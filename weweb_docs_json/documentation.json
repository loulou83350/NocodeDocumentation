[
  {
    "h1": "Introduction​",
    "url": "https://developer.weweb.io",
    "content": "Introduction ​What is WeWeb ? ​weweb.io is a no-code web-app builder where you can drag-and-drop different customizable blocks.Every time you hit publish, we build a JavaScript (Vue.js) application.Then, we prerender each page from it that we host on a content delivery network. Search engines can load them fast and read them easily, improving SEO and overall user-experience.Core concepts ​When you build a WeWeb web-app, you use two type of blocks: Sections and Elements (see below for difference).Under the hood, these two types of blocks are standard Vue components that have special props so that the WeWeb Editor can communicate with them.We provide a lot of base elements (like editable text or image), but you can also develop your own. They are fully customizable and, when you import them in a WeWeb project, they will be usable by builders inside the WeWeb Editor in the same way as our core components (i.e. you will be able to drag-and-drop them on a page and edit their style with no-code).Each element or section have what we call a content: it's a data object that holds your custom properties. There are two contexts when your element or section can be loaded: inside the editor (Editor mode) or inside the published web-app (Front mode). In Editor mode the content is editable by the user, and saved on our database on each change. In Front mode the content can only change if it is bound to a dynamic value.You can use the configuration file to use our build in logic to edit your section/element content, or handle yourself the edition interface. We have a strip logic available, so even if your element/section has a heavy editing logic, this will have no impact on the published web-app. You can learn more about stripping hereYour custom components will inherit the base edition interface, like size, background color or border. Remember that a WeWeb user expects to edit them. You'll want to write your style and javascript with this in mind.If you want to provide values for these WeWeb properties (padding for example), we advise you to drop an instance of your component inside the Editor, change the needed values with the Editor interface, and then save them inside the Design System. The Component source code is responsible for handling content/custom logic, and the Design system is the way to save style/preset of your components.Section vs Element ​A Section is a large block inside WeWeb. Sections are standalone, and cannot be used inside other components. They offer less edition option, but are easier to design because you have more control on the layout they will appear in (they will be a direct child of your page)An Element is a smaller block. Elements can be used by Sections or other Elements and can be repeated.TIPUse a Section if you need to master the layout of your Component or if you will not use it inside other Components. Otherwise go for an Element.You can learn how to create a custom component here."
  },
  {
    "h1": "Add a bindable content property​",
    "url": "https://developer.weweb.io/add-bindable-property.html",
    "content": "Add a bindable content property ​See the Development process to load a base element in dev mod.We will add a text property on our element, so that the user can dynamically change the text of the element.ww-config.js ​The first step is to declare this property on the properties field of the configuration:jsproperties: { // [...] title: { label: { en: \"Title\", }, type: \"Text\", defaultValue: \"My title\", bindable: true, }, }Use the value inside the template ​html<div class=\"my-element\"> <h1>{{ content.title }}</h1> <p :style=\"textStyle\">I am a custom element!</p> </div>And that's all!WARNINGNow that this property is bindable, the user can potentially send you any type of data. Your code needs to be defensive, and check the type of this property.See also: Add a dropzone for binding repeatable content"
  },
  {
    "h1": "Add a dropzone​",
    "url": "https://developer.weweb.io/add-dropzone.html",
    "content": "Add a dropzone ​In WeWeb you can easily create a dropzone, an area where the user will be able to drop in any element. It's useful to build very flexible components.See the Development process to load a base section in dev mod.We will add a header dropzone instead of our title. The user will be able to drop containers, icons, etc...ww-config.js ​The first step is to declare a new property which will hold the references to all the elements dropped.We declare this property on the properties field of the configuration:jsproperties: { // [...] header: { hidden: true, defaultValue: [] }, }TIPA dropzone needs an array of elements, this is why we initialize it with an empty array.TIPWe use hidden: true because there is no way to edit this list on the side panel.Use the value inside the template ​We will use a special component: wwLayout.Full documentation for wwLayout possibilities herehtml<div class=\"my-section\"> <wwLayout path=\"header\" direction=\"column\" class=\"header\"/> <p> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. </p> </div>We also need to add some stylecss.my-section { // [...] .header { min-height: 20px; display: flex; flex-direction: column; } }WARNINGBe sure to give your wwLayout a minimal width and height or the user will not be able to drop elements inside.This is the simpliest way to use wwLayout.We just need to provide the path property which is the path inside the content to access our previously created array.We also give a direction so that the drop zone appears in the right way.Customize the item ​wwLayout by default just repeats the elements. But it also has a scoped slot you can customize to add extra style or property. This is useful to create a card for example or for the editing experience.TIPww-container for example heavily uses this pattern to add handles for defining the grid.Here is an example:js// ww-config.js properties: { // [...] cards: { hidden: true, defaultValue: [] }, }html<div class=\"my-section\"> <wwLayout path=\"cards\" direction=\"row\" class=\"cards\"> <template v-slot=\"{ item }\"> <wwLayoutItem class=\"card\"> <wwObject v-bind=\"item\"> </wwLayoutItem> </template> </wwLayout> </div>css.my-section { .cards { display: flex; justify-content: space-around; } .card { border: 1px solid dashed; padding: 4px; border-radius: 8px; min-width: 100px; } }You can see more options of wwLayout hereBind the content ​If you want, you can mark your content property linked to your dropzone as bindable, with a special binding: repeatableWhen you do that, wwLayout will repeat its first child element for each item in the collection list bound to it, and it will set a binding context for each item.js// ww-config.js properties: { // [...] cards: { hidden: true, bindable: 'repeatable', defaultValue: [] }, }You can learn more about binding here"
  },
  {
    "h1": "Add another element as property​",
    "url": "https://developer.weweb.io/add-element-property.html",
    "content": "Add another element as property ​Why? ​Sometimes we will need to have other element as children, and have more control on it than a dropzone.For example, to add an icon inside a button or to display a text where you forced the text value, but want to allow users to change its style.This is also a common pattern to initialize a dropzone content.Add an element on creation ​See the Development process to load a base section in dev mod.We will replace the title by a ww-text component.ww-config.js ​The first step is to declare this property on the properties field of the configuration:jsproperties: { // [...] title: { hidden: true, defaultValue: { isWwObject: true, type: 'ww-text' }, }, }TIPWe use the special isWwObject property inside defaultValue.We also hide the property from the panel as there is no good way to edit from the sidepanel.Use the value inside the template ​html<div class=\"my-section\"> <wwElement v-bind=\"content.title\" /> <p> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. </p> </div>TIPHere we use the special object wwElement. See here to learn about all the options available.And it's done!Add a forced props ​Some elements can take special props when they are used inside another one.This is the case for ww-text: you can force the text content. In that case, users will no longer be able to edit the text content but can still customize the style of the element.This is very useful when your text is computed by internal logic. This is what we use for the Paginator element for example.js// inside ww-config.js properties: { // [...] priceElement: { hidden: true, defaultValue: { isWwObject: true, type: 'ww-text' }, }, }html<div class=\"my-section\"> <wwElement v-bind=\"content.priceElement\" :ww-props=\"{ text: computedPrice }\"></wwElement> </div>Add an element dynamically ​Sometimes, you will need to create an element after your component has been mounted, in response to a property change for example.Be aware that element creation is only available in the Editor context, so your code needs to be stripped from the production build. (See stripping here)Example: you have a toggle to indicate if an icon is present or not. You create the icon element only when this option is active.You can use wwLib.createElement for that or wwLib.createElementFromTemplate, and the update:content event:jsexport default { // [...] methods: { createIcon() { const icon = wwLib.createElement({ type: \"ww-icon\" }) this.$emit('update', { icon }) } } // [...] }WARNINGElements created this way but not saved anywhere inside an element or a component content will be garbage collected at some point, and will not appear in the published web-app. If you use this method, please store the object in a content after."
  },
  {
    "h1": "Add content property​",
    "url": "https://developer.weweb.io/add-property.html",
    "content": "Add content property ​See the Development process to load a base element in dev mod.We will add a title property on our section, so that the user can dynamically change the title of the section.ww-config.js ​The first step is to declare this property on the properties field of the configuration:jsproperties: { // [...] title: { label: { en: \"Title\", }, type: \"Text\", defaultValue: \"My title\", }, }Use the value inside the template ​html<div class=\"my-element\"> <h1>{{ content.title }}</h1> <p :style=\"textStyle\">I am a custom element !</p> </div>And that's all!TIPIn this use case, it might be better to use a WeWeb text so the user can edit all the text style.See Add a element property"
  },
  {
    "h1": "Add a responsive content property​",
    "url": "https://developer.weweb.io/add-responsive-property.html",
    "content": "Add a responsive content property ​See the Development process to load a base section in dev mod.We will add a titleFontSize property on our section, so that the user can dynamically change the font size of the title. We want this size to depend on the breakpoints.ww-config.js ​The first step is to add the default content value:jsproperties: { // [...] titleFontSize: { label: { en: \"Title font size\", }, type: \"Length\", options: { unitChoices: [{ \"value\": \"px\", \"label\": \"px\", \"min\": 1, \"max\": 100 }] }, responsive: true, defaultValue: \"16px\" }, }Use the value inside the template ​jsexport default { props: { content: { type: \"Object\", required: true }, }, computed: { textStyle() { return { color: this.content.textColor, fontSize: this.content.titleFontSize, }; }, }, };TIPNote here that we don't need anything to handle responsive. WeWeb resolves the inheritance of the different breakpoints for you.We also comment the css style:css.my-section { display: flex; flex-direction: column; align-items: center; min-height: 200px; // h1 { // font-size: 32px; // } p { margin-top: 12px; } }Change the ww-config.json ​We will add a property inside ww-config.json to add a fontSize length input in the Style panel.Test it ​Change the breakpoint in the top right of the Editor navbar, and change the values of the different breakpoints.TIPIn this use case, it can be better to use a WeWeb text so that users can edit the text style.See Add a element property"
  },
  {
    "h1": "Add translated content property​",
    "url": "https://developer.weweb.io/add-translated-property.html",
    "content": "Add translated content property ​See the Development process to load a base section in dev mod.We will add a title property on our section, so that the user can dynamically change the title of the section.We want this title to change depending on the language of the website.ww-config.js ​The first step is to declare this property on the properties field of the configuration:jsproperties: { // [...] title: { label: { en: \"Title\", }, type: \"Text\", defaultValue: \"My title\", multiLang: true, }, }Use the value inside the template ​html<div class=\"my-element\"> <h1>{{ wwLib.wwLang.getText(content.title) }}</h1> <p :style=\"textStyle\">I am a custom element!</p> </div>TIPNote here that we need to use wwLib.wwLangTIPIn this use case, it might be better to use a WeWeb text so users can edit the text style.See Add a element property"
  },
  {
    "h1": "ww-config.js​",
    "url": "https://developer.weweb.io/api",
    "content": "ww-config.js ​options.autoByContent ​Type: boolean (default false)Available for Element onlyDescription: If true, width = auto will use your element size instead of the parent available space.For an example see the behavior of ww-buttonoptions.sizable ​Type: boolean (default false)Available for Element onlyDescription: If true, the editor will display handle to resize your element visually.For an example see the behavior of ww-imageoptions.hyperlink ​Type: boolean (default false)Available for Element onlyDescription: If true, the editor will allow your component to be wrap inside an a tag.editor.label ​Type: translated textAvailable for Section and ElementMandatoryDescription: This is the text use by the editor to label your component through the interface (menu, navigator, ...)editor.noHover ​Type: boolean (default false)Available for Element onlyDescription: If true, the editor will not display an hover effect. Use this property if you want to handle yourself what you display on hovereditor.infoTag ​Type: InfoTag or InfoTag[] or Function returning InfoTag or InfoTag[]Available for Section and ElementDescription: Let you add small tags info on your component floating menu.See ww-text html tag for examplejsinfoTag: content => ({ color: 'var(--ww-color-blue-500)', backgroundColor: 'var(--ww-color-blue-100)', text: content.tag === 'button' ? 'BTN' : content.tag && content.tag.toUpperCase() action: () => { // anything you want to do on click } }),editor.bubble ​Type: Boolean or {icon?: String; color?: String;}Available for Element onlyDescription: Let you add a small bubble in the left top corner. Usefull for selection of container when children take all the content space.tstype InfoTag = { color: string; backgroundColor: string; text?: string; icon?: string; action: function; };properties ​Type: An object with property name as key, and a property as valueAvailable for Section and ElementDescription: Let you describe all your content propertiestriggerEvents ​Type: Array<{ name: String, label: translated text }>Available for Element onlyDescription: Let you describe all the custom event your component can emit. Useful for custom workflows"
  },
  {
    "h1": "Component interface​",
    "url": "https://developer.weweb.io/api/component-interface.html",
    "content": "Component interface ​Props ​content ​Type: ObjectAvailable for Section and ElementAvailable in Editor and Front contextuid ​Type: String IDAvailable for Section and ElementAvailable in Editor and Front contextwwEditorState ​Type: ObjectAvailable for Section and ElementAvailable in Editor context onlyjsconst wwEditorState = { editMode: wwLib.wwEditorHelper.EDIT_MODES.EDITION, isSelected: false, isDoubleSelected: false, isHovered: false, sidepanelContent: {}, isACopy: false, boundProps: { data: true, fontSize: false, }, };wwFrontState ​Type: ObjectAvailable for Section and ElementAvailable in Editor and Front contextjsconst wwFrontState = { lang: \"en\", pageId: \"123544\", sectionId: \"123456\", screenSize: \"desktop\", screnSizes: [\"desktop\", \"tablet\", \"mobile\"], };WARNINGYou will probably never use this property, as weweb.io already handle responsive and translation logic for youwwElementState ​Type: ObjectAvailable for Element onlyAvailable in Editor and Front contextIts a special property for advanced usage, basically to pass custom props to your component.jsconst wwElementState = { props: {}, isInsideLink: false, name: \"My element\", };Event ​js// Inside your component methods you can do this.$emit(\"update:content\", { /*... */ });update:content ​Type: ObjectAvailable for Section and ElementAvailable in Editor onlySee also Update contentupdate:content:effect ​Type: ObjectAvailable for Section and ElementAvailable in Editor onlySee also Update contenttrigger-event ​Type: \"{name: String, payload: any}\"Available in Editor and Front contextDescription: Trigger workflow eventelement-event ​Type: anyAvailable in Editor and Front contextDescription: Trigger event that will be available for the parent elementupdate:sidepanel-content ​Type: { value: any, path: string }Available for Section and ElementAvailable in Editor onlySee also Custom editor interfacechange-menu-visibility ​Type: `BooleanAvailable for Element onlyAvailable in Editor only Toogle menu visibility. Use by certain element to hide the menu"
  },
  {
    "h1": "Content property​",
    "url": "https://developer.weweb.io/api/content-property.html",
    "content": "Content property ​Each content property is describe with an object which has the following properties.property.label ​Type: translated textMandatoryAvailable for Section and ElementDescription: Label used by the editor on the edit panel interfaceproperty.section ​Type: style or settings (default is style)Available for Section and ElementDescription: Determine in which panel's tab the property will be displayproperty.defaultValue ​Type: anyAvailable for Section and ElementDescription: This the default value of the property if empty.TIPThis can be very useful to create child element. See Add element propertyproperty.options ​Type: Object or an EditorFunction returning an objectAvailable for Section and ElementDescription: List of options pass to the ux component used in the edit panel.See available options (depending on the type) hereproperty.type ​Type: stringMandatory if your property is not hiddenAvailable for Section and ElementDescription: The type of your property. It is used to know which user interface display to edit your property inside edit panel.A complete list of available types are availabe hereproperty.multiLang ​Type: boolean (default false)Available for Section and ElementDescription: Will treat your property as a translated objectSee also Add a translated text propertyproperty.responsive ​Type: boolean (default false)Available for Section and ElementDescription: Indicate that your property can be different depending on the current screenSee also Add a responsive propertyproperty.states ​Type: boolean (default false)Available for Element onlyDescription: Indicate that your property can be different depending on the current state (hover for example, or a custom one)See also Use element stateproperty.bindable ​Type: boolean | list | repeatable (default false)Available for Section and ElementDescription: Indicate that your property can be binded. The type of binding depend on the value true: bind to a primitivelist: bind to an arrayrepeatable: special binding to connect to a dropzone and repeat contentSee also Add a bindable property and Add a dropzoneproperty.editorOnly ​Type: boolean (default false)Available for Section and ElementDescription: Indicate if this property is only needed in editor. The data will not be saved inside content, and can be retrieve and modified in an other way. This is usefull for adding some editing logicSee also Custom editor interfaceproperty.hidden ​Type: boolean or an EditorFunction returning a boolean (default false)Available for Section and ElementDescription: Indicate if this property should be hidden from the EditorPanel. This is usefull for dropzone or if you provide yourself a custom way to edit this propertySee also Custom editor interfaceEditor Function ​Some options of a content property can take a function rather than static value. This enable a better UX experience by making the sidepanel dynamic. The arguments of this function are:content: the current content of the componentsidepanelContent: the current editor only content of the componentboundsProps: an object with property name as prop, and true as value if the props is currently boundAvailable Types ​Array ​js{ type: \"Array\", label: { \"en\": \"List of items\" }, options: { item: { [...] // a content property }, fixed: false // if true, do not display add and remove button } },WARNINGAll property except responsive and states are supported for child propertiesBigButtons ​js{ label: { en: 'Presets' }, type: 'BigButtons', options: { action: 'setPreset', values: [ { icon: 'two-columns-mosaic', id: 'two-columns-mosaic' }, { icon: 'three-columns-mosaic', id: 'three-columns-mosaic' }, { icon: 'four-columns-mosaic', id: 'four-columns-mosaic' }, { icon: 'five-columns-mosaic', id: 'five-columns-mosaic' }, ], } }Used to display a button on the edit panel.TIPVery usefull for quick presets action buttonsThis used with editorOnly: true as it has no valueBigIconRadioGroup ​js{ label: { en: 'Display type', fr: \"Type d'affichage\" }, type: 'BigIconRadioGroup', options: [ { icon: 'type-columns', value: 'columns', label: 'Columns' }]), { icon: 'type-rows', value: 'rows', label: 'Rows' }, { icon: 'type-mosaic', value: 'mosaic', label: 'Mosaic' }, ], defaultValue: 'columns', }Button ​json{ \"type\": \"Button\", \"label\": null, \"options\": { // Translated text to be displayed inside button \"text\": { \"en\": \"Click me\" }, \"action\": \"display\" // name of one of your component methods } },Used to display a button on the edit panel.TIPThis used with editorOnly: true as it has no valueColor ​json{ \"type\": \"Color\", \"label\": { \"en\": \"Text color\", \"fr\": \"Couleur du texte\" }, \"options\": { \"nullable\": true, // boolean (default: false). If true color can be null \"gradient\": true // boolean (default: false). If true can return gradient string } },Return a stringCssFilter ​json{ \"type\": \"CssFilter\", \"label\": { \"en\": \"Filters\", \"fr\": \"Filtres\" }, },Return a stringFontFamily ​json{ \"type\": \"FontFamily\", \"label\": { \"en\": \"Font Family\", }, },Return a stringIcon ​json{ \"type\": \"Icon\", \"label\": { \"en\": \"Icon\", }, },Return a stringImage: ​json{ \"type\": \"Image\", \"label\": { \"en\": \"Image\", \"fr\": \"Image\" }, },Return a string representing an image pathInfo: ​js{ label: { en: 'Text', fr: 'Texte', }, type: 'Info', options: { text: { en: 'Click text to edit' }, }, },TIPThis is usefull if you still want this property on the sidepanel for binding, but provide your own edition ux, like text hereLength ​json{ \"type\": \"Length\", \"label\": { \"en\": \"Size\", \"fr\": \"Taille\" }, \"options\": { \"unitChoices\": [ { \"value\": \"px\", \"label\": \"px\", \"min\": 1, \"max\": 1000 }, { \"value\": \"%\", \"label\": \"%\", \"min\": 1, \"max\": 100 } ] } }Return a string representing a length (value + unit)Number ​json{ \"type\": \"Number\", \"label\": { \"en\": \"Number of columns\", \"fr\": \"Nombres de colonnes\" }, \"options\": { \"min\": 1, // default 0 \"max\": 10, // default 100, \"step\": 1 // default 1 } }Return a NumberObject ​js{ type: \"Object\", label: { \"en\": \"Parameters\" }, options: { item: { { prop1: [...] // Content property prop2: [...] // Content property } }, } }This is usefull if you want nested properties. We still encourage you to use as flat as possible content.WARNINGAll property except responsive and states are supported for child propertiesOnOff ​json{ \"type\": \"OnOff\", \"label\": { \"en\": \"Use icon?\", \"fr\": \"Utiliser un icône?\" } }Return a BooleanScript ​json{ \"type\": \"Script\", \"label\": { \"en\": \"Custom js\" } }Return a stringSection ​json{ \"type\": \"Section\", \"label\": { \"en\": \"Section\" } }Return a section idShadows ​json{ \"type\": \"Shadows\", \"label\": { \"en\": \"Shadows\", \"fr\": \"Ombres\" }, \"options\": { \"isText\": true // default: false. If true return text-shadow css compatible value } }Return a stringText ​json{ \"label\": { \"en\": \"Alt\", \"fr\": \"Alt\" }, \"type\": \"Text\", \"options\": { \"placeholder\": \"Image description\" // all input[type = text] options are supported } }Return a stringTextarea ​json{ \"label\": { \"en\": \"Description\", \"fr\": \"Description\" }, \"type\": \"Textarea\", \"options\": { \"placeholder\": \"Image description\" // all textarea options are supported } }Return a stringTextRadioGroup ​json{ \"type\": \"TextRadioGroup\", \"label\": { \"en\": \"Alignement\", \"fr\": \"Alignement\" } \"options\": { \"choices\": [ { \"value\": \"left\", \"default\": true, \"title\": { \"en\": \"Left\", \"fr\": \"Gauche\" }, \"icon\": \"text-align-left\" }, { \"value\": \"center\", \"title\": { \"en\": \"Center\", \"fr\": \"Milieu\" }, \"icon\": \"text-align-center\" }, { \"value\": \"right\", \"title\": { \"en\": \"Right\", \"fr\": \"Droite\" }, \"icon\": \"text-align-right\" }, { \"value\": \"justify\", \"title\": { \"en\": \"Justify\", \"fr\": \"Justifié\" }, \"icon\": \"text-align-justify\" } ] } }Return type of valueTextSelect ​json{ \"label\": { \"en\": \"Font weight\", \"fr\": \"Graisse\" }, \"type\": \"TextSelect\", \"options\": { \"options\": [ { \"value\": null, \"label\": { \"en\": \"Default\", \"fr\": \"Par défaut\" } }, { \"value\": 100, \"label\": { \"en\": \"100 - Thin\" } }, { \"value\": 200, \"label\": { \"en\": \"200 - Extra Light\" } }, { \"value\": 300, \"label\": { \"en\": \"300 - Light\" } }, { \"value\": 400, \"label\": { \"en\": \"400 - Normal\" } }, { \"value\": 500, \"label\": { \"en\": \"500 - Medium\" } }, { \"value\": 600, \"label\": { \"en\": \"600 - Semi Bold\" } }, { \"value\": 700, \"label\": { \"en\": \"700 - Bold\" } }, { \"value\": 800, \"label\": { \"en\": \"800 - Extra Bold\" } }, { \"value\": 900, \"label\": { \"en\": \"900 - Black\" } } ] } }Video ​json{ \"label\": { \"en\": \"Video url\", \"fr\": \"Video url\" }, \"type\": \"Video\" }Return a string"
  },
  {
    "h1": "weweb.io objects​",
    "url": "https://developer.weweb.io/api/weweb-io-objects.html",
    "content": "weweb.io objects ​Editor properties ​weweb.io Editor handle by default some properties of your component listed below. Do not handle them yourselfSection ​Height of the root html elementMax width of the root html elementPositioning of the root html element contentPadding and margin of the root html elementBackground of the root html elementBorders and Shadow of the root html elementTag of the root elementElement ​Width, max-width, height of the root html elementPositioning of the root html element contentPadding and margin of the root html elementBackground of the root html elementBorders and Shadow of the root html elementId and class of the root elementLink wrapping your whole elementTranslated text ​weweb.io use a custom way to handle translation. We use object with lang as key to store the different variants. Value can be anything (usefull for handle any kind of content which need to change depending on the locale)To \"translate\", use wwLib.wwLang.See also Add a translated text propertywwLib global variable ​wwLib.wwLang ​wwLib.createElement ​wwLib.createElementFromTemplate ​wwLib.getFrontWindow ​Global components and directive ​wwLayout component ​This is a Vue component which allow to have a dropzone. See more here.It just repeat children elements, and handle drag and drop for you. You still need to handle the css yourself.Available props:tag: String: change the tag root elementdirection: 'column' | 'row' (default column): Change the ux of the dropzone. You are still responsible of the css to display childrendisableDragDrop: Boolean (default false): Disable the drag and drop if you are handling child add/remove yourselfEvents:update:list: Emit each time a child element is added or removedwwElement component ​wwEditableText component ​ww-responsive directive ​"
  },
  {
    "h1": "ww-config.js​",
    "url": "https://developer.weweb.io/api/ww-config-js.html",
    "content": "ww-config.js ​options.autoByContent ​Type: boolean (default false)Available for Element onlyDescription: If true, width = auto will use your element size instead of the parent available space.For an example see the behavior of ww-buttonoptions.sizable ​Type: boolean (default false)Available for Element onlyDescription: If true, the editor will display handle to resize your element visually.For an example see the behavior of ww-imageoptions.hyperlink ​Type: boolean (default false)Available for Element onlyDescription: If true, the editor will allow your component to be wrap inside an a tag.editor.label ​Type: translated textAvailable for Section and ElementMandatoryDescription: This is the text use by the editor to label your component through the interface (menu, navigator, ...)editor.noHover ​Type: boolean (default false)Available for Element onlyDescription: If true, the editor will not display an hover effect. Use this property if you want to handle yourself what you display on hovereditor.infoTag ​Type: InfoTag or InfoTag[] or Function returning InfoTag or InfoTag[]Available for Section and ElementDescription: Let you add small tags info on your component floating menu.See ww-text html tag for examplejsinfoTag: content => ({ color: 'var(--ww-color-blue-500)', backgroundColor: 'var(--ww-color-blue-100)', text: content.tag === 'button' ? 'BTN' : content.tag && content.tag.toUpperCase() action: () => { // anything you want to do on click } }),editor.bubble ​Type: Boolean or {icon?: String; color?: String;}Available for Element onlyDescription: Let you add a small bubble in the left top corner. Usefull for selection of container when children take all the content space.tstype InfoTag = { color: string; backgroundColor: string; text?: string; icon?: string; action: function; };properties ​Type: An object with property name as key, and a property as valueAvailable for Section and ElementDescription: Let you describe all your content propertiestriggerEvents ​Type: Array<{ name: String, label: translated text }>Available for Element onlyDescription: Let you describe all the custom event your component can emit. Useful for custom workflows"
  },
  {
    "h1": "Anatomy of a component​",
    "url": "https://developer.weweb.io/component-anatomy.html",
    "content": "Anatomy of a component ​Pre-requisites ​We consider that you are familiar with Vue development.You can see the excellent Vue documentation here.TIPWeWeb relies on version 3 of Vue.There are two files you will edit:src/wwElement.vue or src/wwSection.vue which is the Vue component displayed in the Editor and the published web-app.ww-config.js which describes the different properties of your component so that WeWeb knows how to interact with your componentVue component ​See the Development process to load a base component in dev mod.For now your Vue component is simple. It received the content props from the Editor, and uses it to add some style on text:jsexport default { // [...] props: { content: { type: \"Object\", required: true }, }, computed: { textStyle() { return { color: this.content.textColor, }; }, }, // [...] };html<h1 :style=\"textStyle\">My Title</h1>The content props is where your component's editable data lives. Each time this content changes via the Editor, the component will receive a new updated content object and, thanks to Vue's reactivity, your component will refresh its template.TIPWeWeb handles a lot of things for you like translation, responsive or binding so that you will always receive a simple content object without having to think about it.content can have any shape you want, but we encourage you the keep it as flat as possible, because it interacts better with a lof of WeWeb features. You can put any style and html you want to your component. Just keep in mind that your root element will be editable via WeWeb's default editor.It is also required that your template has a root element, and is not a fragment.WARNINGAvoid using link or defining styles like padding which are handled by the Editor.See a complete list hereww-config.js ​This file describes the metadata of your component. All the desired properties of your content need to be listed here. You also have a lot of options to customize the Editor's side panel, the different menus and interactions inside WeWeb's Editor:jsexport default { editor: { label: { en: \"My Element\", }, }, properties: { textColor: { label: { en: \"Text color\", }, type: \"Color\", defaultValue: \"#F23636\", }, }, };editor describes the interaction of your component inside the WeWeb Editorlabel is a translated text used by the Editor for the menu, side panel titles, or navigatorA lot of other options are available, there are listed hereproperties is an object which describes all your content propertiesEach content property will describe the corresponding property inside content (if your property name is textColor, it will be available in this.content.textColor)type lets WeWeb's Editor display the correct user interface to edit your property. A list of all available types and their options are available hereTIPDefining all your properties inside ww-config.js is mandatory. You can decide to handle yourself the edition update by using a custom editor interface.For that, you can use the hidden option to hide it from the edition panel.Using the configuration file is still the quickest way to make your content editable by users and offer a uniform edition experience for users across all the components.Your turn! ​If you want to add more properties take a look at our cookbook.Add a propertyAdd a dropzoneAdd a responsive propertyAdd a bindable propertyAdd a translated text property"
  },
  {
    "h1": "Custom editor interface​",
    "url": "https://developer.weweb.io/custom-editor-interface.html",
    "content": "Custom editor interface ​Soon"
  },
  {
    "h1": "Development process​",
    "url": "https://developer.weweb.io/development-process.html",
    "content": "Development process ​Even if your WeWeb components are standard Vue components, they need to be loaded inside a specific context to be tested. The easiest way to test is to use the WeWeb Editor in development mode. Here is a description of the different steps to test and develop your component.Initiate your directory ​Compatibility noteweweb-cli requires Node.js version >=18.0.0. weweb.io use Vue 3We provide a npm template to quickly start development.For npmshellnpm init @weweb/componentFor yarnshellyarn create @weweb/componentThen you have to follow the different prompt questions.If you already know what you want, you can pass the component name and the type of component you want via additional command line options.For example, if you want to create an element named my-element or a section named hero-section:shell# npm 6.x (use npm -v to know your version) npm init @weweb/component my-element --type element npm init @weweb/component hero-section --type section # npm 7+, extra double-dash is needed (use npm -v to know your version) npm init @weweb/component my-element -- --type element npm init @weweb/component hero-section -- --type section # yarn yarn create @weweb/component my-element --type element yarn create @weweb/component hero-section --type sectionThe directory will contain:a src directory with a file for your component (wwSection.vue or wwElement.vue). Available props and events are listed herea package.json with two scripts for dev and build, and weweb/cli as dependenciesa basic README.mda ww-config.js describing all the properties of your component. Learn more about it hereWARNINGYou can add other dependencies if you need to. Be aware that all package.json will be merged in the final web-app and, if two components need the same dependencies, only the more recent one will be installed. This can lead to conflicts.DANGERYou do not need vue as a dependency, as it will be already provided by the Editor or the application.Install dependencies and start dev server ​Go to the directory you just created, install dependencies and start a dev server.For npm:shell# Install dependencies npm install # Start with default 8080 port npm run serve # Or give a port (usefull if you are developing several components) npm run serve -- port=4040For yarn:shell# Install dependencies yarn # Start with default 8080 port yarn serve # Or give a port (usefull if you are developing several components) yarn serve -- port=4040We use https to serve components. Your browser needs to authorize this.Go to https://localhost:8080 (or the port you choose).Click on Advanced Settings then on Continue to localhostChrome settingsIf you do not see Advanced settings, type chrome://flags as a URL in your browser. Search for Allow invalid certificates for resources loaded from localhost and click EnableLoad your component inside weweb.io in dev mode ​Go to your dashboard and open the Editor of one of your projects.Click on the Dev tab, and then on \"Open Dev Editor\" Editor devWe use another version of the Editor to display your component while you are working on it. Because it requires a specific build of the Editor, you need to use this special version.Open the dev tab again.Select Element, Section or Plugin depending on your need.Then click on Add local Element.Give it a name and put the port where you start you dev server (8080 by default). If you did not do it before, you have a quick access to authorize the SSL certificate.DANGERBecause during development you can broke the integrity of your component content, or use non existing yet components the autosave is disabled. This means that you can safely try things, but also that everything will be reloaded when refreshing the page.Each time you change the code, the component will be refreshed inside the Editor.Display and develop your component ​You just have to drag-and-drop your component from the dev panel where you want to test it.You can see the next section for more information about what you can do with your componentPush in production ​When you are satisfied with your version, you can publish it. WeWeb relies on Github to version components.We advise you to also clear the Local Development before moving to the next step (same panel as for adding one).New component ​If you are creating a new component, create a repository on Github and push your code.Then go to your dashboard, and add a source code pointing to your Github repository.Open the Editor (in normal mode, not dev), click on the Dev tab, and search on the bottom of the panel the source code of your component. Drag-and-drop it on the page.If you'd like, you can also add some base style (padding, background color, some children, etc) and add it to your Design System.TIPThis last step is not mandatory because you can always load your component from source code. But it offers a better user experience.Updating existing component ​If you are updating an existing component, update the version field in package.json and push to Github.Then go to your Dashboard source code, search your component, and change the version (we have a hook on Github that will trigger a build each time you push to the pointed branch).Check that everything is working as excepted.TIPYour component will not be updated inside your web-app until you change the active version in the dashboard.And voilà!"
  },
  {
    "h1": "Stripping editor code​",
    "url": "https://developer.weweb.io/stripping.html",
    "content": "Stripping editor code ​"
  },
  {
    "h1": "Update yourself the content​",
    "url": "https://developer.weweb.io/update-content.html",
    "content": "Update yourself the content ​Soon"
  },
  {
    "h1": "Use element state​",
    "url": "https://developer.weweb.io/use-element-state.html",
    "content": "Use element state ​Soon"
  },
  {
    "h1": "Welcome​",
    "url": "https://docs.weweb.io",
    "content": "Welcome ​WeWeb is a no-code web application builder with a smart AI agent at its core, allowing you to create using natural language while retaining full control through its powerful visual editor. Designed for users of all skill levels, it streamlines the development of production-grade web applications with unmatched speed, ease, and efficiencyWeWeb gives you the perfect trilogy of:Design freedom: build gorgeous interfaces with pixel-perfect controlDevelopment flexibility: connect any backend and create workflows code-freeDeployment freedom: host with WeWeb or self-host anywhereNew to WeWeb? ​🤷 I'm a complete beginner and want to learn about WeWeb and decoupled web-app development.🔌 I'm comfortable with the design side of things. Teach me how to connect a backend.⚡ I know what I'm doing. Teach me how to add business logic to my WeWeb app.🧰 I want to be inspired. Show me how to build things from A to Z.Are you a Developer? ​We have a dedicated developer documentation for you 🙂"
  },
  {
    "h1": "Data Grid​",
    "url": "https://docs.weweb.io/add-elements/elements/data-grid.html",
    "content": "Data Grid ​Add the Data Grid to a Project ​When you drag-and-drop the Data Grid Element on the Canvas, you will be asked if you want to import Variables: You don't have to but, if you do, the Element will come with a ready-made Variable that contains fake data: We did this to help you understand what kind of data the Element expects – in this case, a list of items – and how it works.But let's have a look at how you can display your own data in the Data Grid.Display Data in the Data Grid Element ​In the example below, we replaced the fake data with one of our Collections, a list of rental cars with their current location and mileage: To ensure the Data Grid can understand which are unique, we mapped the \"Unique id\" property to the Airtable id in our Collection.Then, we mapped each column in the Data Grid to a field in our database: 🚨 Warning 🚨Inline editing is only available for field types that are built in the data grid. You can display other Elements using the Custom type but users won't be able to update the values of these fields.Let Users Edit or Delete a Record ​If you want to edit or delete a record in your database, you'll need to enable the Inline editing option in the Data Grid: This will display the column with the little pencil (to edit) and bin (to delete) records.When the user clicks on one of these icons, it will trigger the corresponding Workflow: Note that the two triggers are:On update row, andOn delete row.If you delete them by mistake, you can easily recreate them with these triggers 🙂To update (or delete) a record, the first thing you'll need to do is tell your database what is the unique id of the item you selected: Then, you can update the fields you want in your database.In the example below, we are updating our record with the value we have for the mileage field in our Data Grid: TIPWith the \"Allow selection\" option enabled, you can let users select and delete multiple items at the same time. You'll find a step-by-step walkthrough on how to set this up at the end of the video above (hint: it requires a workflow with a for loop on the \"Selected Rows\" variable)."
  },
  {
    "h1": "Language Input​",
    "url": "https://docs.weweb.io/add-elements/elements/language.html",
    "content": "Language Input ​The Language Input dropdown provides the language options available for the page.You cannot modify the options in this dropdown. Instead, the options automatically reflect the languages you have enabled for the page. For more information about page languages, please refer to the App Settings.Once a desired language is selected from this dropdown, the page language changes automatically, eliminating the need to create a specific workflow."
  },
  {
    "h1": "Paginator​",
    "url": "https://docs.weweb.io/add-elements/elements/paginator.html",
    "content": "Paginator ​In this article, we explain how to:Style the Paginator elementFilter a collection in the frontend using the Paginator elementFilter a collection in the backend using the Paginator elementStyling the Paginator ​You can style any element inside the Paginator, change the style of the arrows or change the color of the active page number for example.To change the color of the active page number:select the \"Text\" element inside the Paginator,create an active state in the style section of this element,select the active state and style it like you would any other state.In the example below, we styled the Paginator's \"Text\" element so that the active page number appears blue and bold:Frontend pagination ​Before we go any further, note that when you add pagination in the frontend, all your collection items loaded in the user's browser, even if only 10 items are displayed on the page.If you do not want this to happen, consider adding pagination in your backend before fetching the collection in WeWeb.Learn more about server-side (backend) vs client-side (frontend) pagination here.If you do want to add pagination in the frontend, here's how you do it in WeWeb:drag-and-drop the Paginator element on the page that displays the collection you want to paginateensure the collection on the page is bound to the Collection object and not a Collection['data'] arraytell the Paginator which collection you want to paginate using the Collection dropdown:WARNINGThis is not intuitive but, for the Paginator element to work, the Collection it relates to must be bound to the Collection object, not Collection['data']. This is because Collection['data'] only includes the list of items in our Collection and we need the information about the current page which is in the Collection object.To learn more about frontend pagination in the context of a real project, consider watching this video from level 1 of the WeWeb Academy:The limits of frontend pagination ​With frontend pagination, data that is not displayed on the page is still accessible in the browser:This has two consequences:the data being loaded may still be heavy enough to slow the browser down or strain your visitors' data planseven though it is not displayed on the page, the data is accessible to anyone who knows where to look for it, i.e. in the inspector / network.If you want to avoid this, consider adding pagination in the backend instead.Backend pagination ​When working with large amounts of data, it is best practice to paginate your Collection of data in the backend.If you paginate a Collection in the frontend, the entire set of data will be loaded in your users' browsers, even if you only display 10 items on the page.This is a big no-no if you're working with a heavy set of data as your users' browsers will crash.People often talk about millions of records but another way to look at it is in terms of volume. The less you tap into your users mobile data plans, the better.This next steps explain how to setup custom pagination on the Paginator Element.WARNINGHow you add pagination to a table in your backend is specific to your backend. Here, we will illustrate how to add Custom pagination on the WeWeb Paginator element using a Xano endpoint. If you are having trouble to follow along with a different backend, please check the user docs of your backend provider.Step 1: add paging to the backend ​In Xano, you'll need to enable Paging in the Output of your query:If you run and debug your API call, you should now see additional information in Xano like the number of itemsReceived and total number of pages, i.e. pageTotal:In WeWeb, the collection should look something like this with context about the collection in addition to the items:Note that, in the screenshot above, we can see Xano sends back 5 items. This is because we asked for 5 items per page when we enabled Paging in Xano.Step 2: have the backend listen for info about the current page and offset ​With the WeWeb Paginator element, we can send info about the current page and offset to tell Xano what items the user needs to see next. In order to to feed that information to Xano, we will create two integer inputs in Xano – page and offset – which we'll map in the External tab:TIPIn the context of pagination in web development, offset refers to the number of items that should be skipped from the beginning of a dataset when displaying a particular page of results.For example, let's say we have a list of 50 items, and we want to display 10 items per page. To display the second page of results, we would need to skip the first 10 items (i.e., the offset would be 10), and then display the next 10 items.Step 3: test the API call ​Through a \"Run & Debug\" in Xano and/or in a Collection in WeWeb, test your API call to make sure it sends back the data you expect depending on the page or offset you send.Here we chose to tell Xano which page we want:TIPTest your API call with different pages and offsets, including the first and last page to ensure that your backend is sending the right items based on the information the frontend is requesting.Don’t worry about making the call dynamic yet, just try with a few values to make sure the response is what you expect.Step 4: create a paginator variable ​Create a paginator variable of type Object with the default values your backend needs to send the first items you want to display from your table.Usually, the default page value should be 1 – paginator is on the first page – and the default offset value should be 0 – no items should be skipped:Step 5: Paginator workflow ​On the page with the collection you want to paginate, add the WeWeb paginator element with a workflow that:triggers On changeupdates the paginator object variable with the information from the eventrefetches the Collection you are working withThat way your paginator variable will have the up to date offset and current page so however you chose to make the call to Xano, you’ll have the correct info based on user interactions with the paginator.Step 6: Paginator settings ​On the paginator element, enable \"Custom pagination\", and bind:the total items returned by your backend (e.g. Xano sends back itemsTotal),the fixed number of items per page (note: this is NOT the number of items received because if you’re on the last page of the collection, the backend might return only 17 items leftover instead of the full 25 per page for example)the offset – the offset should be current page (from the paginator event) - 1 * number of items per pageStep 7: bind the collection ​In WeWeb, instead of binding your collection to the collection with its metadata, you'll need to bind directly to an array or list of items.If we take Xano as an example, that means instead of binding to Collection['data'] or Collection, you'll need to bind Collection['data']['items']:This is because the container to which you bind the collection expects an Array, i.e. a list of items.The binding of the Collection List items is the same as with any other Collection List. If you're unsure how to display the job title or company logo on the page, please refer to the user documentation on binding.Step 8: make your API call dynamic ​Back in your collection, you can now bind the input you are sending to your backend to the data in your paginator variable (for example, the page or offset).The input you send to your backend will depend on the info your backend needs to return the items you want.And voilà! You should be good to go.Enable the Preview mode to check that everything is working correctly.Setting up backend pagination can be challenging. Please don't hesitate to reach out to the WeWeb Community if you get stuck."
  },
  {
    "h1": "Binding data​",
    "url": "https://docs.weweb.io/binding-filtering/binding-concept.html",
    "content": "Binding data ​Binding concept ​In WeWeb, binding consists in displaying external data in your app. This is is often parsed JSON coming from 3rd-party APIs or tools like Airtable or Xano.You can also use formulas to manipulate this data.When bound, the data is displayed in the app. It can be displayed as text, as an image, as a link, as a list, etc. Everytime the data is updated, the app is updated too.TIPOutside of texts and images, all the CSS properties or elements settings can also be bound. Meaning you can control your app behavior and design from an external source.Binding simple data ​Let's take a simple example. Let's say you want to display the current logged-in user name in your app.To do this, you would need to bind a text element to the name property of the user object:Another example would be to display an image coming from a REST API:Lastly, you can also bind a CSS property to any value, in this example, a variable in your app:Binding an array of data ​You can also bind an array of data. This is useful when you want to display a list of items.The main use-case would be to display a list of items coming from an API. Let's say you want to display a list of companies coming from an API:Some explanations are needed here.The companies array (collection) is bond to the main container. Then, the first container's child (here, the card) gets repeated for every element in the array.Then, every element in the child can be bound to a field in the array's element. For example, the image element is bound to the logo field of the company object.Using formulas in bindings ​You can also use formulas in bindings. This is useful when you want to manipulate data before displaying it.For example, let's say you want to display a text composed of two or more fields. You could use the concatenate formula to do this:"
  },
  {
    "h1": "Display collection data​",
    "url": "https://docs.weweb.io/binding-filtering/display-data.html",
    "content": "Display collection data ​Before you can display collection data on a page, make sure you have:Added a data source from the data menu, andSet up a data collection that fetches data from a data source.Learn how to add data sources:AirtableXanoREST APISQLSmartSuiteSupabaseOnce those pre-requisites are met, you will be able to display data from a collection on a page.Step 1 - Bind a Collection List to a Container ​In WeWeb, you can bind a collection to any container: a flexbox, a collection list, a table, a columns element, any container.You do this by selecting the container in the navigator, and binding that container to a list of items:Keep in mind that, bar one specific exception we will discuss later, you should always bind to a list of items, also called an Array. Learn more about the Array data type.In WeWeb, this is represented by collection_name[‘data’] in the no-code formula input as shown above.Step 2 - Bind the Data from a Collection Item to an Element ​When you bind a list of items to a container, the first child of that element will be a collection item, also called a repeated item.What does that mean? 🤔It means that, if you want to bind several pieces of information from one collection item – like a job title, company name, salary, etc. – the first child of your collection list needs to be a container that includes several elements.In the example above, you can see that, right below the “Jobs” columns element where we bound our list of jobs, there is a container named “Job Wrapper”.Inside that “Job Wrapper” element, there are other elements that we can bind to specific data fields in our list of jobs:Company logoCompany nameJob titleJob locationContract typeSalaryList of perksAll of the elements with a purple plug in the navigator are bound to a specific field of the collection item:TIPYou can rename any type of container \"Collection List\" in the element’s settings. If you rename a container \"Collection List\", a purple icon will be displayed in the Layout panel and on the canvas to help you see where you can bind the data from the collection."
  },
  {
    "h1": "Load more button​",
    "url": "https://docs.weweb.io/binding-filtering/load-more-button.html",
    "content": "Load more button ​A simple way to paginate a collection is to use the Paginator element.Another way is to add a button on the page with a workflow to load more items from your collection every time a user clicks on the button.Step 1: Add a button ​Drag-and-drop a Button on the Canvas or Navigator, wherever you want to display it on the Page.In the example below, we placed it below our list of calls:Step 2: Create a variable ​This Variable will be called loadMore and of type Number.Its default value will be the number of items you want to display on the page by default.In the example below, we want to display 5 items by default.Step 3: Add a workflow ​On the button you created in step 1, add a workflow to Change variable value of the variable you created in step 2.In the example below, we are saying:when the user clicks on the button,add 5 to the loadMore variableAs a result, every time a user clicks on the button, the loadMore variable will be incremented by 5:Step 4: Link the collection to the variable ​Now, when we bind our Collection List, we need to tell the browser to display the number of items in the loadMore variable we defined in step 2.In order to do that, we have to slice our list:WARNINGThe slice formula is an Array function so you need to bind to your collection['data']. If you bind to collection, it will not work because you are binding to an Object.In the screenshot above, we see that:we are binding to a list of items calls['data'] instead of the entire collection object callswe are using the slice no-code formula to display the items from index 0 to the index XX changes based on the value of the loadMore variable, which changes every time the user clicks on the button (see step 3)Step 5: Test in Preview ​Ok, that should work.Back in Preview mode, you can click on the button to see the loadMore variable be updated in the Navigator and the additional items displayed on the page:"
  },
  {
    "h1": "Build a Job Board with WeWeb and Xano​",
    "url": "https://docs.weweb.io/build-guides/job-board-with-xano.html",
    "content": "Build a Job Board with WeWeb and Xano ​WARNINGThe build guide below was created using an older version of WeWeb.We are currently working on a new build guide using Xano's Careers template and WeWeb's latest Job board template.In this use case walkthrough, we use two templates to get started quickly:WeWeb’s “Job Board” template for the frontend, andXano’s “Careers” template for the backend.You can follow a video walkthrough here or read a step-by-step guide below:1- Setup new projects in Xano and WeWeb ​In Xano ​Create a free XANO account and choose the “Careers” template in the Marketplace:You’ll notice 3 tables and 16 API endpoints are created automatically:jobapplicationcategoryThis is where you’ll find your list of jobs, applications, and job categories respectively.The 16 API endpoints are how you’ll be able to fetch data from your Xano tables to display it in WeWeb.If you’re not familiar with APIs, you might want to pause and learn more here.In WeWeb ​In WeWeb, create a new project and choose the “Job board” template.You’ll notice a page where you can add your list of jobs and a page where you can display the details of a job offer:2- Display a list of jobs in WeWeb ​In order to display data in WeWeb, we'll need to:Add the Xano data source pluginGet data from a Xano endpointBind that data to an element on the pageStep 1: Add Xano data source ​Go to Plugins > Data sources > Xano:You will be invited to add your Xano API and choose the instance you want to work with.Step 2: Get the data from Xano ​Go to Data > Collections > Add collection to create a Jobs collection that will call the API endpoint in Xano that returns the 6 items we have in the job table:Step 3: Bind the collection list and collection list item on the page ​On the “Jobs” page, bind the “Collection List” of jobs to the items in the Jobs collection:You will notice that, once you bind your collection, even if you only have one Job container in the navigator, you’ll have as many repeated items on the page as there are items in your Xano database.TIPIn WeWeb, you can bind a list to any type of container (e.g. columns, flexbox, table) but it is important to realize that the repeated items of that list will be the first child of the bound container. If you want the repeated item to be a card, you can add a container with text, image, and other elements inside.Inside the “Job container”, i.e. the first child element of the container where you bound the collection, you can then bind the information from a repeated item.In the example below, we bound the job title and type of contract:3- Search, sort & filter a list of jobs in WeWeb ​When you have a list of items on a page, it is common to let users filter that list by searching for a term or selecting an option for example.Searching through a list in WeWeb ​There is a search bar element by default on the “Jobs” page of the “Job board” template in WeWeb.However, if you ever needed to add a search, know that you can find them in the Add menu of the Editor:Whenever a search bar element is dragged and dropped onto the page, a new component variable is created in your project.By default, it is named “Search bar - value” but you can change the name in the element’s settings. You can also change the placeholder of the element in its settings:In preview mode, you can type in search terms in the search bar to see the “Search bar - value” variable change in your navigator:Once you’ve set up the search bar element on the page, you’ll need to add a filter to your list of jobs.You could do this several ways.Backend filter ​If you were working with a large collection of items, say more than 10Mb, the best practice would be to add a search filter to your backend so that the REST API collection in WeWeb only fetched data that matches the search criteria.This takes a little bit more time, usually a couple of seconds, but has two main benefits:You can choose what data you load in your user’s browser (hint: nothing sensitive!)You don’t load as much data in your user’s browser and therefore don’t risk crashing it.TIPFilter on the backend when there’s a high volume of data and/or the data is sensitive (health information for example)Filter on the frontend when there’s not that much data and you want your browser to react fast to user interactions. For example, when you need to re-arrange the data that has already been uploaded to the browser.For the purposes of this tutorial, since WeWeb is a frontend builder, we’ll explain how to add a search filter to your frontend but please bear in mind that, if you’re working with large collections, you should spend a little more time learning how to add a search filter in your backend.Frontend filter ​To search in the frontend in WeWeb:Add a filter to your Collection List,Where the field you want to search “Contains” the “Search bar - value” component variable, andApply this filter if… the “Search bar - value” component variable is not empty.In the example below, we are filtering the jobs list based on whether the search term is in the title or summary of the job description:Filtering a list with a select element ​Now let’s say you also want to filter the job list by job category.First, you’ll want to create a new collection for job categories in WeWeb, using the API endpoint to query all categories from Xano.Not sure how to do that? Might want to revisit how we created the Jobs collection above 😉Once you have your Categories collection setup in WeWeb, you’ll want to drag and drop the “Select” element on the page:As with the search bar element, this will automatically create a component variable in the navigator:In the screenshot below, you can see that:On the select elementWe bound the “Categories” collectionUsed the rollup formula to get only the values from the category fieldNow, to filter your list of jobs based on the job category selected, all you need to do is add a filter to your existing Collection List where the category field of the job contains the Input select - value variable:When the user lands on the page, before they select anything, we don’t want the filter to apply, so we can add a condition to the condition group, i.e. Apply if… the Input select - value variable is empty.4- Redirect a user to a job description page in WeWeb ​Ok great. We have a page with a list of job offers.Now we want to let users access individual job pages.There are several ways we could do this in terms of user interface.Let’s do it in the most obvious way by creating a button that users can click on to learn more about a specific job.Step 1 – Add a button ​In the Add menu, search for the Button element, and drag and drop it in your repeated item container.In the example below, we got rid of the information we didn't need to keep a cleaner design:Step 2 – Add a parameter to the Job template page ​To change the Job template page into a dynamic page, we will add a parameter to the URL with the id of the job:Step 3 – Create a collection to get the job selected ​In the Data menu, call the Xano endpoint that gets the job based on the id of the current page:Step 4 – Create a workflow on the button ​Back on the Jobs page, link the button to the Job template page and pass the current item's id as a parameter:Step 5 – Create a workflow on page load ​Now, when a user navigates to the Jobs template page, you'll want to fetch the Job collection:Step 6 – Display the job data on the template page ​Once you’re on the template page, you can bind fields as you would on any other page, finding the data you need in the Job collection:5 – Allow users to upload their resume and apply to a job through your WeWeb application ​Our web application wouldn’t be complete without the option for users to create, update, or delete a record.For our use case, we want to let users upload their resume and apply to a job by submitting a form on our WeWeb app.By default, on the “Job template” page of the “Job board” template, there is a Contact form container with 4 component variables:User nameUser emailUser locationUser bioYou can see these component variables when you open the Variables sub-menu of the Navigator panel:To allow users to upload a resume, we’ll drag and drop a “File upload” element inside our form container:You’ll notice that, as soon as you drop the element on the page, two new component variables are created by default:“File 1 - progress”, and“File 1 - value”Both these variable names will change if you change the file upload element’s name.You can test this in Preview mode by typing in data and uploading a file as if you were a user. You’ll notice the value of the component variables in the navigator are updated in real time:6 – Update your Xano database with the user’s job application ​By default, the “resume” field in Xano’s “application” table is a “file resource.”However, in WeWeb, when a user uploads a file, we upload it to our CDN and the value of the file is a URL, i.e. a “text” field.Before we show you how to send data from WeWeb to Xano, you therefore need to change the type of the “resume” field in Xano so it’s a “text” type:Then, to update your Xano database with the user’s job application, follow these steps:Create a workflow on the form containerName: “Submit application”, or anything you find more descriptiveTrigger: On Submit, i.e. when the user submits the formTIPIt is important to create the workflow on the form container to validate the input fields. If you add the workflow on the button of the form, you will not be able to validate inputs.Action 1:Upload fileSelect upload element from this page: select the component variable you setupTest Action 1 before moving on to Action 2This is very important because you will need the result of Action 1 to set up Action 2, where you will send data to Xano using the POST /application endpoint:Fields: for each column in the Xano application table, bind the corresponding value in WeWeb.What does this mean?It means that, in Xano, you have 6 columns with data. The keys for these columns are as follows:job_idnameresumeemailphonestatusIn WeWeb, you have a corresponding variable for each key except phone. In the walkthrough below, you can see we:select which fields we want to update in Xano,give Xano the id of the job we are applying to in our Job collection,map the form input variables to the fields in Xano,hard code the fact that every application should have the status \"To be reviewed\"get the link from the file we uploaded in the previous actionOnce that’s done, you can test Action 2, refresh the application table in Xano and jump with joy when the test application comes through 😀7 – Add Xano authentication ​Let’s say you want to force users to authenticate themselves before they can apply to a job.In order to do that, you’ll need to:Add a user table to your Xano databaseAdd authentication endpoints to XanoSet up Xano authentication plugin in WeWebPrevent users who are not authenticated from applying to a job (create login page and gate content)Step 1 - Setup a User Table in Your Xano Database ​By default, there is no user table in Xano’s “Careers” template but you can easily add one.Got to Database > Add Table in the top right corner.Your user table should include at least two fields:one field where you store the login. For example, an email field type, andone field of type password where you store the encrypted password.WARNINGIt’s important that you choose the field type password when creating your user table in Xano. It will ensure that:you can use Xano’s authentication API points, and thatthe user input is encrypted when the user first creates an account with your web-app.Step 2 - Create Authentication API Endpoints in Xano ​For Xano authentication to work, you need three API endpoints:signuploginmeIf you’re using Xano’s “Careers” template, you’ll need to create these three endpoints yourself by going to API > Add API Endpoint > Authentication:"
  },
  {
    "h1": "CRM Build Guide​",
    "url": "https://docs.weweb.io/build-guides/using-the-crm-template.html",
    "content": "CRM Build Guide ​In this guide, we’ll cover how the CRM Template was built and how to tailor it to your needs.The template includes 5 groups of pages:Signup/signinDealsCompaniesContactsSettingsI’ve connected my app to a Xano backend, but you can choose the one of your choice.Let’s dive into more details on how each page was built.AssetsCRM TemplateStarter Kit Library is imported by default in the template.Example database Xano snippetSupabase (coming soon)Figma mockups (coming soon)Data structure ​Deals ​The deals are all the commercial opportunities that a CRM stores. They’re linked to users and companies.id integercreated_at timestamptitle textcontent textstatus texttag passworduser_id integercompanies_id integerdue_date dateCompanies ​Every CRM revolves around deals that are tied to a contact and a company. That’s why we have to store companies in a separate table, as some deals can be linked to the same company.id integercreated_at timestampname textlogo imagedescription textContacts ​A contact is the person attached to a deal, that’s also part of a company. In the case of a CRM, that’s the person you’re “trying to close” on a deal.id integercreated_at timestampname textemail textcompany textUser ​The user table store the information about the users of the application. This is where we the information goes when a new user signs up.id integercreated_at timestampfirstName textlastName textemail textpassword passwordrole textSign in / Sign up Pages ​These pages allows your users to sign up, sign in and reset their password.The Inputs and Button are components from the Starter Kit. You can change their settings in the properties panel.The Form container, that holds the inputs and buttons, has a workflow Sign in. This workflow is triggered when the form is submitted.The Sign up page was built the same way as the Login page, with a few more inputs and a Sign in workflow.Those 2 pages are responsive. In tablet breakpoint, the left content takes up the whole width and the right content is hidden.Sidemenu ​The Sidemenu contains Item Link components. If you edit the component (1), it will automatically update all instances of it throughout the Sidebar, except the properties that you apply directly on the instance such as its link and its props (2). The Sidebar component comes with an integer variable menuWidth (located in the Sidemenu folder of the Variables panel). This variable is connected to the width of the Sidebar in the desktop breakpoint. It also defines the left padding of the Deals section.The Sidemenu component is responsive by default! In tablet breakpoint, the sidemenu will be hidden by default, and can be activated with the menu icon in the top menu.Deals page ​This is the page where your user will be able to create and manage deals.The main component on that page is the Kanban.A Kanban is made up of Column stacks where the cards can be moved to. In each columns you’ll find: a Header (1), an Item div (2) and a Footer (3).Bind data to the Kanban ​The Kanban component is linked to our Deals collection. So each Item of the Kanban will be repeated for each Deal inside of that collection.In the properties pannel, you’ll find a Stacks properties where you can define what column exists in your component. The value of the Stack by needs to match the value of the Stack in order. In this case, it’s the value of my item’s status.Customize the Kanban ​CardsWhen you select any element inside of a card, you’ll see that its content is bound to a formula (1). On the first tab of the formula pannel (2), you have access to the context where you can find all the properties of the current deal.HeaderThe color property of the Square element is bound to a Switch formula that determines the background-color depending on the status.Add a deal ​To add a new deal, you can click on the Create deal button. It will display a modal containing a form. This button triggers workflow that opens the New Deal Modal.On submit, that form takes all the information from the inputs in the forms and sends them to the backend. At the end of the workflow, the modal is closed.This nested workflow is a global workflow. This method allows us to have one workflow that can be used at multiple places but managed in one. When you define a global workflow, you can set parameters to be used inside it. This is useful to add different variables and values in different situations.Change status ​The Kanban component has a trigger On item moved that detects when the user moves a card. Each time this trigger is fired, we are sending the data to the backend to save the new status of the card.Display a deal in a drawer ​When the user clicks on a card 2 things are happening: the card becomes active and the drawer opens with the deal’s information.This is made possible with the selectedItem object variable. On click on the card, all the deal’s information is copied inside of the selectedItem variable.The drawer opens with all the data of the current deal.Inside of the drawer, all the elements content are bound to the selectedItem object keys.The clicked card becomes active.The card has a Selected state (1) that is activated when the Condition (2) is met. In this case, we are looking at the current card id, and checking if the id in the selectedItem matches it. If they are equal, the condition returns true. Inside of the state, you can modify any property that you want. On our card, we modified the background-color to be darker.Modify a deal ​Same as the new deal workflow, you can also edit deals. When you click on Edit button in the drawer, you open the edit modal. With the Init value prop of the Input components, you can pre-fill the input with the current deal information (stored in the selectedItem variable).Action bar ​The Kanban can be filtered by deal owner. To do that, we used a Dropdown Component that acts as a Select component. When you open the dropdown, you have a collection list of all the user from the User collection.On click on a user, the variable dealOwner is set with the user’s id. The second action is a component action linked to the dropdown. It allows us to close it after selection.The dealOwner variable is then use in the Filter setting of the items bound to the Kanban.Companies page ​The Companies list is bound to the Companies collection. Each company has a name, a logo and a description.On that page, we are using 3 workflows to interact with the collection:Create company on the Form submit workflow of the New company modal.Edit company on the Form submit workflow of the Edit company modal.Delete company on the Delete button of the Edit company modal.You have a search input below the Heading that allows you to perform a backend filter. The filter is set directly on the Xano endpoint. The input trigger the workflow on change. That means the collection refetched every time the input value changes, with the new query parameter.Contacts page ​The contact list is bound to the Contacts collection. A contact has a name, a company and an email.On that page, we are using 2 workflows to interact with the collection:Create contact on the Form submit workflow of the modal after clicking on Add contact.Edit contact on the Form submit workflow of the modal after clicking on a contact.Delete contact on the Delete contact button of the Edit modalYou also have the ability search for a contact with the Search input that applies a frontend filter on the list. This means, all results are still loaded in the browser but not on the page. This time, the filter was made on the Collection parameters.Settings page ​Build your own CRM! ​This template get you started building your customized CRM using WeWeb as the frontend and the backend of your choice!"
  },
  {
    "h1": "Advanced properties​",
    "url": "https://docs.weweb.io/components/advanced-properties.html",
    "content": "Advanced properties ​When creating a component property, beyond just setting its label and type, you can configure advanced settings by expanding the Advanced section:The Advanced settings in component properties give you different ways to control how you want your properties to behave. Each setting determines:Where you'll find the property (Styles or Settings tab)What values you can use (fixed only, or both fixed and dynamic with Bindable)If it can change with screen size (Responsive)If it can change with states like hover (States)If you can save values as reusable classes (Classes)If the property is visible or hidden (Hide property)These toggles let you configure exactly how your properties will work in your component.Bindable ​On: property can accept both fixed values and dynamic valuesOff: property can only accept fixed valuesResponsive ​On: Different values per screen sizeOff: Same value across all devicesStates ​On: Define values for different states (hover, active, etc.)Off: Single state onlyClasses ​As your project grows and you reuse components across different places, setting up each component's properties one by one can become time-consuming.Classes let you:Configure property values onceSave them as a reusable class in your WeWeb libraryApply that class to any instance of the componentThink of Classes as presets for your component properties - set up once, reuse everywhere. This not only saves time but also ensures consistency across your project.A practical use case ​Imagine you have an input component that can be reused as a username field, email field, or password field.When you add another instance of this input to use as a username field, you need to reconfigure all its properties again:Instead of manually setting these same properties (label, value, hint text) every time you need a username field in your app, you can:Toggle the Classes option for each propertyExit the component's Edit mode and save all these username-specific instance properties as a reusable class in your library.Next time you need a username input, just add the component and select this classThis way, one click applies all the username field settings instead of configuring each property manually. It's especially useful when you're using the same input configuration repeatedly throughout your project."
  },
  {
    "h1": "Component dropzones​",
    "url": "https://docs.weweb.io/components/component-dropzones.html",
    "content": "Component dropzones ​When you create multiple instances of a WeWeb component, they share identical content elements. While styling can be customized per instance, adding or removing elements affects all instances globally. Component dropzones solve this limitation by providing customizable areas within your component where you can add elements to individual instances without affecting others.This feature:Makes components more versatileEnables instance-specific customizationReduces design repetitionWorking with dropzones ​A typical use case for dropzones would be an input form. Imagine you have a form component and use multiple instances of it in your application. This component has 3 input fields, and you want these 3 fields to be present in every instance of it.But let's say there is one instance of this component where you need to include an additional rich text input field:Create a component dropzone ​While all other instances of this component remain the same, you can customize this specific instance. To create and customize a component dropzone:Create a form and convert it into a component following the steps described here: https://docs.weweb.io/components/intro-to-components.htmlOpen the component editor by double-clicking the component on your canvas or by clicking on the three dots in the component menu and selecting EditOnce in the Edit mode, click on the Add button.Select the Dropzone element at the very top of the Elements list, drag and drop it to your componentThat’s it! Your component dropzone is defined. All instances of this component will now include this dropzone.Adding elements to dropzones ​TIPIf you wish to add elements into a dropzone, make sure you are not in Edit mode for the component containing the dropzone. You are only able to add elements into dropzones if you are not editing the component.To customize a specific instance with additional elements:Select the instance of the component you want to customize with the rich text element. Click on the arrow on the left side of the component in the elements tree to expand itAdd the rich text element by clicking on the Add button and dragging and dropping it into the dropzone on your canvas or in the element treeThe customization is complete. Only this instance of the component will include the rich text input, all other instances will remain the sameExecute dropzone workflow ​Component workflows help you organize and encapsulate functionality in one place. However, you might want to execute these workflows from outside the component or specifically from a dropzone.Suppose you have created a component workflow:Configuring workflow execution ​When creating a component workflow, you have two execution options:Allow execution from outside - enables the workflow to be triggered from anywhere using the Execute component action actionAllow execution from dropzone - permits the workflow to be triggered specifically from elements within your dropzoneUsing execute dropzone workflow ​To trigger a component workflow from your dropzone:Select your dropzone elementAdd a new workflow (e.g., On Change)Add the Execute dropzone workflow actionChoose the component workflow you want to executeThis approach lets you maintain organized component logic while still allowing flexible execution from dropzone elements when needed.TIPRemember to enable the appropriate execution permission (outside or dropzone) in your component workflow settings before attempting to trigger it.Pass data to dropzones ​To share component properties with your dropzone elements:Enter component Edit mode to select your dropzoneNavigate to the Dropzone data section in the Settings tabLocate the Data property:Bind the component properties you want to make available in your dropzoneThis allows elements within your dropzone to access and use the component's properties, enabling better integration between your component and its customizable areas.TIPYou can pass multiple properties at once by binding them as an object."
  },
  {
    "h1": "Component events​",
    "url": "https://docs.weweb.io/components/component-events.html",
    "content": "Component events ​A component event is a message that tells other parts of your application when something specific happens within a component.When building a component, you can trigger events that can then be used outside the component.Let's say, for example, that we have a component called 'Login Form' that is displayed in 2 different parts of our application:on a dedicated login pagein a login modal, accessed when the user clicks on a button in the navbarIn this example, the 'Login Form' is used to pass the user's input details to our back-end and log the user in.When the user logs in, we will need someway of knowing from which part of the application they have used our 'Login Form' component, as:If they have come from the login page - we need to change the page and direct them to the appropriate screen.If they have come from the login modal - we need to close the modal.We could approach this in 2 different ways:include the logic inside the component with a property, orhandle the logic outside the component with an event.Why trigger an event ​With option 1, we would have a component property that says if the component is used on a dedicated page or in a modal.Then, in our component's login workflow, we could add a branch that defines what to do depending on the property value.Althought this works, it would introduce a large amount of manual work as we would need to add a branch to the workflow everytime we wanted to add new funtionality. As we introduce more and more functionality in the future, it could become impractial to manage all the branches.We need more flexibility, so using option 2 makes more sense. To do so:first, in the component workflow, we trigger an event after the login action is successfulthen, outside the component, we are able to react to this event.Create a component event ​In the example below, we created a component event called On login success in our login form component:Emit a component event ​We created a login workflow on submit of the form and triggered the On login success event after our login action:As a result, when an instance of the component emits that event, we can react to it with a workflow that is triggered by the On login success event.TIPYou can type in or bind a specific event value if you want.If you don't pass a value in the event, the event will fire but the event value will be null.React to a component event ​In the example below, on the instance of our component inside a modal, we choose to close the modal when the On login success event is emitted by the component:We could follow the same logic to change page when the component is on a dedicated login page:Event data and schema ​When your component triggers an event (like a successful login), you might want to pass along user information. This is done in the Event data section of your workflow.You can bind the data you want to pass with the event. For example, user information from your login form:email addressusernameany other relevant dataWARNINGWe used a password field in this example for demonstration only. In real applications, never pass plain text passwords through events. Events might be logged and viewed, making them unsuitable for sensitive data. Instead, handle password submission through secure API calls and only pass non-sensitive information through events.When you test your component:The binding UI for the Event object appears empty at firstYou won't see the actual data until the event triggersYou can view the triggered event data in the Logs tabUnderstanding Event schema ​To help others understand what data your event will provide:Go to your component's event settingsAdd an Event schema with example data like:json{ \"email\": \"mockemail@email.com\", \"password\": \"mockpassword\" }After adding the schema above, the binding UI now shows what data to expect, and others can see exactly what information will be available. This eliminates any guesswork about what event data will be accessible. The schema serves as clear documentation, making it easier for everyone to understand and work with your component's events.TIPEvent schema is optional but recommended as it helps others understand how to use your component's events."
  },
  {
    "h1": "Component instance​",
    "url": "https://docs.weweb.io/components/component-instance.html",
    "content": "Component instance ​The thisInstance object streamlines custom JavaScript integration in WeWeb components. It provides direct access to the component's DOM element, essential for third-party libraries and efficient DOM manipulation. It eliminates the need for costly full DOM traversal JavaScript methods such as document.querySelector, instead targeting only the specific component instance. This approach significantly improves performance when working with custom scripts or HTML code in WeWeb components.TIPWeWeb is a visual development platform - you don't need JavaScript knowledge to create powerful applications. However, WeWeb still gives you the flexibility to add custom code if you want to extend your application's capabilities.Why it matters: ​Traversing the entire DOM is expensive. Many third-party libraries require DOM elements to initialize. Using thisInstance in workflows with the onMounted trigger provides these libraries with the correct elements at the right time, ensuring proper setupLet’s say we want to add some custom HTML code inside our Selfie component:We can add the code below. This HTML code sets up a simple camera capture and image download interface:Now we can access our component workflow 'Init camera' that uses the onMounted trigger. We will use this workflow to initialize the camera:TIPonMounted is a lifecycle event that occurs when a component has been inserted into the DOM (Document Object Model). It signifies that the component has been rendered and is now \"mounted\" in the page structure. This is an ideal time to perform certain actions:Initializing third-party librariesSetting up event listenersMaking initial API callsManipulating the DOM directly (when necessary)Starting animations or timers thisInstance is best used onMounted as it ensures that the component's DOM elements are fully rendered and available. thisInstance provides access to these elements, so using it in onMounted guarantees that the elements you're targeting actually exist.In our component’s workflow, we can add a Custom JavaScript action:When targeting DOM elements, using document.querySelector() forces a search through the entire document tree. The issue lies with the document object, which represents the whole DOM. This global scope can be inefficient, especially in large or complex web applications.Binding scripts to the component's scope improves efficiency. Rather than using the global document object, which searches the entire DOM, we use a thisInstance object. This object limits the script's scope to the component's own HTML, ensuring faster and more targeted element selection within the component instance.The code will work even if you have multiple instances within the same page.Conclusion ​When working with custom JavaScript in component workflows, use thisInstance instead of document to target DOM elements. Here's why:document.querySelector() searches the entire DOM, which is inefficient.thisInstance targets only the current component's HTML.This approach is faster and maintains component isolation.It works seamlessly with multiple component instances on a page"
  },
  {
    "h1": "Intro to components​",
    "url": "https://docs.weweb.io/components/intro-to-components.html",
    "content": "Intro to components ​Web components allow you to create reusable custom elements — with their functionality encapsulated away from the rest of your code — and utilize them in your web apps.They are especially helpful to:build faster,design an interface that has the same look-and-feel across pages, anddevelop complex projects without repeating yourself.In summary:The core idea of components is simple but powerful: create something once and reuse it in many different ways while keeping its functionality and data self-contained. This approach lets you build modular, maintainable applications without duplicating work or losing control of how your components behave and manage their own data.Working with components ​You can find components in the Libraries section of the Add panel:Sections and elements without an icon refer to the section and element Templates available in your Libraries.Templates vs components ​When you drag-and-drop a template on a page, it will create a copy of the template. If you later make a change to the template, those changes will not be reflected in the copies you created before.When you drag-and-drop a component on a page, it will create a new instance of the component. If you make a change to the component, those changes will be reflected in all the instances of the component you created before.TIPIf you are starting from a blank project in a new workspace, you may not have any assets available in your libraries at first:Create a new component ​In WeWeb, there are two ways you can create a new component.Option 1 ​You can select an element in the HTML tree on the left of the editor and click on New component in the right panel:Option 2 ​You can select an element on the canvas and click on the component icon to transform it into a new component:TIPIf you choose option 2, make sure to check in the HTML tree that you selected the correct element before creating the component.Rename or delete components ​When you create a new component in a project, it will be added to that project's library.To view, rename, or delete a project component, you can navigate to Libraries:TIPIn Libraries, you can view components from external libraries:However, you won't be able to rename or delete them.To rename or delete a component from an external library, you will need to open that project and update the component in that project's library.Edit a component ​Once you have created a component, you will be able to:change the style of that instance of the component, oredit the component itself so that changes are reflected on all the instances of that componentUpdating an instance vs updating a component ​To customize one instance of a component, simply make the changes you want in the right panel as you would with any other element.To edit a component (and have those changes reflected on all instances of that component), select the component and click on the Edit button at the top of the right panel:WARNINGThe changes you make on an instance of a component will override the component settings.For example, let's say you are using one component three times in your project. If your component has a max-width of auto but change it to 100% on instance B of the component:instance A will have a max-width of auto,instance B of the component will have a max-width of 100%instance C of the component will have a max-width of autoUpdating a component ​Once you have selected a component and clicked on Edit, you will be able to update the component itself:In the screenshot above, you can see a few things:the Back to instance button in the top right confirms that you are currently editing the component itself, not an instance of the componentthe Component tab allows you to create properties, variables, workflows, formulas, and triggers associated with the componentthe Styles, Settings, and Workflow tabs allow you to customize the component as you would any other element. The changes you make here will be applied to all the instances of that component.Component properties ​When you create a component in WeWeb, you can also associate that component with properties (often referred to as \"props\").These properties can be texts, numbers, booleans, selects, collections, and more:Benefit of using props ​When you use a component in multiple places, you can use its props to differentiate the behavior of one instance compared to another.In the example below, we have a button components with 2 properties (style and usage):One the page, we have 4 instances of the same component, but each instance is styled differently and display a different text.This is because each instance of the component has different usage and style property values.For example, the text of instance 3 is Login because its usage property value is For app:But we could change the text and colors of the button by changing the usage and style values of the instance.In the example below, we change the property values of instance 3 to the same values as instance 2:Create component property ​In the Components tab, click on New to create a new component property:You will be invited to:name it,select a property type,provide a default value.TIPIf you create a Select property, you will be invited to add options and select a default value:Advanced options ​In this section, you can decide if the component property:should be displayed in the Styles or Settings tab of the instance,should be bindable,should include states,should include classes.Component variables ​Component variables are variables that are scoped to the component, i.e. they can only be seen and referred to inside the component as opposed to global variables – in the Data tab of the left panel – which can be seen and accessed throughout the project:In the example above, there are no global variables used on the page. However, there is a component variable (selectedItem) which is used to display data about the selected item on the page.TIPComponent variables are especially helpful to keep your project clean and maintainable while it grows in complexity.Component workflows ​Component workflows are workflows that are scoped to the component, i.e. they can only be executed inside the component as opposed to global workflows – in the Action tab of the left panel – which can be executed throughout the project:In the example above, there are no global workflows used on the page. However, there is a component workflow (Count coins) which can be executed anywhere inside the component.In the example below, you can see:our component workflow expects a parameter,we select the down arrow icon, andexecute the global workflow on click of that icon,with the parameter down to reflect the fact the user just clicked on the down arrowTIPComponent workflows are especially helpful to keep your project clean and maintainable while it grows in complexity.Component formulas ​When building a component, you can create formulas that are local to that component. These formula will not exist outside of the component:In the example above, you can see:inside our component,we created a CTA text formula,with two parameters that refer to the two properties of the component: style and usage,the combination of these two parameters will decide what text is displayed in our component,the Current value is \"Login\" because the property values of the current instance of the component are primary and productTIPUsing component formulas is very helpful for scaling and debugging when you're building complex web-applications because they don't crowd the global formulas tab in your project:Component events ​When working with components, it can be helpful to emit a component event that you can then react to outside the component.For example, you could have a login form component that authenticates the user and emits a login success event.Then, depending on where you use the login form component, you could react to the login success event to decide if you need to close a modal or change page.Learn how to emit and react to component events."
  },
  {
    "h1": "CSS classes​",
    "url": "https://docs.weweb.io/css-and-styling/classes.html",
    "content": "CSS classes ​​When we talk about classes in the context of styling, we are specifically referring to CSS (cascading style sheets).In WeWeb, if you wish to reuse a specific style, you can choose to create a class using the following option 👇 ​ Classes & subclasses ​​ Suppose you have a desire to integrate something like Bootstrap ​ ​A web developer would have to do something like this ​html<button type=\"button\" class=\"btn btn-primary\">Primary</button> <button type=\"button\" class=\"btn btn-secondary\">Secondary</button> <button type=\"button\" class=\"btn btn-success\">Success</button> <button type=\"button\" class=\"btn btn-danger\">Danger</button> <button type=\"button\" class=\"btn btn-warning\">Warning</button> <button type=\"button\" class=\"btn btn-info\">Info</button> <button type=\"button\" class=\"btn btn-light\">Light</button> <button type=\"button\" class=\"btn btn-dark\">Dark</button> <button type=\"button\" class=\"btn btn-link\">Link</button>​ In this code, each button is assigned two CSS classes:the first class, btn, is common to all buttons,the second class (or subclass) determines the specific style of each button (e.g. Primary, Danger, Warning)In WeWeb, you could approach this in 2 different ways.Option 1: create a default class & style subclasses ​In this case, create a btn class and a btn-primary subclass attached to the btn class:This approach has the benefit of being super simple to maintain. The downside of option 1 is that, in WeWeb, you can only have one sub-class per class.We did this to help you build in a way that is efficient and maintainable while addressing 90% of use cases but if you find this too restrictive, please don't hesitate to reach out to us to share your specific use case.Option 2: create a default class & style classes with state subclasses ​In this case, in addition to the btn class, you'd create:a class for each style (i.e. btn-primary, btn-secondary, etc.)with multiple subclasses for states on each class (e.g. hover, focus and disable)This approach allows you to have as many classes as you want on an element (though we encourage you to stay lean for readibility and maintainability purposes).It has the added benefit of enabling you to save and re-use states across elements in a subclass.WARNINGThe order of classes matters: the style of the bottom class will override the style of classes above.If you want the btn-primary class to inherit styles from the btn class, it needs to be placed below its parent class.Note that ​we made the decision to offer you the capability to reuse styles in a manner that closely aligns with how developers do it.Our aim is to offer you the flexibility to manage your design systems according to your preferences. There is no single prescribed approach for doing so.Instead, there are numerous best practices available. We encourage you to take the time to explore and identify the approach that suits you best, and then maintain consistency by adhering to it throughout your project. ​We are constantly seeking to iterate and improve WeWeb. If you have any suggestions or request to improve this feature, please do not hesitate to share it with us. ​Create a class ​When creating a \"parent\" class for an element, ask yourself: what are the common style properties I want to feature on this element by default?For example, the default style of a button could include:paddingtext sizefont weightalignmentborderstransitions​Once you're happy with the default style of your default element, go to Select or create a class to create your first class: ​ ​In the example below, we called it btn – stands for \"button\" – and selected the CSS properties we styled:​ ​Save changes ​We didn't want to enable autosave when styling a class because of the risk of updating something by mistake that impacts other elements in the project.When editing the CSS property of a class, you will see a light gray background appear around the name of the property you just changed.Once you save the change (by going to the pencil icon of the class and clicking on \"Save\"), you will see a yellow/orange background around the name of the properties you saved: ​ Re-use styles ​Once you've created a class, you'll most likely want to apply it to other elements.You can do this by simply selecting the class when you're on an element: ​ ​Class combos ​In our Bootstrap example, we saw that each button had two classes.As with code, we can have two classes on a single element in WeWeb.If you don't want two classes to conflict with each other in an unexpected way, it's important that you select only the properties you want to update when styling a class.In the example below, we added the btn-primary class and edited the style specific to that button, i.e.​ ​ ​ ​When saving our changes on the btn-primary class, we selected only those 3 properties to ensure it didn't potentially conflict with the style of our btn class: ​ ​TIPRemember, the last class in the list will override the classes above so, if we saved font-size property with 14px on btn-primary and decided later to change the font-size to 12px on all buttons with the btn class, the change we inadvertendly saved on btn-primary would mean our change on btn wouldn't be effective on elements with both classes.​Subclasses ​To add a subclass to a WeWeb class, simply click on Create subclass below the class you are working on.A common use case involves adding a state as a subclass.In order to do that, we can start by adding a state to our element (for example hover): ​ ​And make sure we are on that state when styling the element. In the example below, we are on an element with both the btn and btn-primary classes and we can see above the class names that the Hover state is selected: ​ Since the background color of the button will change on hover depending on the type of button (not all buttons), we'll add a hover subclass to the btn-primary class (not btn):And change only the background-color and border CSS properties: ​We now have 2 classes and one subclass applied: ​ ​To accomplish the same result as our Bootstrap model, we'd need to repeat this process with all the button states we wanted (e.g. hover, focus, and disable), on each button type (i.e. Warning, Success, etc.) to obtain a list of classes that looks something like this: ​ ​TIPYou cannot have sub-subclasses. We chose this approach because we believe it is the most user-friendly to get started and most maintainable as your project grows in complexity.After extensive user interviews in beta testing, we have yet to come across a use case where this is an issue.If you feel stifled by this implementation, please reach out in the WeWeb community to let us know more about your use case."
  },
  {
    "h1": "Conditional rendering​",
    "url": "https://docs.weweb.io/css-and-styling/conditional-rendering.html",
    "content": "Conditional rendering ​In this article, we will explain how to use the advanced Conditional Rendering setting available in the Settings tab of elements:Difference with display:none ​The Conditional Rendering setting can greatly improve the performances of your web app because, when you hide an element using this advanced setting, that element will not be built on page load by default. It will only be rendered in the DOM if / when the condition to display it is met. As a result, your pages will load faster.By comparison, when you use the standard display CSS property to hide an element on a page, the browser still needs to build that element on page load. If you have a lot of hidden elements on the page, it can significantly slow down your browser.You may wonder why ever use the standard CSS display property anymore? Well, if you need to access input variables of an element that is hidden by the Conditional Rendering setting, you won't be able to because the element won't be in the DOM. In that use case, the standard display property will continue to be very useful.Using Conditional Rendering ​The Conditional Rendering setting needs you to define a condition. When that condition is met, the element will be made available in the DOM and displayed on the page (provided you haven't used the standard CSS display property to hide it!).In the example below, we are saying that, if the user types in more than 225 characters (from index 0 to 224 in the string of characters that is user_description text), we will display a message warning them they are close to reaching the 280 character limit:Like the standard CSS display property, the element will not appear on the page when the condition is not met:The crucial difference with the standard CSS display property is that the element will not appear in the DOM either, the browser will only build it when the condition is met. In the WeWeb Navigator, you will see the little crossed-out eye icon that warns you an element is not displayed.In the example below, you can see that, when we remove some text and fall below the 225 characters limit, the warning text element disappears completely from the DOM in the browser:If we were using the display CSS property, the element would still be visible in the DOM in the browser."
  },
  {
    "h1": "CSS Animations​",
    "url": "https://docs.weweb.io/css-and-styling/css-animations.html",
    "content": "CSS Animations ​Different approaches ​To add CSS animations to an element on a WeWeb page:select that element, on the pagego to the CSS styles tab of that element, andchoose your preferred way of creating an animation in the Animation dropdownYou can find the all the definitions of the CSS animation properties here.There are three main ways to get started:Manually add keyframes.Import keyframes.Ask WeWeb AI.Animation properties ​In the Animation panel, you can set the following properties to customize your animations:Duration: Define the duration of the animation in milliseconds (ms).Delay: Add a delay before the animation starts, also in milliseconds (ms).Transition: Choose how the animation transitions between keyframes. Options include: easeease-inease-outease-in-outlinearIterations: Set how many times the animation repeats. You can specify a number or select Infinite for continuous looping.Alternate: Enable or disable the alternate mode. When enabled, the animation reverses direction after each iteration.Fill Mode: Control how the animation applies styles outside its active period: None: No styles from the animation are applied before the animation starts or after it ends. The element will only be styled during the animation's active period.Forwards: The element retains the styles defined in the animation's final keyframe after the animation ends.Backwards: The element immediately applies the styles defined in the animation's first keyframe, even during the animation's delay period.Both: Combines the behaviors of Forwards and Backwards. The element applies the styles from the first keyframe during the delay and retains the styles from the final keyframe after the animation ends.Play State: Toggle the animation's play state (On or Off).Keyframes: Open the editor to create, import, or edit keyframes for the animation.Keyframes editor ​If you're familiar with keyframes, you can create your own using our no-code keyframes editor:To add an animation, select the keyframe where you want to define properties. Then, you can modify any CSS property from the style panel. You can identify properties set on a keyframe with their green highlight. Do that for the initial keyframe, the final one, and all the intermediate ones to create a smooth animation.In the example above, we:copy Keyframe #1 which creates Keyframe #2move Keyframe #2 on the animation timelinechange the value of Keyframe #2 and changing it to seconds instead of percentagedelete Keyframe #2 to get back where we startedImport keyframes ​To save time, you can also paste and import keyframes in the WeWeb keyframes editor:In the example above, we:first opened the keyframes editor to import the keyframes used as examples in MDN's documentation,then used the WeWeb editor to limit the animation to 3 counts.WeWeb AI ​If CSS animations to come easily to you, we recommend asking WeWeb AI for help to get started:In the example above, we:first asked WeWeb AI to \"make an animation where the text grows larger and larger then smaller and smaller fairly slowly\",then used the WeWeb editor to slow down the animation.TIPYou can also edit the keyframes generated by WeWeb AI in the keyframes editor:Copy/paste an animation ​To reuse an animation, you can copy it and paste it on a similar element (e.g. here, we are copy/pasting an animation between two text elements):WARNINGYou can only paste animations that were copied from the same type of element (e.g. text on text, container on container, etc.)"
  },
  {
    "h1": "CSS Grid​",
    "url": "https://docs.weweb.io/css-and-styling/css-grid.html",
    "content": "CSS Grid ​Why use CSS grids ​CSS grids are a powerful tool to build complex, responsive layouts on the web.For example, designing a complex layout like this would be complex with a flex display but is fairly easy with a grid display:CSS grid basics ​UNDERSTANDING CSS GRID BASICSThe following article aims to explain how to use CSS grid properties in the WeWeb editor.If you're new to CSS grids, we recommend you take the time to understand how CSS grids work in general.We have selected 4 free resources that can help you with this:Learn CSS Grid helpfully lists and illustrates all available grid CSS propertiesCSS Grid Garden is an fun, interactive way to understand CSS grid propertiesMDN's docs explains the basic concepts of grid layoutsGrid by Example includes numerous examples of grid layouts with the underlying HTML & CSS to reverse-engineer how each was builtGrid container ​In the Style tab of WeWeb containers, you will find grid and inline-grid under the Display property options:When a container has a grid or inline-grid display, all the children of that container become grid items.Learn more about the grid container.Grid direction ​Grids can have a horizontal (\"row\") or vertical (\"columns\") direction:In the example above, we have 3 containers that can be displayed as rows or columns.Grid column & row size ​By default, each column or row will have the same width and height respectively.You can, however, be explicit and set a fixed width or height to create more complex layouts:In CSS, this corresponds to the grid-template-rows and grid-template-columns properties.In WeWeb, you have a couple of options to work with these properties:use the no-code interface of WeWeb as shown in the columns example above, orbind the Rows or Columns settings in WeWeb to CSS values as shown in the rows example below.In the example above, you can see we have an array of 5 values that defines the height of the 5 rows in our grid.Learn more about explicit grid templatesGrid gaps ​Grid gaps (also called \"gutters\") are an elegant way of handling spacing:Learn more about grid gaps.Grid items span & position ​For each item in a grid, you can define its:span: how many row or column units does it span,position: where should it be placed in the row or columnLet's look at a few examples.Example 1 ​In both cases, the grid container is configured as follows:Direction: RowColumns: auto-generatedRows: auto-generatedWidth: 100%Height: 500pxThe grid on the left has no additional settings on the grid items. The grid on the right contains grid items where we specified the span or position.Example 2 ​In all three cases, the grid container is configured as follows:Direction: ColumnColumns: 3 columns of 1frRows: 3 rows of 1frWidth: 100%Height: autoThe grid at the top has no additional settings on the grid items.Grid item A of the middle grid has a Column position of 2/4.Grid item A of the bottom grid has a Row span of 2 and a Column position of 2/4.TIPIn the example above, notice that each grid has 4 vertical lines.When we give the Column position property a 2/4 value, it means that the grid item should take up the space between vertical line 2 and vertical line 4 in the grid.Learn more about positioning items by grid line number.Troubleshooting ​As mentioned above, this article aims to explain how to use CSS grid properties in the WeWeb editor.If you're new to CSS grids, we recommend you take the time to understand how CSS grids work in general.We have selected 4 free resources that can help you with this:Learn CSS Grid helpfully lists and illustrates all available grid CSS propertiesCSS Grid Garden is an fun, interactive way to understand CSS grid propertiesMDN's docs explains the basic concepts of grid layoutsGrid by Example includes numerous examples of grid layouts with the underlying HTML & CSS to reverse-engineer how each was builtIf you're still stuck after this, don't hesitate to reach out in the WeWeb Community! Make sure to include visuals that show:the end result you're trying to achieve, andthe styles settings you have applied to your grid container and grid items.We'll do our best to help 🙂"
  },
  {
    "h1": "CSS Properties​",
    "url": "https://docs.weweb.io/css-and-styling/css-properties.html",
    "content": "CSS Properties ​CSS properties are all the options you can use to change an element's design inside your WeWeb app.They're available on the right sidebar, under the styling tab.Let's go over each of them.Specific ​This section is a shortcut to find the most used CSS properties for a given element. It's different for every element.Here are the available CSS properties in this section (all elements included):Text - {lang} ​This is where you can bind the text displayed to a variable, typically, when you want to display some text that comes from a plugin or 3rd-party API.You'll have to bind it for every language that's currently activated on this page.Typography ​This option is useful when you want to standardise text styles in your app. Here, you can select a text type (for example: heading, subtitle, etc) that you created in the typography section of your app.Size ​To set the element text's size (in px, em or rem). Equivalent to CSS' font-size.Font family ​To set the font of the text element. Equivalent to CSS' font-family.Font weight ​To set the weight of the text element (for example: bold, semibold, etc). Equivalent to CSS' font-weight.Line height ​To set the height between two lines of text in the element. Equivalent to CSS' line-height.Alignment ​To align the text right, center, left of justified. Equivalent to CSS' text-justified.Text color ​To set the color of the text. Equivalent to CSS' color.Text decoration ​To set the decoration of the text (for example: underline, overline, etc). Equivalent to CSS' text-decoration.No-wrap ​To prevent the text from wrapping to the next line. Equivalent to CSS' white-space.Character case ​To set the case of the text (for example: uppercase, lowercase, etc). Equivalent to CSS' text-transform.Text shadows ​To add a shadow to the text. Equivalent to CSS' text-shadow.Letter spacing ​To set the space between each letter of the text. Equivalent to CSS' letter-spacing.Word spacing ​To set the space between each word of the text. Equivalent to CSS' word-spacing.Text background ​To set the background color of the text. Equivalent to CSS' background-color.Image ​This is where you can bind an image source, typically, when it comes from an external tool or API. Equivalent to HTML's src.Fit ​To set how the image should be displayed (for example: cover, contain, etc). Equivalent to CSS' object-fit.Overlay ​To set the color of the image overlay. Equivalent to CSS' background-color.Filters ​To apply filters to the image (for example: grayscale, blur, etc). Equivalent to CSS' filter.Items ​This is where you can bind a list of items to be displayed inside a container (like a div, columns, etc).Direction ​To set the direction of the items (for example: horizontal, vertical, etc). Equivalent to CSS' flex-direction.Rows gap ​To set the space between each row of items. Equivalent to CSS' grid-row-gap.Columns gap ​To set the space between each column of items. Equivalent to CSS' grid-column-gap.Justify ​To set how the items should be aligned horizontally (for example: left, center, right, etc). Equivalent to CSS' justify-content.Alignment ​To set how the items should be aligned vertically (for example: top, center, bottom, etc). Equivalent to CSS' align-items.Reverse order ​To reverse the order of the items. Equivalent to CSS' flex-direction.Push last to the end ​To push the last item to the end of the container. Equivalent to CSS' justify-content.Display type ​To set the display type of the items (for example: list, grid, etc). Equivalent to CSS' display.Presets ​Set of predefined display types for columns. Equivalent to CSS' display.Text ​Sanitize ​This is for when you bind a text to a data provided by the user, for example a comment you have register in the database.This will escape special characters, so that you are not vulnerable to XSS attacks.The option is not active by default because sometimes you want these characters to be interpreted (for example making some part of the text bold with markup).Sizing ​Width ​To set the width of the element. Equivalent to CSS' width.Height ​To set the height of the element. Equivalent to CSS' height.Max-width ​To set the maximum width of the element. Equivalent to CSS' max-width.Min-width ​To set the minimum width of the element. Equivalent to CSS' min-width.Max-height ​To set the maximum height of the element. Equivalent to CSS' max-height.Min-height ​To set the minimum height of the element. Equivalent to CSS' min-height.Spacing ​Padding ​To set the padding of the element. Equivalent to CSS' padding.Margin ​To set the margin of the element. Equivalent to CSS' margin.Display ​Alignment ​To set how the element should be aligned vertically (for example: top, center, bottom, etc). Equivalent to CSS' align-items.Display ​To set if an element should be displayed or not. Equivalent to CSS' display: none.TIPThis is how you can hide an element on responsive mode or when a condition is met.Opacity ​To set the opacity of the element. Equivalent to CSS' opacity.Position ​To set the position of the element. Equivalent to CSS' position.Z axis ​To set the z-index of the element. Equivalent to CSS' z-index.Cursor ​To set the cursor of the element. Equivalent to CSS' cursor.Overflow ​To set the overflow of the element. Equivalent to CSS' overflow.Background ​Color ​To set the background color of the element. Equivalent to CSS' background-color.Element ​To set the background element (like and image or video) of the element. Equivalent to CSS' background.Borders & Shadows ​Borders ​To set the borders of the element. Equivalent to CSS' border.Corner radius ​To set the corner radius of the element. Equivalent to CSS' border-radius.Shadows ​To set the shadows of the element. Equivalent to CSS' box-shadow.Advanced ​Transform ​To set the transform of the element. Equivalent to CSS' transform.Transition ​To set the transition of the element. Equivalent to CSS' transition.Perspective ​To set the perspective of the element. Equivalent to CSS' perspective.Custom CSS ​Here, you can add custom CSS to the element. Equivalent to CSS' style.Binding Properties ​Note that, you can bind the value of any CSS Property to another formula or variable. You can use this feature to manipulate the properties based on interactions elsewhere in the app, or even with workflows"
  },
  {
    "h1": "Responsive design​",
    "url": "https://docs.weweb.io/css-and-styling/responsive-design.html",
    "content": "Responsive design ​Responsive design consists in designing web applications that adapt to smaller devices, like mobile and tablets.WeWeb handles responsive design out of the box.Three breakpoints ​In WeWeb, you can customize the design at three breakpoint levels: desktop, tablet, and mobile:Top down approach ​When you customize a CSS property on a breakpoint, that style will be applied to all the smaller breakpoints:setting a font color on desktop will also apply on tablets and mobile devicessetting a font weight on tablet will also apply on mobile, but not on desktopsetting a font size on mobile will only apply on mobile, not on desktop or tabletAdd responsive style ​To design responsively, switch between breakpoints in the top navigation menu, then change a style in the right sidebar.You'll be able to see responsive styles when hovering them. A green icon will appear next to the property name and, if you click on it, you'll see on what breakpoint the change was made:TIPYou can also access the information about a user's browser, including the breakpoint they're on, and use it to style responsively.In the example below, we are saying that we only want to show the name column of a data grid when the browser breakpoint has the default value, i.e. when the user is on desktop:Though it can be helpful in some cases such as the data grid example described above, note that this approach is harder to debug because it's hard to see if a responsive style is applied to an element just by looking at the style panel in the WeWeb editor.Delete responsive style ​If you hover a CSS style and click on one of the tablet or mobile icons, you'll remove the responsive style for that breakpoint:Make your designs responsive ​To make your designs adapt to different screen sizes, ensure that your layout and components adjust smoothly across all breakpoints. Here are some best practices to help you achieve responsive designs in WeWeb:Use Relative Units ​Instead of using fixed pixel values (px) for widths, heights, margins, and paddings, opt for relative units like percentages (%), viewport width (vw), viewport height (vh), or em and rem. This allows elements to scale proportionally with the screen size.Leverage Flexbox and Grid Layouts ​Utilize CSS Flexbox and Grid to create flexible and responsive layouts:Flexbox is ideal for one-dimensional layouts (rows or columns).Grid is perfect for two-dimensional layouts (both rows and columns). These layout models adapt naturally to different screen sizes, ensuring your content remains organized.Avoid Fixed Widths and Heights ​Setting fixed widths and heights can cause elements to overflow or not resize properly on smaller screens. Instead, use max-width, min-width, max-height, and min-height properties to allow elements to resize within specified limits.Check Parent Containers ​If you notice that only part of your page resizes while another part remains the same, it might be because:Fixed Dimensions on Parent Elements: Ensure parent containers don't have fixed widths or heights that prevent child elements from resizing.Overflow Properties: Check if overflow is set to hidden, which can restrict content from adjusting its size.Positioning Issues: Elements with position: absolute or position: fixed might not respond to changes in screen size.Hide elements on mobile ​To not display an element on tablet or mobile, DO NOT delete it.Instead, we invite you to follow standard web development practices and edit:CSS display property, orconditional rendering setting."
  },
  {
    "h1": "States​",
    "url": "https://docs.weweb.io/css-and-styling/states.html",
    "content": "States ​A state is a combination of CSS properties that you want to trigger at a specific moment on an element.It can be classic CSS states like hover, or user-generated ones that you define while building your app.How to create a State ​To create a new CSS state, click on the element you want to create the state on, then on Default > Add State:How to configure a state ​When the state if created, open its tab and set 3 options:the state's namethe condition under which the state should trigger, which is bindable and should return true when the state is to be active, false otherwisewhether to apply the state the the element's children or notWhen the state is selected at the top of the style sidebar, any CSS changes that you'll do will be only applied for this state.Example: here the color and display will only change when the state Please Click Me! is activated:How to apply a State to an element's children ​When Apply to children is set to On, you can use the state on any of the element's children by simply using it. It should be called {{Parent}}:{{State name}}.For example, if a button has a state called Please Click Me!, an icon inside this button can use the same state which would be called Button:Please Click Me!:Focus state ​The button and input elements recognize the focus state if you add it as a custom state on the element.In the example below, we have a focus state on an input that changes the border color when a user navigates to the input:"
  },
  {
    "h1": "Intro to collections​",
    "url": "https://docs.weweb.io/data/intro-to-collections.html",
    "content": "Intro to collections ​In WeWeb, a collection is a set of data fetched from a 3rd-party API or backend. You can then use this data to display it in your app.Pre-requisites ​WARNINGBefore you can create a new collection of data in WeWeb, you first need to have installed at least one data source plugin, e.g. Xano, Supabase, REST API, etc.Once you have added a data source plugin, you will be able to create a collection to fetch data from that source.Create a collection ​To create a collection, go to the Data tab in the left sidebar, then click on + New to start setting up the collection.The setup process is different for every data source plugin, but it revolves around the following steps:Give your collection a nameSelect the data source plugin you want to useSelect the connection modeConfigure how you want to fetch the dataFetch the dataApply any frontend sort, filter or paginationLet's look at an example:To deep-dive into how to setup a collection for each data source plugin, check out the following guides:AirtableREST APIXanoSupabaseAlgoliaHow to use a collection ​Collections are typically used to display data in a list or a grid. To do so, you can use the Collection list element, or any div.To learn more about how to display a collection, check out the following guide.But in the end, collection are simple arrays of data that can be used in any workflow or formula.They look like this inside the data explorer: Let's deep dive into this:first, you'll find the collection as a whole. It contains your data, and some metadata about the collection (like the number of items, the total number of items, etc.) that WeWeb created.secondly, you'll find the data property. This is the array of data without any metadata.TIPSome elements require to be bound to the collection, others to the collection's data only, depending on if they use the metadata or not. If your binding doesn't seem to work, please try it again by binding only the data property!data[index] shows the data for the item at the index index in the collection. It's useful to bind to a specific item in the collection. To change the item, you can use the index dropdown next to the data property.Length is the number of items there are in the collection.TIPTo know if a collection is empty, use the Length property. If it's equal to 0, the collection is empty!isFetching is a boolean that tells you if the collection is currently fetching data. It's useful to display a loading state while the data is being fetched.isFetched is a boolean that tells you if the collection has already been fetched.TIPTo display a loading state while your collection is being fetched, you can use a loading GIF or SVG, and bind its display property to the collection's isFetching property.limit is the max index for the items that are currently displayed in the collection, given any active frontend filter, sort or pagination.total is the total number of items in the collection, given any active frontend filter, sort or pagination.offset is the index of the first item in the collection, given any active frontend filter, sort or pagination.Optimize collection load ​By default, a collection is:fetched automatically when a user navigates to a page that uses that collection, andis preserved (not fetched again), when a user navigates to other pages in the app.To optimize the performance and UX of your web app, you can change that default behavior in the Fetch data step of the collection setup:Fetch this collection automatically tells WeWeb if it should fetch the collection on every page load, or if you want to fetch it manually. If you want to fetch it manually, you can trigger the Fetch collection workflow action.Preserve on navigation tells WeWeb if it should keep the collection in memory when the user navigates to a new page. If you want to fetch the collection again, you can trigger the Fetch collection workflow action.There may be use cases where you want to change these default settings.Why disable automatic fetch? ​If you have a collection that you don’t need immediately on page load, you should consider disabling the automatic fetch to improve performances. For example, you might want to fetch a collection when the user opens a modal on a page and not on page load.If you disable the automatic fetch on a collection, you'll need to remember to trigger a workflow that fetches the collection every where you need it in the app.Why disable preserve on navigation? ​A common use case where you don't want to preserve on navigation: a collection that fetches a single item selected on a previous page (if you preserve on navigation, there might be a blink where the info from the previously selected item appears while the API call takes place to fetch the info of the new selected item)This is especially problematic if the collection data concerns a specific user with potentially private information. You want to make sure that data is not preserved on navigation in case 2 users connect to your app using the same browser.Collection modes ​TIPTo build dynamic web applications, we highly recommend creating Dynamic collections.However, at times, when you need to pre-render content or bypass API rate limits from a data source, you may want to consider working with a Static or Cached collection instead.Static: the collection will be fetched once, on our servers, while the app is built. Everytime this collection is used in your app, the data will be pre-rendered (better for SEO, can slow down the publish process).Dynamic: the collection will be fetched on the client side, when the app is loaded. This is the best option if you want to fetch data that changes often (like a list of products).Cached: the collection will be fetched on the client side, but from our servers. This is the best option if you want to fetch data that changes often, but you want to avoid hitting any API rate limit (but you'll need to refresh the data yourself when it changes).Frontend vs Backend filters ​When setting up a collection, the Sort, Filter and Pagination step can be before or after the fetching one.If you set it before, it's called a backend filter. It means that the data is fetched from the 3rd-party API, already filtered, sorted and paginated by the server.If you set it after, it's called a frontend filter. It means that the data is fetched from the 3rd-party API, then filtered, sorted and paginated on the client side:Why do some plugins have backend filters (like Supabase) when other have frontend filters (like Airtable)?Well, it depends on the tools' API capabilities, and how they handle pagination, sorting and filtering.Some APIs are very limited, and don't allow to filter, sort or paginate the data on the server side. In that case, WeWeb will have to fetch all the data, then filter, sort and paginate it on the client side.When to use frontend vs backend filters? ​If you have a small collection, without any private data: use a frontend filter. It's the easiest to setup, and it's the fastest.If you have a big collection, or need to fetch private data: use a backend filter. It's a bit more complicated to setup, but it's the more secure.WARNINGKeep in mind that any data fetched from a 3rd-party API is visible. It's not because you have a frontend filter and that the data is not visible to the user in your app, that it's not visible at all. Indeed, anyone can inspect the HTML of your app, and see the data that is fetched from the 3rd-party API.If you need security: use a backend filter and make sure to use a backend with secured endpoints or RLS on the database.Learn more about adding security to the web-apps you build with no-code tools.Filter options ​Pagination is the number of items that are displayed per page. It's useful if you have lot of data to display, and you want to split it into multiple pages (using the Pagination element).Filter is a formula that filters the data. It's useful if you want to display only a subset of the data.Let's look at an example: Here, we're filtering the data to only display companies where their name contains the letter t or, (where their domain contains www and their number_of_employees is greater than 100).As you can see, you can create groups of filters using condition groups.For each of these groups or conditions, you can set them under certain conditions (using the Apply if...). For example, when a variable is true or false in your app.You can also use the AND and OR operators to combine filters.The toggles are Ignore if empty options that tell WeWeb not to apply the filter if the value is empty.Sort is a formula that sorts the data. It's useful if you want to display the data in a specific order (like ascending or descending order for alphabetical or numerical values, etc)."
  },
  {
    "h1": "Intro to variables​",
    "url": "https://docs.weweb.io/data/intro-to-variables.html",
    "content": "Intro to variables ​Variables are containers that store information in your WeWeb application. Think of them like labeled boxes where you can keep different types of data - text, numbers, lists, or even yes/no values. Just like how you'd label a box \"Kitchen Items\" to know what's inside, you give each variable a name to easily find and use its contents anywhere in your application.For example, if you store the name \"John Doe\" in a variable called userName, you can display or use \"John Doe\" anywhere you need it on your website.Check out this video to learn more about variables in WeWeb:Create a variable ​Here's a short interactive tutorial on how to create a global variable in WeWeb:Let's take a look at each step:Variables are in the Data tab of the WeWeb navigatorClick on the New in the Variables section of the panelName your variableChoose the variable type from the dropdown menu (e.g., Text, Number, Boolean, Query, etc.)Optionally, you can set a default value for the variable in the Default value fieldDecide if you want the variable to be preserved on navigation and/or saved in local storageClick on Create to create the variable.Now, you can use this variable throughout your website by binding it to UI components or using it in workflows.Variables types ​In programming, variables are helpful to store, send, and display information. For example, you can store the name of a user in a Text variable (also called a string) or a list of users in an Array variable in your frontend before sending the information your your backend.However, if you try to send the value of a Text variable to a column in your backend that expects an Array, you'll get an error.That's why it's important to understand the different data types you may encounter in web development.Text ​A text variable is a variable that stores text. You can use text variables to store text values, such as names, addresses, or any other text data. It's equivalent to a string in JavaScript.Number ​A number variable is a variable that stores numbers. You can use number variables to store numeric values, such as prices, quantities, or any other numeric data. It's equivalent to a number in JavaScript.Boolean ​A boolean variable is a variable that stores a boolean value (true or false). You can use boolean variables to store boolean values, such as a flag that indicates whether a user is logged in or not. It's equivalent to a boolean in JavaScript.Object ​An object variable is a variable that stores an object. You can use object variables to store complex data, such as a user profile, a product, or any other data that has multiple properties. It's equivalent to an object in JavaScript.Array ​An array variable is a variable that stores an array. You can use array variables to store a list of values, such as a list of products, a list of users, or any other data that has multiple values. It's equivalent to an array in JavaScript.Query ​You can use query variables to store the value of a query string parameter in an URL.For example, you can use them to:Customize what a user sees based on how they got to your site (like showing different content when they click an email link)Remember which product someone wants to view (like going directly to a specific item when sharing a link)Keep track of where visitors came from (like knowing if they clicked an Instagram ad)Show personalized messages (like displaying \"Welcome back!\" when someone returns through a special link)Display variable value ​To use a variable in WeWeb, follow these steps:Open a workflow's action or a binding panel on any elementGo to the Variables tabClick on the variable you want to useYou can also use variables inside formulas like so: Inspect current value ​In the example below, our text element is bound to the myName variable. When we change it's current value or default value, it changes the text displayed on the page:"
  },
  {
    "h1": "App settings​",
    "url": "https://docs.weweb.io/editor/app-settings/app-settings.html",
    "content": "App settings ​App settings are project settings used to build the application. For example, a custom domain is a project setting, but a On App Load workflow is an app setting.To get to the app settings, open the More menu in the top navbar:Mobile App (PWA) ​In this tab, you can setup options so that your WeWeb app can be installed on a mobile device as a Progressive Web App.Learn more about building and publishing a PWA in WeWeb.App workflows ​Here, you can execute workflows for some specific triggers:On App Load (before fetching collections): trigger a workflow when the app is loaded by a user for the first time (i.e. at the beginning of a user session), but before collections are fetched from your backendOn Page Load (before fetching collections): trigger a workflow when a page is loaded by a user, but before collections are fetched from your backendOn App Load: trigger a workflow when the app is loaded by a user for the first time (i.e. at the beginning of a user session), but after collections are fetched from your backendOn Page Load: trigger a workflow when a page is loaded by a user, but after collections are fetched from your backendOn App Unload: trigger a workflow when the app is unloaded by a user (i.e. at the end of a user session, when he's closing his/her browser's tab)Page languages ​Here, you're able to add new languages to your app, in addition to the default one that you selected when you created the app, by clicking the Add language button:By using the toggle icons, you're also able to tell WeWeb which language should be your app's default one. Meaning that if a user lands on your live project and his/her browser's language doesn't match one of your app languages, the app will display in the default one.In this example, if a user's browser isn't set to either English or French, the app will revert to English:The last option tells WeWeb if your app's default language should be in your app's URLs paths.By default, WeWeb creates URLs like this: https://{yourdomain}/{page-path}But to navigate between languages, the lang code (ex: fr, en, es...) is added before the path, like so: https://{yourdomain}/{lang}/{page-path}By setting this option to Yes, the lang code will also appear in the URLs for the default language:Images ​In the Images sub-menu, you can find all the images that were uploaded into the project which are currently used to build the app, and hosted on WeWeb's servers:Files ​The Files sub-menu allows you to upload various types of files to WeWeb's CDN:Common examples include but are not limited to:a custom sitemap, robots.txt file or PWA manifest,verification files for third-party providers such as Apple Pay,static files (e.g. PDFs and CSVs) to display in or download from the app.Features of the Files Sub-Menu ​Set File Path: Define the file's path on your published app.Copy File Link: Quickly copy the link to any uploaded file.Download Files: Retrieve any file you previously uploaded.Remove Files: Delete any file from the WeWeb CDN.Set file paths ​When you set a path for a file, it becomes accessible at that location within your published project.For example, if your WeWeb app is connected to mydomain.com and you upload best-sitemap-in-town.xml, setting its path to /sitemap.xml will make it available at mydomain.com/sitemap.xml. This action will override the default sitemap generated by WeWeb.Removing Files ​To remove a file from the published app's path, simply delete the set path and republish your app. Note that the file will still be available via its direct CDN link and should be manually removed from the CDN if no longer needed.User files vs app filesWhile it is possible to store user files to WeWeb's CDN, it's best practice to store user-related data in a backend system. This approach offers greater flexibility for scaling storage solutions and ensures files can be secured with appropriate user access controls.Fonts ​In the Fonts sub-menu, you can:find all the fonts currently used in your app,see or choose the default font of your app, andadd new fonts to your project.TIPWhen you change the default font of your app, it will be reflected on all the text elements where the Font family is Default.Icons ​In the Icons sub-menu, you can find the icon sets that are active in your app. By default, you've got access to WeWeb regular icons, Fontawesome and Heroicons icon sets.TIPCurrently, importing a new icon set in a WeWeb project is a bit cumbersome but possible.Custom code ​Here you can add some custom code (HTML, CSS or JavaScript) that will be added to all your project's pages.It's were you typically want to add a global CSS style or scripts from external tools like Google Analytics, Intercom chatbox, or Axeptio, to name a few.You have the availability to add the scripts in the head or the body of the page:TIPAdd the scripts in the header if you need them to be loaded before the rest of the page by the end user's browser. But add them in the body if they're not critical and to get better pagespeed, hence, better SEO performances.WARNINGThis is an advanced behavior. You can break your app if you don't know what you're doing or adding unknown scripts.WARNINGWhen you add custom CSS to a page or project, you should not add any <head> or <body> tags. WeWeb handles those tags for you.Redirections ​Redirections are used when you want a path on your domain to redirect to another URL (be it on your domain or any other external URL).It's especially useful for SEO, when you're switching from a former app/site to a WeWeb app.Let's say that you used to have a page's URL at https://{yourdomain}/hello-world that you want to redirect to your WeWeb project's home page.It would look something like this: The Source is the path you want to redirect (not the full URL but the path after the domain name).The Target status is the HTTP status code you want to trigger on redirect (you can refer to MDN docs for this).The Target type is the Page to redirect to a page in your current app or External URL to redirect to any URL on the web.The Target page or Target URL is the page in your WeWeb project or external URL you want to redirect to.TIP90% of the time, when you want to do an SEO redirect, use a 301 redirect to forward Google's page rank and link juice to the new URL.Once you added redirections in a project, they will be displayed in the Redirections tab:Headers ​In this section, you can:Control if & how your WeWeb app can be embedded in an iframe.Add custom headers to your published project.Iframe embedding ​By default, once published, your WeWeb app can be embedded in an iframe.Here, you can:decide if you want to allow iframe embedding for your WeWeb app,allow it only on the same domaine, orblock it.Custom headers ​Here, you can add custom headers to your WeWeb app. In the example above, we started configuring a Content Security Policy.Base tag ​WARNINGChanging the base tag is an advanced feature that should be used if you 100% know what you're doing. You can totally break your app by changing it.Changing the base tag is useful when you're hosting your WeWeb app yourself, on a specific subpath.To learn more about base tags, please refer to MDN docs.Project plans ​This is will open the Project plans tab where you can choose a different project plan:TIPTo switch to a different workspace plan, you'll need to go to the Members tab in your workspace dashboard:Development ​This will open the Development panel where you can:open the WeWeb dev editor,view the custom elements, components, and plugins you added to the project, andlearn more about developing custom components in WeWeb."
  },
  {
    "h1": "Mobile apps (PWA)​",
    "url": "https://docs.weweb.io/editor/app-settings/pwa.html",
    "content": "Mobile apps (PWA) ​What is a PWA ​A Progressive Web App (PWA) is an application built using web technologies, providing a user experience similar to that of a mobile app.Web Access: Like a website, a PWA can be accessed through web browsers.Installation: Like a mobile app, a PWA can be installed on a device such as a phone, tablet, or computer.Enabling mobile app features ​To allow users to install your WeWeb app on their devices, first go to More > Mobile App (PWA) in the WeWeb editor:Then, select Enable and provide the following required information:App name: The name that will appear under the app icon on the home screen.App icon: The icon that will be displayed on the device's home screen.Theme color: Define the theme color see MDN documentationBackground color: Set the background color see MDN documentationDisplay: Choose how the app will be displayed on the user's device (learn more about PWA display options).Once you have filled out the required information to establish the PWA manifest, publish your WeWeb app.Disabling mobile app features ​If you need to disable the PWA features of your WeWeb app:Go to More > Mobile App (PWA) in the WeWeb editor.Select Disable and publish your WeWeb app.When you disable the PWA features:The project will be published without a PWA manifest and service worker.Users will no longer be able to install the app on their devices.The app will only be accessible via a web browser.Installing a PWA on a phone ​To install your WeWeb app on their phone, users will need to open it in a browser and save it to the homescreen.When they click on the app's icon to launch it, it will behave like \"classic\" mobile app.TIPHow users can save the app on their phone will vary depending on the phone and/or browser they're using.iOS examplebrowse to the web apptap on the Share iconchoose Save to Home ScreenAndroid examplebrowse to the web apptap on the Install iconfollow on-screen instructionsUpdating a PWA ​When you publish a new version of your app through WeWeb, there is no action required on your side to update the version of the app installed on your users' phones.Every time you publish a new version of your app, there is a version attached to it. When a user opens the app on their phone, there is an automatic check and the latest version is displayed.That is standard PWA, not specific to WeWeb.Enhanced PWA Functionality​ ​For more advanced PWA features and functionality, please check our PWA plugin article."
  },
  {
    "h1": "Import Figma designs​",
    "url": "https://docs.weweb.io/editor/figma/import-figma-designs.html",
    "content": "Import Figma designs ​Add WeWeb plugin in Figma ​WeWeb has an official Figma to WeWeb plugin that can import styles from Figma, but also import designs.In order to start using the plugin, find and add it from the Figma Community on the following Figma to WeWeb Toolkit plugin link.LOOKING TO IMPORT COLORS & TYPOGRAPHIES?With our plugin, you can also import Figma color and typographies to the library of a WeWeb project.Learn how to import Figma styles in a WeWeb library.Best practices for best results ​Before using the plugin, it's important to remember that the quality of the conversion will largely depend on the organization of the Figma designs.Here are some important guidelines to follow:use Auto Layout as much as possible,use frames instead of groups, andavoid shapes such as rectangles and ellipses, use frames instead.Tag elements in Figma ​Since WeWeb has it's own element types such as buttons and inputs which cannot be defined natively in Figma, users have to do that manually.Our plugin makes this easy to do by allowing you to select any number of frames and click on the corresponding element type in the plugin interface.This node in Figma will be imported as the selected element inside WeWeb:Import design in WeWeb ​After tagging elements and making sure you are using Auto Layout, the design is ready to be imported.In Figma, click on the Generate button and wait for the success notification.In the WeWeb Editor, click on More > Import from Figma.Then, paste the design on any of your pages."
  },
  {
    "h1": "Using the Add Panel​",
    "url": "https://docs.weweb.io/editor/how-to-use-the-add-panel.html",
    "content": "Using the Add Panel ​Add an element on the page ​The Add panel is where you can find UI blocks to add to your web application. These can be anything, from simple texts to complex forms.To add an element to your app, simply drag and drop it where needed in your app:The Add panel is composed of different sections, let's discover each category.Basics ​This is where you can find commonly used elements with limited style presets that act a great starting point to build your own design.Basic elements include but are not limited to sections, navigation menus, containers, headings, images, buttons, inputs, etc.Assets ​This is where you will find the UI components and templates from available libraries, i.e. the current project library and libraries that were added to the project.TIPLearn more about working with Libraries in WeWeb.Multi-page sections ​This is where you will find the list of existing sections in your app:Linked sections: lists all the sections that are linked on multiple pages in your app.Pages: lists all the pages in your app with all the sections (linked or not) on each page.From this panel, you can drag-and-drop a section on a page. When you drop a section on a page, you will be prompted to decide if you want to Create an instance or Create a copy of that section:THE POWER OF MULTI_PAGE SECTIONSWhen you create an instance of a section, it is also called a \"Linked section\" or a \"Multi-page section\".The changes you make on one instance of a linked section will be reflected on all other instances of this section, throughout the app.Learn more about leveraging multi-page sections to improve page load speed of your WeWeb apps.Plugin UI kits ​Here, you'll find elements that are specific to the plugins you installed.For example: authentication forms for auth plugins, charts, maps, etc."
  },
  {
    "h1": "Intro to HTML & CSS​",
    "url": "https://docs.weweb.io/editor/intro-to-html-css.html",
    "content": "Intro to HTML & CSS ​When you visit a web page, when you're looking at the actual content, what you see on the screen is your browser making decisions based on what's in the code of the page.The browser uses this code – i.e. the HTML, CSS, and Javascript information – to render the web page. When the browser finally loads up the page, it displays what you see on the screen.You can see this code in your browser when you open the inspector 🕵️In fact, you can even change the code on the page. When you change the code, the browser will instantly update what you see on the page.But of course, when you refresh the page, the changes go away because you only made the changes locally in the browser, not in the actual code base hosted on the internet.In the example below, you can see us open the browser’s inspector and update:The HTML text in the buttonThe CSS color and size of the text in the buttonHTML is generally used for content. It tells the browser what's on the page. For example, headings, paragraph links, images, etc.CSS, on the other hand, is used to style the content. For example, to change the font color or size.In the past, you would have one HTML file where you would write the content and style it.Nowadays, you write and structure the content in an HTML file. Then, you style the content in a CSS file.In the HTML file, you include a link to your CSS file – also called stylesheet – and structure the content with classes and ids that make it easy to style similar elements and components in your CSS file.For example, you might have several HTML files containing the content of several pages on your web app but you would like the buttons to look the same on all the pages.In that case, you could add classes in your HTML files. For example, button-primary and button-secondary could refer to the main CTA button and the secondary CTA button on your pages.Then, in your CSS file, you could style each button class only once.Elements in your HTML file can reference the styles in your CSS file at any time. If you make a change to that style in the CSS file, it affects any element that's using that style in your HTML file.Why do we need to know this? ​Well, WeWeb is a frontend builder. As a frontend builder, we help you visually design what will appear in the user’s browser.As you have seen in the Intro to the Editor, WeWeb allows you to:Add HTML elements in the NavigatorEdit the content of these HTML elements in the CanvasChange the CSS style of these HTML elements in the Right Panel"
  },
  {
    "h1": "Intro to the editor​",
    "url": "https://docs.weweb.io/editor/intro-to-the-editor.html",
    "content": "Intro to the editor ​The WeWeb Editor is where you build your projects.It is made up of 4 sections:the top navigation menu,the canvas in the middle,the left panel, andthe right panel.Topbar ​The topbar is where you can:go back to your dashboard or access project settingsmanage pages and page languages to your projectadd elements, libraries, plugins, and users to your web appask WeWeb AI to help you build your appmanage PWA settings, project assets, and custom codenavigate between changes, editing and preview modes, and breakpointssee who is currently editing the projectpublish the appProject settings ​Here you can:view available shortcutsnavigate to project settingsnavigate back to your dashboardswitch the Editor to light or dark modePages ​This is where you can:see the list of pages in your app,create new pages, andnavigate between pages in your app.TIPWhen creating a new page, you can save time by copying it from another page and choosing which sections are linked:The changes you make in linked sections will be reflected on all the pages that use that linked section.Learn more about leveraging multi-page sections to improve your WeWeb app's performances.Languages ​Here you can toggle between languages to see how text content will vary depending on your user's browser language.To enable this feature, you will first need to:add a language to the project, andenable it on all relevant pages (you can choose to enable a language on some pages only)TIPNotice that when you have more than one language available on a page:for one text element in the HTML tree,you have several text binding options in the style tab, andthe text displayed on the page matches the text defined for the language selected in the topbarAdd panel ​In the Add menu, you will find 4 categories of items:Basics: commonly used elements & layouts with minimal style presets.Assets: components & templates from the libraries available in the project.Multi-page sections: list of sections being used throughout the project.Plugin UI kits: UI blocks that are specific to plugins used in the project (e.g. charts, login forms).You can drag-and-drop elements from the add menu on the canvas:Libraries ​In the Libraries menu, you will find:the UI kit attached to your current projectexternal UI kits that you have added to your projectexternal UI kits that are available to you but that you haven't added to your projectUI kits that are present in your workspace but that haven't been shared with the workspaceTIPTo use an external library in a project, it needs to have been have been shared in your workspace, and Added in the project.Learn more about using UI libraries in WeWeb.Plugins ​The Plugins menu is where you will find:the plugins that have already been added to the project, andall available WeWeb plugins.There are currently 3 categories of plugings:Data sources, like Xano, Supabase, REST API, and moreAuthentication systems, like Auth0, OpenID, JSON Web Tokens, and moreExtensions, like Stripe, Charts, Mapbox, OpenAI, and moreTo add a plugin, simply navigate to the plugin category of your choice, select a plugin and click on the Add button: Learn more about using plugins in WeWeb.TIPWe don't add popular plugins like charts and dates to every project by default because, under-the-hood, each plugin loads a JS library.As in traditional web development, we refrain from adding uneeded libraries to your no-code apps.Auth ​In the Auth menu, there are three sections:Users where you can import, export, or view users of your appRoles where you can add user roles and user groups to handle user permissionsFile storage where you can see the files uploaded by app usersLearn more about working with authentication plugins in WeWeb.WeWeb AI ​This is where you can ask WeWeb AI how to build something or use a text prompt to create a section or element that you will then be able to drag-and-drop on the page.More ​In the more menu, you will find features that apply at app level:This is where you can:define the manifest for the PWA version of the app,trigger workflows at app level,add languages to your project,manage project assets like images and fonts,upload custom app files (e.g. sitemap, manifest, service worker, etc.)add custom code at app level,add redirections, and a base tag,add custom headers,subscribe to a different plan,access WeWeb developer tools.Learn more about WeWeb app settings.Canvas ​The Canvas is the great big part in the middle. It’s where you can interact with the page in real-time.You can select elements, move them around, and edit content right on the page:The layout of everything you build in the Canvas follows the box model with sections and elements that are responsive by default.It ensures that we’re generating clean, production-ready code.You can edit and preview this on three different views – desktop, tablet, mobile – and publish when you’re ready:Left panel ​In the left panel of the WeWeb editor, you will find:the HTML tree of the page you're on in the Layout tabthe data collections and global variables in the Data tabthe global workflows and formulas in the Actions tab, andthe debugger panel with app logs and the current state of variablesLayout panel ​In the Layout panel, you will see the HTML tree of the page you are currently on.In the example below, you can see we are on the Jobs page and selected the heading element in our HTML tree.As a result, the element is selected on the Canvas and we can edit its properties in the right panel:Data panel ​In the Data panel, you can:see all the collections available in the project or used on the current page,create new collections and variables, andupdate or delete existing ones.TIPCollection and variables are essential tools to build dynamic web applications in WeWeb.Learn more about working with collections and variables in WeWeb.Actions panel ​In the Actions panel, you can create, edit, and delete global workflows and formulas that you can then use throughout your project.TIPWorkflows and formulas are essential tools to build dynamic web applications in WeWeb.Learn more about working with workflows and formulas in WeWeb.Debugger panel ​In the debugger panel, you will find:the logs of what is happening in your application, andthe current values of global variablesRight panel ​The panel on the right gives you precise control over the element that is selected on the page.It allows you to:style the element,bind data to the element,change settings that are specific to that type of element,add no-code workflows on the element."
  },
  {
    "h1": "Logs​",
    "url": "https://docs.weweb.io/editor/logs.html",
    "content": "Logs ​In the Navigator of the WeWeb editor, you can open the Logs tab in the Debugging panel to see what is happening in your app:In the example above, you can see what happens when you open a project in the WeWeb editor:the application is started,collections start being fetched,the authenticated user value is set,data from collections are fetched, etc.The Logs panel is helpful:to understand what's happening in a workflow that is not behaving as expected, andto improve the UX and performance of a page by looking at what happens when the user arrives on the page.Workflow debugging ​When you are working with workflows, it can be helpful to look at the logs of what's happening when you execute the workflow:In the example above, we can see that:our backend returned an error,the error was caused by a user trying to login with invalid credentials,the workflow moved on to the error branch as a result, andstarted going through the actions in the error branch.TIPBefore testing a workflow, try clearing the logs to get a nice clean view of what is happening:UX & performance audit ​When you develop an app, things can start getting complex quickly.In order to scale your projects, it helps to audit the UX and performance of your pages on a regular basis.For example, you can use the Logs panel to check that:only essential data collections are fetched on page load, andvariables are updated in the order you would expect.Example 1 - flow of actions ​If a displayError variable is updated before an errorMessage variable, you might see an unwanted blink before the text of the errorMessage is updated.Changing the order of these actions will greatly improve the experience of your users.Example 2 - collections fetched ​On one page, we couldn't figure out why the list of jobs always appeared as empty on page load, only to be populated when the user interacted with filters on the page.It turns out we were fetching an old collection on page load (jobs instead of jobs_):The jobs_ collection was only fetched On change when the user interacted with a filter on the page.After identifying the problem, we were able to get rid of the old collection (decluttering our developer environment along the way) and optimize the loading of the jobs_ collection."
  },
  {
    "h1": "Accordion​",
    "url": "https://docs.weweb.io/elements/accordion.html",
    "content": "Accordion ​An accordion lets you click to reveal more content, making it perfect for organizing information in a neat, expandable way.Components of the Accordion ​The accordion is made up of three main parts:Opened Header: This is what you see when the accordion is expanded. It includes the text and icon for the open state.Header: This is visible when the accordion is closed, showing the text and icon for the closed state.Content: This is the text that appears inside the accordion when it's expanded.By default, when you drop the accordion onto the canvas, it starts off expanded. To see how it looks when closed, just switch to preview mode and close it."
  },
  {
    "h1": "Calendar​",
    "url": "https://docs.weweb.io/elements/advanced_calendar.html",
    "content": "Calendar ​The Calendar element provides a feature-rich interface for displaying and managing events in various time-based views. It offers multiple view options, event management capabilities, and extensive customization to fit your specific requirements.Features ​Multiple View Types: Year, month, week, day, and list viewsEvent Management: Display, create, update, and delete eventsDrag & Drop Support: Easily reschedule events by draggingEvent Resizing: Adjust event duration by stretchingResponsive Design: Adapts to container sizeFull Styling Control: Customize colors, fonts, and dimensionsInternationalization: Support for multiple languagesTime Grid: Configurable time slots for week and day viewsInteractive Features: Event selection, view switching, date navigationGetting Started ​Using AI ​The quickest way to set up a calendar is by using AI:Ask AI to add the calendar. Make sure to specify: Specific styling requirementsAny contextual data you would like it to useSettings you would like appliedThe AI will then create your styled calendar:Continue refining your calendar by asking for specific adjustments: \"Change the calendar to start weeks on Sunday\"\"Add a red indicator line for the current time\"\"Hide weekends on the calendar\"\"Make today's date background yellow\"Manual Setup ​Add a Calendar element to your page from the Add panelConfigure the view settings in the properties panel: Select which views to enable (year, month, week, day, list)Choose a default viewSet the localeConfigure events: Add static events directly in the properties panel, orBind to a collection or variable containing event dataCustomize the appearance through style properties: Colors for header, cells, buttons, and eventsFont settingsDimensions and spacingViews ​The calendar offers five different views to display your event data:ViewBest ForImageYearAnnual planning, long-term overviewMonthTraditional calendar view with all days in monthWeekDetailed weekly schedule with time slotsDayFocused view of a single day's scheduleListCompact, text-based event listingConfiguring Views ​In the calendar properties, you can enable/disable available views:Set a default view that will be shown when the calendar first loadsUsers can switch between enabled views using the buttons in the calendar header:View-Specific Settings ​Time Grid (Week & Day Views) ​For week and day views, you can customize the time range displayed:Time Start: Set the starting time for the time grid (format: \"HH:MM:SS\")Time End: Set the ending time for the time grid (format: \"HH:MM:SS\")For example, setting the Time Start to 12:00:00 and the Time End to 18:00:00 would retrict the times like so:Day Display Options ​Control which days are shown in the calendar:Hide Weekends: Hide Saturday and SundayStart Week on Sunday: Change the first day of the week to SundayHide Days of Week: Hide specific days by entering their numeric values (0=Sunday, 1=Monday, 2=Tuesday, etc.). In the example below, Tuesday and Thursday is being hidden:ManualDynamic BindingEvents In The Calendar ​Events are the core data elements displayed on the calendar. Each event represents a scheduled activity with a start and end time.Understanding Event Fields ​Each event can contain the following fields:FieldPurposeExample ValueIDUnique identifier used by the calendar to track events\"event-123\"TitleMain text displayed on the event\"Team Meeting\"StartWhen the event begins (ISO format)\"2025-04-15T10:00:00\"EndWhen the event ends (ISO format)\"2025-04-15T11:30:00\"All DayWhether the event is shown in the all-day sectiontrue or falseBackground ColorBackground color of the event block\"#3788d8\"Border ColorColor of the event's border\"#2C5F9E\"Text ColorColor of the event's text\"#FFFFFF\"ContentExtended description or notes about the event\"Quarterly planning session with all department heads\"Group IDLinks related events that should move together\"team-meetings\"DataCustom data object for storing any additional information{ \"roomId\": \"A201\", \"priority\": \"high\", \"requiredAttendees\": [\"alice\", \"bob\"] }The Content Field is useful for storing longer descriptions, details, or instructions related to an event. This content isn't displayed directly on the calendar but can be accessed when handling event clicks to show in tooltips, modals, or detail panels.The Data Field is a flexible container for any additional information about the event that doesn't fit into the standard properties. You can store complex objects with custom properties that your application needs, such as:Associated users or resourcesMetadata like creation time or last modificationStatus informationCustom flags or settingsRelated record IDs from your databaseWhen using the field mapping feature, you can specify which properties from your data source correspond to each of these event fields.Event Properties ​Each event requires the following properties:PropertyDescriptionIDUnique identifier for the eventTitleEvent title displayed on the calendarStartStart date/time (ISO format: YYYY-MM-DDTHH:MM:SS)EndEnd date/time (ISO format: YYYY-MM-DDTHH:MM:SS)All DayBoolean indicating if the event spans the whole dayAdditional optional properties:PropertyDescriptionBackground ColorBackground color for the eventBorder ColorBorder color for the eventText ColorText color for the eventContentExtended description or details for the event, often used for displaying additional information in tooltips or popupsGroup IDIdentifier for related events that should move together when draggedDataAdditional custom data for the event (can store any JSON object with custom properties)WARNINGIf you do not want items to move together when dragged, ensure the Group ID you use is unique to each item.Adding Static Events ​For simple use cases, you can add events directly in the calendar properties:In the calendar properties panel, find the \"Events\" sectionClick the \"+\" button to add a new eventFill in the required propertiesAdd as many events as neededBinding Dynamic Events ​For most applications, you'll want to bind events from a collection or variable:Create a collection or variable containing your event dataIn the calendar properties panel, bind the \"Events\" property to your data sourceIf your data structure doesn't match the expected format, use the field mapping options to specify which fields correspond to event propertiesInteracting With The Calendar ​Event Interaction ​The calendar provides several ways for users to interact with events:Clicking Events ​When a user clicks on an event, the On event click trigger fires with the complete event data. Use this to:Show event details in a popupNavigate to an event details pageAllow editing of the eventjavascript// This event data is available from the `On event click` trigger { \"id\": \"event1\", \"title\": \"Meeting with Team\", \"start\": \"2025-04-06T10:00:00\", \"end\": \"2025-04-06T11:00:00\", \"allDay\": false, \"backgroundColor\": \"#3788d8\", \"borderColor\": \"#3788d8\", \"textColor\": \"#ffffff\", \"content\": \"Weekly team sync meeting\" }In the example below, a workflow has been created with the On event click, and in the workflow the data available from the On event click is being logged:Dragging Events ​Users can reschedule events by dragging them to a new date/time:The On event drag start trigger fires when dragging beginsThe On event drag end trigger fires when the drag gesture endsThe On event drop trigger fires when the event is dropped at a new positionThe On event drop trigger provides the updated event data along with a delta object showing the change:javascript{ \"id\": \"event1\", \"title\": \"Meeting with Team\", \"start\": \"2025-04-07T10:00:00\", // Updated date \"end\": \"2025-04-07T11:00:00\", // Updated date \"allDay\": false, \"delta\": { \"days\": 1, \"milliseconds\": 0 } // Moved by 1 day }In the example below, there are workflows created on all three drag events (On event drag start, On event drag end, and On event drop) to log the event data.On the first drag, the event is not moved to a different time, and thus the On event drop trigger does not fire. However, on the second drag, the event is moved to a different time, and thus the On event drop trigger does fire:Resizing Events ​When in the Week, Day, or Month view, users can adjust event duration by dragging the bottom edge of events:The On event resize start trigger fires when resizing beginsThe On event resize trigger fires when resizing is completeThe On event resize trigger provides delta information showing how the event was changed:javascript{ \"id\": \"event1\", \"title\": \"Meeting with Team\", \"start\": \"2025-04-06T10:00:00\", \"end\": \"2025-04-06T12:00:00\", // Updated end time \"allDay\": false, \"startDelta\": { \"days\": 0, \"milliseconds\": 0 }, \"endDelta\": { \"days\": 0, \"milliseconds\": 3600000 } // Extended by 1 hour }In the example below, workflows are created for both resize events (On event resize start and On event resize) to log the event data:Creating New Events ​Users can create new events by selecting a time slot:Click and drag over the desired time period on the calendarThe On event created trigger fires with the selected date and time rangejavascript{ \"start\": \"2025-04-06T14:00:00\", \"end\": \"2025-04-06T15:00:00\", \"allDay\": false }Use this data to:Populate a form for creating a new eventDirectly add an event to your data sourceShow a confirmation dialogHandling Event Creation/Modification ​To pragmatically handle the creation and modification of events, there are three core workflows you need to create on the calendar:Using the On event created trigger, a workflow to add to your existing events dataIn practice, your workflow would be something like this:Ensuring to send the new event data to your backend for creation in your database, like so:Using the On event updated trigger, a workflow to update your existing events dataIn practice, your workflow would be almost identical to the event creation workflow:The key difference being the event data you send to your backend is used for updating and not creation:Using the On event clicked trigger, a workflow to show a modal/popup that allows the user to make specific edits to the event meta information, like the title.The calendar automatically exposes which event was most recently clicked via the selectedEvent variable, so we can use this information in our modal/popup and allow editing:Then, on our delete and submit buttons, we would have workflows set up to appropriately communicate the needed changes to our backend (e.g. delete the record or update it), and then close the modal/popupREFETCH DATAAfter creating an event, changing an event, or deleting an event in your backend, always ensure you refetch the data so the calendar has the latest, correct data.Custom Calendar Header ​The calendar element provides the option to hide the default header and create your own custom header design.Hiding the Default Header ​In the calendar properties, set the Header toggle to \"Off\"The default navigation buttons, title, and view selectors will be hiddenCreating a Custom Header ​With the default header hidden, you can build your own header with full control over its appearance and functionality:Create a container above the calendar elementAdd your own buttons, text elements, dropdowns, and other UI elementsUse element actions to connect your custom UI to the calendar functionalityTIPIf you are unsure how to style your custom header, get AI to do it for you! Here is an example prompt:Please create a custom header for my calendar. I want a sleek, modern design.Connecting Custom UI to Calendar Actions ​Use these component actions of the calendar to make your custom header elements work with the calendar:UI ElementAction to UsePurposePrevious buttonPrevious periodMove backward in timeNext buttonNext periodMove forward in timeToday buttonGo to todayJump to current dateView selectorChange viewSwitch between view typesDate pickerGo to dateNavigate to a specific dateProperties Reference ​Settings ​PropertyTypeDescriptionReadonlyToggleControls whether users can interact with the calendar to create or modify eventsView Settings ​PropertyTypeDescriptionLocaleSelectSets the language (auto uses current site language)Default ViewSelectInitial view when calendar loadsYear ViewToggleEnable/disable year viewMonth ViewToggleEnable/disable month viewWeek ViewToggleEnable/disable week viewDay ViewToggleEnable/disable day viewList ViewToggleEnable/disable list viewShow All-Day EventsToggleShow or hide the all-day slotTime StartTextStart time for day/week views (HH:MM:SS)Time EndTextEnd time for day/week views (HH:MM:SS)Hide WeekendsToggleHide Saturday and SundayStart Week on SundayToggleStart weeks on Sunday instead of MondayHide Days of WeekListSpecific days to hide (0=Sunday, 1=Monday, etc.)Event Properties ​PropertyTypeDescriptionEventsArrayCollection of events to display↳ Event ID FieldPathField to use as event ID↳ Event Title FieldPathField to use as event title↳ Event Start Date FieldPathField to use as event start date↳ Event End Date FieldPathField to use as event end date↳ Event All Day FieldPathField to use as event all-day flag↳ Event Background Color FieldPathField to use as event background color↳ Event Border Color FieldPathField to use as event border color↳ Event Text Color FieldPathField to use as event text color↳ Event Content FieldPathField to use as event content/description (can contain HTML or plain text)↳ Event Data FieldPathField to use for storing additional custom data (any JSON object with custom properties)↳ Event Group ID FieldPathField to use as event group ID (for events that should move together)Button Text Properties ​PropertyTypeDescription\"Today\" Button TextTextCustom text for the Today button\"Year\" Button TextTextCustom text for the Year view button\"Month\" Button TextTextCustom text for the Month view button\"Week\" Button TextTextCustom text for the Week view button\"Day\" Button TextTextCustom text for the Day view button\"List\" Button TextTextCustom text for the List view buttonNo Events TextTextText to display when no events are availablePropertyTypeDescriptionHeaderToggleControls whether the default header is displayedStyling ​General ​Control the overall appearance of the calendar:PropertyDescriptionFont FamilySets the typeface for all calendar textFont SizeControls the size of text elementsFont WeightSets the boldness of textNow Indicator ColorColor for the line showing current timeHeader ​Customize the appearance of the calendar's header:PropertyDescriptionBackgroundBackground color for the header areaText ColorColor for text in the headerHeader HeightSets the height of the header areaDay Header ​Customize the appearance of the calendar's day header:PropertyDescriptionBackgroundBackground color for the day header areaText ColorColor for text in the day headerDay Header HeightSets the height of the day header areaFont SizeSize of text in the day headerFont WeightWeight of text in the day headerWeekend Text ColorColor of text in the day headerCells ​Style the calendar's date cells and today's highlight:PropertyDescriptionToday BackgroundHighlight color for the current dayBackgroundDefault background color for day cellsText ColorDefault text color for day cellsOther Month BackgroundBackground for days from adjacent monthsOther Month TextText color for days from adjacent monthsTime Grid ​Style the time-based views (week and day views):PropertyDescriptionBackgroundDefault background color of time gridButtons ​Customize the appearance of all navigation and view selection buttons:PropertyDescriptionBackgroundBackground color for calendar buttonsText ColorColor for button textHover BackgroundBackground color when hovering over buttonsHover TextText color when hovering over buttonsActive BackgroundBackground color for the active buttonActive TextText color for the active buttonBorder RadiusRoundness of button cornersToday Button BackgroundBackground color of the Today buttonToday Button Text ColorText color of the Today buttonToday Button Hovor BackgroundBackground color on hover of the Today buttonToday Button Hovor Text ColorText color on hovor of the Today buttonBorders ​Configure the border appearance throughout the calendar:PropertyDescriptionColorColor of borders in the calendarEvents ​Style the appearance of event blocks on the calendar:PropertyDescriptionBackgroundDefault background color for eventsBorderDefault border color for eventsText ColorDefault text color for event titlesComponent Actions ​ActionDescriptionParametersChange viewChanges the calendar viewviewName: \"multiMonthYear\", \"dayGridMonth\", \"timeGridWeek\", \"timeGridDay\", or \"listWeek\"Go to dateNavigates to a specific datedate: Date string in YYYY-MM-DD formatNext periodAdvances to the next periodNonePrevious periodGoes back to the previous periodNoneGo to todayJumps to the current dateNoneExposed Variables ​VariableTypeDescriptioncurrentViewStringThe currently active view typeselectedEventObjectThe most recently clicked event dataEvent Triggers ​The calendar provides the following events you can use to trigger workflows:EventDescriptionPayloadOn event clickTriggered when an event is clickedEvent data objectOn view changeTriggered when the view or date range changesView information objectOn event createdTriggered when a time slot is selectedNew event time rangeOn event updatedTriggered when an event is updatedUpdated event dataOn event drag startTriggered when event dragging beginsEvent data objectOn event drag endTriggered when event dragging endsEvent data objectOn event dropTriggered when an event is dropped in a new positionEvent data with deltaOn event resize startTriggered when event resizing beginsEvent data objectOn event resizeTriggered when an event is resizedEvent data with deltasExample Event Trigger Payloads ​On event click ​json{ \"id\": \"event1\", \"title\": \"Meeting with Team\", \"start\": \"2025-04-15T10:00:00Z\", \"end\": \"2025-04-15T11:00:00Z\", \"allDay\": false, \"backgroundColor\": \"#3788d8\", \"borderColor\": \"#3788d8\", \"textColor\": \"#ffffff\", \"content\": \"Discuss Q2 planning\", \"groupId\": \"team-meetings\", \"data\": { \"roomId\": \"A101\", \"organizer\": \"John Smith\" } }On view change ​json{ \"view\": \"dayGridMonth\", \"start\": \"2025-04-01T00:00:00Z\", \"end\": \"2025-05-01T00:00:00Z\", \"title\": \"April 2025\" }On event created ​json{ \"start\": \"2025-04-15T14:00:00Z\", \"end\": \"2025-04-15T15:00:00Z\", \"allDay\": false }On event updated ​json{ \"id\": \"event1\", \"title\": \"Updated Meeting\", \"start\": \"2025-04-15T10:00:00Z\", \"end\": \"2025-04-15T11:00:00Z\", \"allDay\": false, \"backgroundColor\": \"#3788d8\", \"borderColor\": \"#3788d8\", \"textColor\": \"#ffffff\", \"content\": \"Discuss Q2 planning - Updated\" }On event drag start ​json{ \"id\": \"event1\", \"title\": \"Meeting with Team\", \"start\": \"2025-04-15T10:00:00Z\", \"end\": \"2025-04-15T11:00:00Z\", \"allDay\": false }On event drag end ​json{ \"id\": \"event1\", \"title\": \"Meeting with Team\", \"start\": \"2025-04-15T10:00:00Z\", \"end\": \"2025-04-15T11:00:00Z\", \"allDay\": false }On event drop ​json{ \"id\": \"event1\", \"title\": \"Meeting with Team\", \"start\": \"2025-04-16T10:00:00Z\", // Notice the date changed \"end\": \"2025-04-16T11:00:00Z\", // Notice the date changed \"allDay\": false, \"delta\": { \"days\": 1, \"milliseconds\": 0 } }On event resize start ​json{ \"id\": \"event1\", \"title\": \"Meeting with Team\", \"start\": \"2025-04-15T10:00:00Z\", \"end\": \"2025-04-15T11:00:00Z\", \"allDay\": false }On event resize ​json{ \"id\": \"event1\", \"title\": \"Meeting with Team\", \"start\": \"2025-04-15T10:00:00Z\", // Start time unchanged \"end\": \"2025-04-15T12:00:00Z\", // End time changed \"allDay\": false, \"startDelta\": { \"days\": 0, \"milliseconds\": 0 }, \"endDelta\": { \"days\": 0, \"milliseconds\": 3600000 // Extended by 1 hour (3,600,000 milliseconds) } }"
  },
  {
    "h1": "Datagrid (Advanced)​",
    "url": "https://docs.weweb.io/elements/advanced_datagrid.html",
    "content": "Datagrid (Advanced) ​The advanced datagrid component allows you to display and interact with structured data in a tabular format. Built on the AG Grid framework, it offers high-performance rendering with advanced features like sorting, filtering, pagination, and cell editing. You can fully customize its appearance and behavior to meet your specific requirements.Features ​High-Performance Rendering: Efficiently handles large datasets with virtual scrollingAdvanced Sorting & Filtering: Helps users quickly find and organize dataRow Selection: Single or multiple row selection with full event handlingInteractive Cell Editing: Edit data directly within the grid with validationCustom Cells: Add your own UI components to grid cellsPagination: Traditional page-based navigation for structured data reviewColumn Management: Resize, reorder, and pin columns as neededComprehensive Styling: Extensive appearance customization for all grid elementsGetting Started ​Using AI ​The quickest way to set up the datagrid is by using AI.First, ensure you have a variable or collection with your data ready.Ask AI: \"Create a datagrid that uses {{insert your data}}\". Make sure you pass in your data as context in the chat.Continue refining and customizing your datagrid by asking AI for specific modifications: \"Add an action column with an 'Edit' button\"\"Enable multiple row selection on the datagrid\"\"Make the email column wider and show the status column with color indicators\"\"Add pagination showing 5 rows per page\"Manual Setup ​Add the datagrid to your page from the Add panelConfigure the data source: Click the Data property and select a variable or collectionSet a unique row ID formula (typically using the primary key of your data)Click Generate Columns to create columns based on your data structureCustomize columns as needed through the properties panelConfigure appearance settings in the Style panelAdd workflows to handle interactions like row selection or action buttonsTIPWhen binding data to the datagrid, it is optimal for your data to be an array of objects, as this will allow the automatic generation of columns.If you are unsure what an 'array of objects' means, please refer to our guide on understanding variables: Variables Guide.Column Configuration ​The datagrid organizes your data into columns that can be extensively customized.Column Types ​TypeBest ForTextString dataNumberNumeric valuesBooleanTrue/false valuesDateDate stringsImageImage URLsActionInteractive buttonsCustomComplex elementsCustom Display Formatting ​For Text, Number, Boolean, and Date columns, you can customize how values are displayed without changing the underlying data:Select a column in the properties panelToggle on Custom display valueCreate a formula that transforms the raw value into your desired formatInteractive Features ​Cell Editing ​Enable users to edit data directly in the grid:Select a column in the properties panelToggle on EditableUsers can now double-click a cell to edit its contentCreate a workflow on the datagrid using the On Cell Value Changed triggerIn your workflow, you'll have access to: The old valueThe new valueWhich column was changedThe complete row dataRow Selection ​Allow users to select one or multiple rows:In the datagrid properties, set Row Selection to either Single or MultipleUsers can now select rows by clicking on themCreate workflows for selection events: On Row Selected: Triggered when a row is selectedOn Row Deselected: Triggered when a row is deselectedAccess all currently selected rows via the exposed selectedRows variable OR access only the data of the row that triggered the On Row Selected or On Row Deselected eventAction Buttons ​Add interactive buttons to each row of your datagrid:Add a new column with type set to ActionConfigure: Action Name: Identifier for the action (used in workflows)Action Label: Text displayed on the buttonCreate a workflow on the datagrid using the On Action triggerIn your workflow, you'll have access to: Which action was triggeredThe complete row dataCustom Cell Content ​Create completely custom cell rendering:Add a column with type set to CustomA Dropzone appears on the canvas where you can add any UI elementsDrag and drop elements into this dropzone to create your custom cell appearanceThese elements will have access to the cell value and the entire row dataManaging Large Datasets ​The datagrid provides two approaches to handling large amounts of data:Virtual Scrolling (Default) ​By default, the datagrid uses virtual scrolling to efficiently render large datasets:Only visible rows are rendered in the DOMRows load dynamically as users scrollProvides smooth performance even with thousands of rowsPagination ​For a more traditional approach to large datasets:Toggle on Pagination in the datagrid propertiesSet the desired number of rows per page (default: 10)The datagrid will now display page navigation controls, and users can browse through pages of data.Advanced Usage ​Dynamic Column Definition ​For programmatically defining columns, bind the columns property to a variable with this structure:javascript[ { \"headerName\": \"Name\", \"cellDataType\": \"text\", \"field\": \"name\", \"width\": \"200px\", \"sortable\": true }, { \"headerName\": \"Price\", \"cellDataType\": \"number\", \"field\": \"price\", \"width\": \"100px\", \"sortable\": true }, { \"headerName\": \"In Stock\", \"cellDataType\": \"boolean\", \"field\": \"inStock\", \"width\": \"100px\" }, { \"headerName\": \"Product Image\", \"cellDataType\": \"image\", \"field\": \"thumbnail\", \"imageWidth\": \"50px\", \"imageHeight\": \"50px\" }, { \"headerName\": \"Actions\", \"cellDataType\": \"action\", \"field\": \"edit\", \"actionName\": \"editRow\", \"actionLabel\": \"Edit\" } ]Column Width Strategies ​The datagrid offers two approaches to handling column widths:Fixed Width: Set a specific pixel width for the columnGood for consistent layoutsBest for columns with predictable content lengthFlex Width: Distribute available space proportionallyAdapts to different screen sizesSet flex values to control relative proportionsColumn Pinning ​For tables with many columns, pin important columns to ensure they stay visible:Set the Pinned property to either Left or RightPinned columns remain fixed while users scroll horizontallyUseful for ID columns, status indicators, or action buttonsExample Use Cases ​Product Catalog: Display products with images, pricing, inventory status, and edit/view actionsUser Management: List users with filterable columns for roles, status, and registration datesFinancial Dashboard: Present financial data with custom number formatting and row selectionTask Tracker: Show tasks with status indicators, due dates, and action buttonsData Analysis: Enable sorting and filtering for data exploration with visual indicatorsForking ​While the DataGrid component offers extensive built-in customization options, there may be cases where you need functionality beyond what's natively available. In these situations, you can fork the component and modify it to meet your specific requirements.If you are unsure how to fork an element, you can learn more in the dedicated documentation.Forking Example: Custom Pagination Styling ​One reason to fork the DataGrid would be to create styling properties not available in the standard component. For example, you might want to be able to change the styling of the pagination.To do so, you could fork the datagrid, then edit with AI and pass in the following prompt:I want to edit this forked datagrid so that I can change the styling of the paginationThe AI will then add new styling properties to control the appearance of different aspects of the pagination: Properties Reference ​Settings Properties ​PropertyOptions/TypeDescriptionDataCollection/ArrayThe data to display in the gridUnique Row IDFormulaWhat to use for the Unique ID of each rowColumnsArrayConfiguration for each column in the gridRow SelectionNone, Single, MultipleDetermines how users can select rowsPaginationBooleanEnable/disable pagination for large datasetsRows Per PageNumberNumber of rows to display per page (when pagination is enabled)Movable ColumnsBooleanAllow users to reorder columns via drag and dropResizable ColumnsBooleanAllow users to adjust column widthsColumn Properties ​Each column in the datagrid can be configured with these properties:PropertyOptions/TypeDescriptionHeader NameTextThe title displayed at the top of the columnTypeText, Number, Boolean, Date, Image, Action, CustomThe type of data in this columnKeyTextThe field name from your data sourceWidthFixed/FlexColumn width approach (fixed pixel width or flexible)Min WidthPixelsMinimum column widthMax WidthPixelsMaximum column widthFilterBooleanEnable/disable filtering for this columnSortableBooleanEnable/disable sorting for this columnPinnedNone, Left, RightPin the column to the edge of the gridEditableBooleanAllow users to edit cell valuesCustom DisplayBooleanUse a formula to format how values are displayedImage Column Properties ​PropertyDescriptionImage WidthWidth of the displayed imageImage HeightHeight of the displayed imageAction Column Properties ​PropertyDescriptionAction NameIdentifier for the action (used in workflows)Action LabelText displayed on the buttonStyling Properties ​General ​PropertyDescriptionHeight ModeChoose between Fixed height or Auto (based on content)Grid HeightSet the height of the grid when using Fixed modeText ColorGlobal text color for the gridBorder ColorColor of grid bordersHeader ​PropertyDescriptionBackground ColorSet the background color of the header rowText ColorSet the color of header textFont WeightControl the boldness of header textFont SizeAdjust the size of header textFont FamilyChoose the font for header textRow ​PropertyDescriptionBackground ColorSet the background color of rowsAlternate ColorSet the color for alternating rowsHover ColorSet the background color when hovering over rowsVertical Padding ScaleAdjust vertical spacing in rows (0-5)Selected Background ColorHighlight color for selected rowsColumn ​PropertyDescriptionHover HighlightToggle column highlight effect on hoverHover ColorSet the color for the column hover effectCell ​PropertyDescriptionText ColorSet the color of cell textFont FamilyChoose the font for cell textFont SizeAdjust the size of cell textMenu ​PropertyDescriptionText ColorSet the color of text in filter menusBackground ColorSet the background color of filter menusAction ​PropertyDescriptionText ColorSet the color of action button textBackground ColorSet the background color of action buttonsPaddingAdd space around action button textBorderSet the border style for action buttonsBorder RadiusControl the roundness of action button cornersFont SettingsConfigure typography for action buttonsEvent Triggers ​The datagrid component provides events you can use to trigger workflows:EventDescriptionPayloadOn ActionTriggered when an action button is clicked{ actionName, row, id, index, displayIndex }On Cell Value ChangedTriggered after a cell value is edited{ oldValue, newValue, columnId, row }On Row SelectedTriggered when a row is selected{ row }On Row DeselectedTriggered when a row is deselected{ row }Example Event Payloads ​On Action ​javascript{ actionName: \"edit\", row: { id: 42, name: \"Product A\", price: 29.99, inStock: true }, id: 42, index: 5, displayIndex: 2 }On Cell Value Changed ​javascript{ oldValue: 29.99, newValue: 24.99, columnId: \"price\", row: { id: 42, name: \"Product A\", price: 24.99, inStock: true } }On Row Selected / On Row Deselected ​javascript{ row: { id: 42, name: \"Product A\", price: 29.99, inStock: true } }Exposed Variables ​The datagrid component exposes the following variables for use in your application:VariableDescriptionselectedRowsArray"
  },
  {
    "h1": "Alerts (Deprecated)​",
    "url": "https://docs.weweb.io/elements/alerts.html",
    "content": "Alerts (Deprecated) ​On this page, you'll learn:how to add alerts / notifications on your apphow to customize and trigger the alertsHow to add alerts on your app ​To add alerts to a page, go to Add> Layout and drop it anywhere on your page:Also import the section's variables and workflows so that you'll be able to use the alerts from the get-go.Once dropped, you can find the alert section in the navigator.As you can see, the alert is bound to a configuration variable. This variable is the alert's current state, telling it how and what to display. Edit the display option to false to make the alert stop appearing by default:It also comes with a workflow called Display Alert which we'll use later to trigger an alert.How to customize and trigger the alerts ​To trigger an alert from a workflow, choose the Execute workflow action and then the Display Alert workflow:In this action, they're several options you can use to trigger the alert and customize it:\"type\": the type/color of the alert. It could be: \"info\" (blue), \"warning\" (yellow), \"error\" (red), \"success\" (green), \"info-neutral\" (grey)\"title\": the alert's title\"description\": the text that'll appear in the bulk of the alert\"cta\": whether or not to display a call to action\"cta text\": the text of the call to action \"cta link\": the link the call to action leads to\"display\": whether of not to display the alert. To trigger it, switch this value to \"true\"\"delay (ms)\": how many milliseconds the alert will display before to disappear (best practice is 3000 to 5000ms, so 3 to 5 seconds).Here's a visual explanation of the fields:"
  },
  {
    "h1": "Autocomplete​",
    "url": "https://docs.weweb.io/elements/autocomplete.html",
    "content": "Autocomplete ​Provide users with a list of relevant options as they enter text.Configuring Autocomplete ​Property NameDescriptionOptionsBind this setting to a list of items that users can select from in the autocomplete feature.Initial ValueSet a default value that appears when the autocomplete is first displayed.PlaceholderProvide a hint or example text that guides users on what to input.RequiredEnable this toggle to make the autocomplete input mandatory for form submission."
  },
  {
    "h1": "Bottom Navigation Bar​",
    "url": "https://docs.weweb.io/elements/bottom-nav.html",
    "content": "Bottom Navigation Bar ​The bottom navigation bar sits at the bottom of your page, making it easy to access all the important links. Plus, it's responsive, so it looks great on any device/Components of the Bottom Nav bar ​The Bottom Nav bar consists of 1 container, which has a list of items, each meant for a different navigation link.Configuring the Bottom Nav Bar ​To customize the functionality and appearance of the Bottom Navigation Bar, adjust the following properties:Display On/Off: Toggle this setting to show or hide the Bottom Navigation Bar.Animation: Select from seven animation presets to determine how the Bottom Navigation Bar appears on the screen: Fade, Appear from Top, Appear from Right, Appear from Left, Appear from Bottom, Zoom In, and Zoom Out.Backdrop: Enable or disable a backdrop. When enabled, interactions are restricted to the Bottom Navigation Bar only.Transition: Define the behavior of the selected animation."
  },
  {
    "h1": "Breadcrumb​",
    "url": "https://docs.weweb.io/elements/breadcrumb.html",
    "content": "Breadcrumb ​The Breadcrumb element provides a navigation aid that helps users understand their current location within a website's hierarchy. It displays the path from the homepage to the current page, allowing users to easily navigate back to previous levels.Getting Started ​Using AI ​The quickest way to set up breadcrumbs is by using AI:Ask AI to add the breadcrumb. Make sure to specify: Specific styling requirementsSettings you would like appliedThe AI will then create your styled breadcrumb:Continue refining your breadcrumbs by asking AI for specific modifications: \"Make the breadcrumbs use the dot style\"\"Change the active item color to match my primary color\"\"Add home icon to the first breadcrumb item\"\"Make the breadcrumb collapses on mobile\"Manual Setup ​Add the Breadcrumb element to your page from the Add panelChoose between manual or automatic mode: Manual: Define each breadcrumb item yourselfAuto: Generate breadcrumbs automatically based on the URL pathCustomize the appearance through the properties panelConfigure navigation links for each item (in manual mode)Modes ​The Breadcrumb element offers two operating modes:Manual Mode ​In this mode, you define each breadcrumb item explicitly:Set the Mode property to ManualAdd breadcrumb items using the Add buttonFor each item, specify: Label: The text to displayLink: Where the item should navigate to when clickedIcon (optional): An icon to display before the item labelAuto Mode ​WARNINGIf you are unfamiliar with URL paths and/or have not worked with them in WeWeb before, it is highly recommended to read our dedicated documentation on URL paths to get familiar with them before experimenting with the breadcrumb element.In this mode, breadcrumbs are automatically generated based on the URL path:Set the Mode property to AutoThe breadcrumb will parse the current URL path and create breadcrumb items for each segmentIt will automatically try to match path segments to pages in your siteThe auto mode is convenient for sites with a clear hierarchical structure reflected in the URL paths.In the example below, the page is called 'Favorites', its URL path is favorites, and we have the Mode of the breadcrumb set to Auto:Then, when we navigate to this page from a different page, the breadcrumb auto-populates and includes Favorites due to its path being in the URL:TIPThe Home link will always exist in the breadcrumb when using the Auto mode. If you do not wish to include this link, then you must use the Manual mode and configure the items in the breadcrumb.Using Nested Paths ​To create pages with nested paths, you can customise the URL path of your pages to have the needed paths. You can edit the URL of your page from the settings of the page:For example, if you had a page called Properties, and when clicking on a property, you wanted to direct the user to the respective Property page with the breadcrumb showing Home > Properties > {{Name Of Property}}, then you would do the following:Have a page with the path propertiesHave a page with the base path properties and a dynamic path added. This dynamic path would be populated with whatever is the identifier of the specific property we will show.Because we have properties at the start of the path, the breadcrumb will automatically detect the distinct paths and show them accordinglyNow, we can create a workflow on our property card to navigate to the Properties page with the appropriate path of the property:The breadcrumb on the page would then appear correctly and link to the appropriate pages:DANGERFor the breadcrumb element to automatically create links to the correct page, the paths used when creating nested paths must be identical to that of the page you wish for it to link to.In the example above, the URL set for the Property page was properties/{{property_identifier|}}. The breadcrumb is able to automatically link to the Properties page because the URL path of the Properties page is properties. In this example, if there was no page in our project with the path properties, the breadcrumb would have displayed Home > Properties > {{Name Of Property}}, but the Properties text would have had no link added.WARNINGWhen working with pages that have dynamic paths, the paths may not always appear correctly in the editor, however, they will operate as expected in the published project. To learn more about working with dynamic paths, please refer to our dedicated documentation.:Display Styles ​The Breadcrumb element offers four distinct visual styles:Standard ​The default style with simple text links and separators:Pills ​Each breadcrumb item appears in a rounded pill shape:Arrows ​Items are connected with arrow shapes, creating a directional flow:Underline ​Text links with underlines for a classic navigation appearance:Separator Options ​When using styles other than Arrows, you can choose from various separator types:Slash (/): Traditional breadcrumb separatorArrow (›): Directional indicatorChevron (>): Alternative directional indicatorDot (•): Subtle divider between itemsPipe (|): Vertical separatorDash (-): Simple horizontal dividerCustom: Define your own custom separator text or HTML/SVGResponsive Behavior ​For improved display on smaller screens, you can enable breadcrumb collapsing:Toggle on the Collapse the breadcrumb propertyWhen enabled, only the first and last items will be shown, with an ellipsis (...) in betweenThis maintains context while saving space on mobile devicesBinding to Dynamic Data ​When working with dynamic data, you can bind the breadcrumb items to a collection:Set the Mode property to ManualBind the Breadcrumb Items property to your collection or variableUse the property path settings to map your data: Label Property: Specify which field contains the display textURL Property: Specify which field contains the link objectIcon Property: Specify which field contains the icon nameIf you wanted your breadcrumb to be Home > Properties > Property Detail, like so:Then you would bind a list of data with the following structure:javascript[ { \"label\": \"Home\", \"link\": { type:'internal', pageId:'5ae1841b-d6cd-48fc-9d2c-a98dca906f26', //Home page UID sectionId: null, targetBlank: false }, \"icon\": \"lucide/house\" }, { \"label\": \"Properties\", \"link\": { type:'internal', pageId:'03r0a4e7-9154-4cee-82b6-ffd512fccfbf', //Properties page UID sectionId: null, targetBlank: false }, \"icon\": null }, { \"label\": \"Property Detail\", \"link\": { type:'internal', pageId:'b9l6110b-d29a-423d-a179-ddaf2e0c5d7d', //Property Detail page UID sectionId: null, targetBlank: false }, \"icon\": null } ]Best Practices ​Do: ​Use breadcrumbs for sites with a clear hierarchical structureKeep breadcrumb labels concise (1-2 words is ideal)Place breadcrumbs near the top of the page below the main navigationMake sure the current page is visually distinct (but not clickable)Use icons sparingly to avoid cluttering the breadcrumb trailDon't: ​Use breadcrumbs as the primary navigation methodInclude too many levels in a single breadcrumb trailUse inconsistent separators across your siteHide important navigation options in breadcrumbsExample Use Cases ​E-commerce: Category > Subcategory > Product navigationDocumentation: Section > Topic > Article hierarchyPortfolio: Work > Project > Case Study structureContent Management: Section > Category > Article organizationUser Accounts: Dashboard > Settings > Profile navigationForking ​While the breadcrumb element offers extensive built-in customization options, there may be cases where you need functionality beyond what's natively available. In these situations, you can fork the element and modify it to meet your specific requirements.If you are unsure how to fork an element, you can learn more in the dedicated documentation.Forking Example: Custom Link Hovor Color ​One reason to fork the breadcrumb would be to create styling properties not available in the standard element. For example, you might want to be able to change the styling of the pagination.To do so, you could fork the breadcrumb, then edit with AI and pass in the following prompt:I want to edit this forked breadcrumb so that I can change the color of the links on hovorThe AI will then add new styling properties to control the hovor color of the text links:Properties Reference ​Settings ​General ​PropertyOptionsDescriptionModeManual, AutoControls how breadcrumbs are generatedSeparator TypeSlash, Arrow, Chevron, Dot, Pipe, Dash, CustomType of separator between items (not used with Arrows style)Custom SeparatorTextCustom separator text or HTML when using the Custom separator typeCollapse the breadcrumbBooleanWhether to collapse the breadcrumbs on small screensBreadcrumb ItemsArrayItems to display when using Manual mode↳ Item LabelTextDisplay text for each breadcrumb item↳ Item LinkLinkNavigation target when item is clicked↳ Item IconIconOptional icon to display before the item labelStyling ​Colors ​Customize the colors of all breadcrumb elements:PropertyDescriptionLink ColorColor of regular breadcrumb linksActive Item ColorColor of the current/active breadcrumb itemSeparator ColorColor of separators between itemsIcon ColorColor of icons in regular breadcrumb itemsActive Icon ColorColor of icons in the current/active itemPill Background ColorBackground of pill-style items (Pills style only)Active Pill Background ColorBackground of active pill-style item (Pills style only)Arrow ColorColor of arrow shapes (Arrows style only)Typography ​Control the text appearance:PropertyDescriptionFont SizeSize of breadcrumb textActive Item Font WeightFont weight for the current/active itemHover Text DecorationText decoration applied on hoverSpacing & Layout ​Fine-tune the spacing between each item:PropertyDescriptionItem SpacingGap between breadcrumb itemsSeparators & Borders ​Adjust the spacing between the text and the separator, and the size of the separator:PropertyDescriptionSeparator SpacingMargin around separatorsSeparator SizeSize of separator characters or icons"
  },
  {
    "h1": "Button​",
    "url": "https://docs.weweb.io/elements/button.html",
    "content": "Button ​Add a button to your web app—it's perfect for kicking off actions or submitting forms!Configuring the Button ​Type: Choose what kind of button you want: None: No specific action assigned.Button: Standard button for general actions.Submit Button: Used for submitting forms.Disabled: Toggle this to disable the button if needed. When disabled, onClick is no longer triggered. Therefore all workflows relying on onClick will not be triggered. Also, form submissions will not be triggered.Left Icon: Want an icon on the left? Toggle this on and pick your favorite icon.Right Icon: Prefer an icon on the right? Toggle this on and select the icon you like.For triggering actions, the best approach is to use workflows with the on click trigger.If you're looking to save or update forms, it's smarter to trigger workflows on the form container. By using a Submit Button, the form container will automatically recognize it as a submit action. This way, you'll have access to all the form's properties, and your logic will be neatly organized."
  },
  {
    "h1": "Calendar​",
    "url": "https://docs.weweb.io/elements/calendar.html",
    "content": "Calendar ​WARNINGThis version of the calendar element has now been deprecated. To view documentation for the current calendar element, please refer here.Add calendar ​The Calendar element allows you to display and style user calendars and events. You will find it in the Add> Elements menu: Style the calendar ​In the styling panel of the element, you will find you can:style the event colors,style the view by day, week, month, or yearhide or display weekendshide other specific daysstart the week on Sunday or Mondayadd a \"Today\" button so users can quickly navigate back to the present daydecide how you want to increment time (e.g. 30 minute or 1 hour blocks), etc.update the current time every minute so that the red line in the calendar always displays the current day and timeDisplay events ​In the settings panel of the element, you will be able to:choose the language of the calendar,make the language dynamic based on the user's browser languageadd calendars (e.g. for different users),add and style event categories,add events to the calendar,link those events to a category or calendarYou can add events, calendars, and categories manually or bind them to a collection.Custom languages ​When using the WeWeb calendar element, you can choose to display the calendar in multiple languages depending on the user's browser's locale.In order to do this, you can bind the Language option to:a locale code (usually 2 letter unless a distinction is needed). For example fr for French or pt-br for Portuguese Brazilian, ora custom object as described in the Vue Cal documentation which is the library we used to develop the Calendar element{ \"weekDays\": [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"], \"months\": [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"], \"years\": \"Years\", \"year\": \"Year\", \"month\": \"Month\", \"week\": \"Week\", \"day\": \"Day\", \"today\": \"Today\", \"noEvent\": \"No Event\", \"allDay\": \"All day\", \"deleteEvent\": \"Delete\", \"createEvent\": \"Create an event\", \"dateFormat\": \"dddd D MMMM YYYY\" }"
  },
  {
    "h1": "Sans titre",
    "url": "https://docs.weweb.io/elements/checkbox.html",
    "content": "The checkbox element is a popular element to allow users to:select / unselect an option,toggle an option on or off.By default, it comes as a square checkbox with a light background color, a blue checkmark icon, and borders when the input is checked:How it works ​When you drag-and-drop a checkbox on a WeWeb page, you will notice that there is one Checkbox component that contains:a flexbox, anda checkbox input.It's important to understand what these 3 items do and how they work together:the flexbox,the input, andthe component as a whole.Checkbox flexbox ​The flexbox is helpful if you need to display a information next to the input for example.In the Settings tab of the component, you can turn the Embedded container setting On or Off and decide where you want to display it:WARNINGTurning the Embedded container to Off deletes the container completely.If you turn the Embedded container to Off and turn it back on to On, you will not be able to retrieve what you had in the container before changing the setting to Off.You will need to start from scratch.Checkbox input ​The checkbox input is the element on which the user will click to toggle the option on or off.By default, the checkbox input comes with two states (Default and checked):When the user clicks on the checkbox input, it will change the state of the input.You can style the checkbox input in default or checked state (but more on that later).Checkbox component ​The checkbox component contains both the checkbox input and the flexbox container if Embedded container is switched On.It comes with an internal variable:when the value is false, the checkbox input will be displayed in its Default statewhen the value is true, the checkbox input will be displayed in its checked stateIn Settings of the checkbox component, you can:set or bind an initial value (which must be true or false),decide if the checkbox input is required,decide if the checkbox input is read-only.In the example below, you can see that we set the initial value to true by switching the Init value to On:TIPTo test that your checkbox is behaving as expected, you will need to switch to Preview mode.In the example below, the checkbox appears unchecked on the page despite:the Init value being set to On, andthe component variable being true as a resultIt's only when we move away from the Editing view that we can see the checkbox in action:Style the checkbox ​To style the checkbox itself, you will need to go on the checkbox element that's inside the checkbox component.Once you've made sure you are on the checkbox input itself and not the parent element, you can style the checkbox as you would any other element:Different state, different style ​In the example above, you can see us styling the checkbox when in its Default state.You can have a different style when the checkbox is in the checked state:"
  },
  {
    "h1": "Code Input​",
    "url": "https://docs.weweb.io/elements/code.html",
    "content": "Code Input ​Easily capture input codes, like OTPs, in your web appConfiguring the Code Input ​The code input is made up of two main parts:A wrapper that holds the form input for capturing codes.The form input itself.With the wrapper, you can decide how many code inputs you want to include, by using the Number of code property.As for the form input, it comes with all the cool features you find in WeWeb inputs.For instance, if you're using a number input, you'll have access to the same settings as the input element, with possible options such as:Minimum number: Set the lowest value allowed.Maximum number: Define the highest value permitted.Step value: Specify the increment between numbers.Option to hide arrows: Choose whether to display the increment/decrement arrows."
  },
  {
    "h1": "Color Picker​",
    "url": "https://docs.weweb.io/elements/color-picker.html",
    "content": "Color Picker ​Easily integrate a color picker into your web appConfiguring the Icon ​Initial Value: Set the starting color for your color picker. This is the color that will be pre-selected when the user first interacts with the element."
  },
  {
    "h1": "Columns​",
    "url": "https://docs.weweb.io/elements/columns.html",
    "content": "Columns ​The Columns layout is your go-to for quickly setting up a grid with columns, rows, or even a mosaic pattern. It's perfect for when you want a neat layout without the hassle of manually configuring flexboxes.Configuring the Columns ​You can configure the columns using the following properties:Items: Similar to other elements in WeWeb, you can bind the columns to a repeating element, allowing them to replicate according to the number of elements.Display Type: Columns: Arrange elements in a columnar format. Various presets are available, offering different widths and layouts to best suit your needs.Rows: Organize elements in a row format.Mosaic: Arrange elements in a mixed format, with presets that combine rows and columns for diverse layouts."
  },
  {
    "h1": "Container​",
    "url": "https://docs.weweb.io/elements/container.html",
    "content": "Container ​A Container is a versatile element used to group and organize other elements within a layout.Adding a container to a page ​To add a Container, drag and drop it onto the editor. In WeWeb, a container defaults to a flexbox layout but can be configured as a grid too.Adding elements to a container ​Drag and drop elements inside Container to add them.Sizing a container ​Like other elements in WeWeb, the sizing of a Container can be adjusted from the sizing panel.By default, a Container's width is set to 100%, its height is set to auto, and its max-width is set to 940px. This means it will take the full width available up to 940px, and the height will adjust to fit its child content.Container sizing is managed through the sizing panel. You can adjust the sizing using the following properties:width: Sets the width of the Container. By default, it takes the full width available.height: Sets the height of the Container. By default, it adjusts to the height of its child content.max-width: Defines the maximum width the Container can expand to, preventing it from growing beyond this value.min-width: Defines the minimum width the Container must maintain, ensuring it doesn't shrink below this value.max-height: Sets the maximum height the Container can reach, limiting its expansion vertically.min-height: Sets the minimum height the Container must maintain, ensuring it doesn't shrink below this value.Spacing in a conatiner ​Padding and margin are CSS properties that can be applied to a div to control spacing.Padding: This property adds space inside the div, between the content and the border. It can be set for all sides or individually for top, right, bottom, and left.Margin: This property adds space outside the div, between the border and surrounding elements. Like padding, it can be set for all sides or individually for top, right, bottom, and left.Styling a container ​The following properties can be used to enhance the visual appearance of a container:Borders: This property allows you to define the thickness, style, and color of the border surrounding the container. It can be applied to all sides or individually to the top, right, bottom, and left.Outline: Similar to borders, outlines are drawn outside the border edge of the container. They do not take up space or affect the layout, and can be used to highlight or emphasize the container.Radius: This property is used to round the corners of the container. You can specify a uniform radius for all corners or set different values for each corner to achieve various shapes.Shadows: This property adds a shadow effect to the container, creating a sense of depth. You can customize the shadow's color, size, blur, and position to achieve the desired effect.You can set a background color to a container, add an image or video"
  },
  {
    "h1": "Content Slider​",
    "url": "https://docs.weweb.io/elements/content-slider.html",
    "content": "Content Slider ​Incorporate a horizontal slideshow into your web application.Configuring the slider ​The Content Slider utilizes a flexbox layout for each slide, allowing you to incorporate multiple elements within each slide's flexbox.To configure the slider, follow these steps:Slides: Add slides manually by clicking the + symbol in the editor. Alternatively, bind the slider to a list, ensuring that the fields within the flexbox align with the values in the repeating fields.Slides per View: Specify the number of slides visible at once.Space Between: Define the spacing between slides in pixels.Effect: Choose from various transition effects, including: Slide: A basic horizontal sliding effect.Fade: A smooth fading transition between slides.Coverflow: A 3D effect where slides appear to be stacked.Flip: A 3D flip effect for transitioning slides.Cards: A card-stacking effect for a unique transition.Transition Duration: Set the duration of transitions in milliseconds.Navigation: Enable or disable arrow navigation.Pagination: Toggle the display of page indicators.Loop: Enable or disable continuous looping of slides.Autoplay: Activate autoplay and configure the following properties: Timing: Set the autoplay interval in seconds.Linear Transition: Toggle linear transition for autoplay.Mousewheel Control: Enable or disable control via mousewheel."
  },
  {
    "h1": "Data Grid​",
    "url": "https://docs.weweb.io/elements/data-grid.html",
    "content": "Data Grid ​Add the Data Grid to a Project ​When you drag-and-drop the Data Grid Element on the Canvas, you will be asked if you want to import Variables: You don't have to but, if you do, the Element will come with a ready-made Variable that contains fake data: We did this to help you understand what kind of data the Element expects – in this case, a list of items – and how it works.But let's have a look at how you can display your own data in the Data Grid.Display Data in the Data Grid Element ​In the example below, we replaced the fake data with one of our Collections, a list of rental cars with their current location and mileage: To ensure the Data Grid can understand which are unique, we mapped the \"Unique id\" property to the Airtable id in our Collection.Then, we mapped each column in the Data Grid to a field in our database: 🚨 Warning 🚨Inline editing is only available for field types that are built in the data grid. You can display other Elements using the Custom type but users won't be able to update the values of these fields.Let Users Edit or Delete a Record ​If you want to edit or delete a record in your database, you'll need to enable the Inline editing option in the Data Grid: This will display the column with the little pencil (to edit) and bin (to delete) records.When the user clicks on one of these icons, it will trigger the corresponding Workflow: Note that the two triggers are:On update row, andOn delete row.If you delete them by mistake, you can easily recreate them with these triggers 🙂To update (or delete) a record, the first thing you'll need to do is tell your database what is the unique id of the item you selected: Then, you can update the fields you want in your database.In the example below, we are updating our record with the value we have for the mileage field in our Data Grid: TIPWith the \"Allow selection\" option enabled, you can let users select and delete multiple items at the same time. You'll find a step-by-step walkthrough on how to set this up at the end of the video above (hint: it requires a workflow with a for loop on the \"Selected Rows\" variable)."
  },
  {
    "h1": "Date pickers​",
    "url": "https://docs.weweb.io/elements/date-pickers.html",
    "content": "Date pickers ​In WeWeb, you can access 3 date picker elements in the Add panel:the date and time picker,the date range picker, andthe time picker.Under the hood, these are in fact the same element with different Selection Mode and Time Mode presets but more on that later...For now, let's focus on how it works out of the box.Component variable ​The first thing to understand is that, when you drag-and-drop a date or time picker element on the page, a new component variable will be created in the Navigator:If you change the Time > Mode to Date instead of the default Datetime, the variable will only include the date with no time information:If you change the Selection > Mode to Range, the component variable will include a start and end date:If you change the Selection Mode to Multi dates, the component variable will include all the dates that were selected:WARNINGMake sure to send the date in a format your backend understands. For example, if your backend expects a list of dates, send the selected date(s) in an array, even if the user only selected one date.Styling the date picker ​Let's have a look at the different no-code styling options that come with the date picker elements.Lang ​This setting will change the default language of the calendar.If you select Page lang, the language of the calendar will take the current language of the page.In the example below, we are working with three languages and we can see the language of the calendar changes based on the page language:Format ​The Format setting allows you to change how the date is displayed on the page.The value of the component variable will remain unchanged but the date will be displayed to the user as you choose.In the example below, we chose a format to display the full month name in letters. Instead of displaying Jan 5,2025, we display January 5, 2025:Display ​The Display options allow to change a little bit how the date picker is displayed.In the example below, we decided to keep the Menu position centered and display a Left sidebar in which we added a Rich text element to display a text:Style and Colors ​The Style and Color properties are fairly intuitive.Here, we made the cells of the calendar bigger by changing the Cell size from the default 35px to 50px and changed the background color from the standard blue to a nice green:Other CSS properties ​The other CSS properties available in no-code for the date pickers are standard (e.g. Sizing, Spacing, Display, etc.)You can find more about each property in the article dedicated to standard CSS properties.TIPIf you're noticing you're having trouble selecting the date picker element, consider selecting it from the HTML tree in the Navigator or on the page by selecting the date picker icon in the top left of the element: Let's now dig into the customization options available with the date picker elements.Single, multiple, or range date picker ​As mentioned above, the date and time picker elements in WeWeb are all the same under the hood with different default settings. The first setting that changes from one type of picker to the other is its Mode.In the specific settings of the date pickers, you can switch between one of three modes:Single: users will be able to select a single date. The variable value will be a date string.Range: users will be able to select a range of dates. The variable value will be an object with a start and end dateMulti dates: users will be able to select multiple dates. The variable value will be an array with a list of date strings.Single mode ​The one thing you might want to set in Single mode is the initial value (Init value) of the date picker. In the example below, we used a no-code formula to select the current date by default:Range mode ​The range mode works similarly except it expects a start and end date:There are three Range mode options:Free: the user can select whatever date ranges they wantAuto: the user selects the start date and you define how many days after the range ends with the Auto range day inputMin Max: the user can select the range they like provided its above and below the numbers you defineIn the example below, we want users to book more than 2 but no more than 7 nights:Multi dates mode ​The Multi dates selection mode expects an array of dates as an initial value.In the example below, we enabled the option to select multiple dates (Multi dates), selected 2 dates by default (Init value), and limited the number of dates a user can select at one time (Multi date limits). As a result, we can see two dates are highlighted by default and the component variable is an array of strings:Behavior settings ​Auto apply: disable if you want the user to confirm the selection before closing the calendarClose on auto apply: disable if you want the calendar to stay open even after user has selected the dateClose on page scroll: enable if you want the calendar to close automatically when the user scrolls out of viewTime settings ​The Time settings define the type of range will be able to select. One way to look at it is through the value that is updated in the component variable of the date picker element:in Datetime mode, the variable returns a date with year, month, date, and time. For example, \"2025-01-06T23:00:00.000Z\"in Date mode, the variable returns a date without the time. For example, \"2025-01-10\"in Time mode, the variable returns an hour, minute, and seconds. For example, \"19:28:00\"in Month mode, the variable returns a year and month. For example, \"2025-01\"in Year mode, the variable returns a year. For example, \"2025\"TIPIn code, dates are strings. That's why the date values are displayed in between quotation marks.Dates settings ​Start date: the date on which the date picker will openMin date: users can't select a date before thatMax date: users can't select a date after thatAdvanced date navigation settings ​Prevent min/max navigation: users can't navigate before the Min date and after the Max dateAllowed dates: users will only be able to select among these dates. Expects a list of dates. For example, [\"2023-03-25\",\"2023-04-01\",\"2023-04-12\"]Disabled dates: users will not be able to select these dates. Expects a list of dates. For example, [\"2023-03-25\",\"2023-04-01\",\"2023-04-12\"]Disabled week days: users will not be able to select dates that fall on specific week days. Expects an array of numbers where 0 stands for Sunday, 1 for Monday, etc. For example, [1, 4] to disable Mondays and Thursdays.If you don't need to decide which days to disable dynamically, you could use the Add button instead of binding to hard-code the disabled week days:WARNINGThe Allowed dates, Disabled dates, and Disabled week days settings expect a list of dates. For example: [\"2024-06-04\", \"2024-06-20\"]If your intention is for only one date to be available, you will still need to “wrap it” inside an array. For example: [\"2024-06-04\"]Weeks / Months settings ​Week start: define which day the weeks start onWeek numbers: choose if you want to display week numbersHide offset dates: hide the last days from the previous and first days from the next monthDisable month/year select: hide the calendar navigationFlow ​The Flow is the order in which users will be invited to pick a date and/or time.By default, when the user clicks on a date picker element, they see a monthly calendar which they can navigate in. Depending on your use case, this can be a bit cumbersome.To change this UX, you can enable the Flow setting and fully control how the user will interact with the date picker.In the example below, we configured the date picker flow so the user would be invited to choose a year and month before selecting the correct day in the calendar:TIPThis type of UX can be helpful when there's a good chance the date that is picked is a few years back. When you ask for someone's birthday for example, asking them to navigate year after year after year can be cumbersome.PS: This tip is not at all influenced by the age of the person typing this ^^"
  },
  {
    "h1": "Dialog (Modal, Alert, Sheet)​",
    "url": "https://docs.weweb.io/elements/dialog.html",
    "content": "Dialog (Modal, Alert, Sheet) ​A dialog or popup is an overlay element that appears above your page content to focus user attention. It creates a dedicated interaction space for forms, confirmations, or additional content.The Dialog element can be configured into three UI patterns:Modal window - centered overlay for forms and detailed contentAlert dialog - focused overlay for confirmations and notificationsSheet element - full-width/height panel that slides in from any screen edgeHere is a video of how it works:Getting Started ​Add a Dialog element to your pagePreview your Dialog by clicking 'Toggle dialog' in the side panelCustomize the appearance and behavior through Dialog propertiesOpening & closing dialogs from anywhere ​By default, the Dialog element will open when you click on it, but you can also choose from where and when you want this behavior to happen. To do so, you need to use component actions.Disable the Trigger property of your Dialog:Create a custom trigger:Select any element you want to use as a triggerAdd a workflow to this element (typically on click)Use Execute component action in the workflowSelect your Dialog and choose Open, Close, or ToggleWhen you click the element you selected, it will open the Dialog:TIPDialog control uses component actions instead of boolean variables. You can trigger your Dialog from any workflow, not just clicks. Examples include:On page loadOn mouse enterOn double clickAfter form submissionLearn more about workflow triggers in our Triggers documentation.Properties ​Type & Position ​PropertyOptionsDescriptionTypeModal, Sheet, NoneModal: Overlay window with flexible positioning. Sheet: Full-width/height panel on screen edges. None: Unstyled base for custom designs.Sheet PositionLeft, Right, Bottom, TopWhen using Sheet type, choose which screen edge it appears fromModal PositionLeft, Center, Right, CustomPosition your Modal horizontally on screenModal AlignmentTop, Center, BottomAlign your Modal vertically on screenCustom Position (X,Y)Custom valuesSet exact coordinates when using Custom positionAnimation ​PropertyOptionsDescriptionAnimationNone, Fade, Zoom in, Slide inChoose how your dialog appearsDirectionLeft, Right, Top, BottomChoose slide direction when using Slide in animationDurationCustom valueSet how long the animation takesEasingLinear, Ease in, Ease out, Ease in outControl how smooth the animation feelsInteraction Settings ​PropertyOptionsDescriptionPrevent scrollingOn/OffControl if users can scroll the page behind an open dialogEscape key to closeOn/OffAllow closing the dialog with Escape keyTriggerOn/OffShow/hide the default opening triggerTrigger click closesOn/OffControl if clicking the trigger closes an open dialogOverlayOn/OffAdd a background overlay behind the dialogOverlay click closesOn/OffClose the dialog when clicking the overlayClick outside closesOn/OffClose the dialog when clicking outside itModalOn/OffAllow/prevent interactions with content behind the dialogTIPWe recommend experimenting with these properties to see their visual effects in action.TIPYou can place the Dialog anywhere. To ensure the overlay covers the whole screen, enable the Z axis property for the Dialog.Retrieving data from form inputs ​When you place a Dialog containing form inputs inside a repeating group, the inputs will lose their values due to how WeWeb handles state.In this example, we placed a Dialog with a form input inside a repeating group and entered the value \"Hello\":When accessing the Variables tab, no value is found:To fix this, you can either:Place the Dialog outside the repeating group (recommended)Or store the input values manually:Add an On change workflow to your inputCapture the input value from the Events tabSave it to a variable"
  },
  {
    "h1": "Div​",
    "url": "https://docs.weweb.io/elements/div.html",
    "content": "Div ​A Div is a simple wrapper used to contain other elements.Adding a Div to a page ​To add a Div, drag and drop it onto the editor. In WeWeb, a div defaults to a flexbox layout but can be configured as a grid.Adding elements to a Div ​Drag and drop elements inside Divs to add them.Sizing a div ​Like other elements in WeWeb, the sizing can be done from the sizing panel.The default height and width are set to automatic. For a div, this means it will take the full width available to it, and the height of it's children content.Div sizing is managed through the sizing panel. You can adjust the sizing using the following properties:Property NameDescriptionwidthSets the width of the Div. By default, it takes the full width available.heightSets the height of the Div. By default, it adjusts to the height of its child content.max-widthDefines the maximum width the Div can expand to, preventing it from growing beyond this value.min-widthDefines the minimum width the Div must maintain, ensuring it doesn't shrink below this value.max-heightSets the maximum height the Div can reach, limiting its expansion vertically.min-heightSets the minimum height the Div must maintain, ensuring it doesn't shrink below this value.Spacing in a div ​Padding and margin are CSS properties that can be applied to a div to control spacing.Property NameDescriptionPaddingThis property adds space inside the div, between the content and the border. It can be set for all sides or individually for top, right, bottom, and left.MarginThis property adds space outside the div, between the border and surrounding elements. Like padding, it can be set for all sides or individually for top, right, bottom, and left.Styling a div ​The following properties can be used to enhance the visual appearance of a div:Property NameDescriptionBordersThis property allows you to define the thickness, style, and color of the border surrounding the div. It can be applied to all sides or individually to the top, right, bottom, and left.OutlineSimilar to borders, outlines are drawn outside the border edge of the div. They do not take up space or affect the layout, and can be used to highlight or emphasize the div.RadiusThis property is used to round the corners of the div. You can specify a uniform radius for all corners or set different values for each corner to achieve various shapes.ShadowsThis property adds a shadow effect to the div, creating a sense of depth. You can customize the shadow's color, size, blur, and position to achieve the desired effect.You can set a background color to a div, add an image or video"
  },
  {
    "h1": "Donut Progress Bar​",
    "url": "https://docs.weweb.io/elements/donut-progress-bar.html",
    "content": "Donut Progress Bar ​Incorporate a donut progress bar into your web application to visually represent the completion status of a task or process in a circular format.Customize the donut progress bar using the following properties:Visual Settings:Style: Select from several display presets: Center: The progress is displayed in the center of the donut.Out: The progress is shown outside the donut's circumference.Out over: The progress extends over the outer edge of the donut.In: The progress is displayed inside the donut's circumference.In over: The progress extends over the inner edge of the donut.Fill: Thickness: Adjust the thickness of the filled portion.Color: Choose the color for the filled section.Empty: Thickness: Set the thickness of the empty portion.Color: Define the color for the empty section.Animation: Duration: Specify the animation duration in milliseconds.Delay: Set the delay before the animation starts, in milliseconds.Within the settings tab, you can set the progress value, which is represented as a simple integer.The donut progress bar is especially beneficial when linked to the progress of another process or task, providing users with a clear visual indicator of completion."
  },
  {
    "h1": "Multiple file upload​",
    "url": "https://docs.weweb.io/elements/drag-and-drop-files.html",
    "content": "Multiple file upload ​You can allow users to upload multiple files to your WeWeb app by using the Drag and Drop files element:By default, it comes with a workflow that:handles multiple file uploads,via the WeWeb CDN.If you want to use this element to upload a single file and/or upload the file(s) directly to an external backend without going through WeWeb's CDN, you will need to customize its default settings.Upload to WeWeb's CDN ​By default, the Drag and Drop files element comes with a no-code workflow that allows you to:upload files to WeWeb's CDN,update your backend with the URLs of the files uploaded to WeWeb's CDN.All you need to do is drag-and-drop the element on the page and it will work out of the box.If you wish to upload files directly to your backend (instead of storing URLs), read on.Upload to external backend ​To upload multiple files directly to an external backend using the Drag and Drop files element, you will need to change the workflow that comes with the element by default.The updated workflow will look something like this:TIPIn the step-by-step guide below, we use Xano as an example but you can apply similar logic no matter what backend you are using as long as it accepts the Data URL or Base64 format.Reset component var ​We take the variable that comes with the “Drag and drop files” element, and make sure it’s empty at the start of the workflow:Loop through the files ​We loop through the input variable of the Drag and drop file component, i.e. the list of files dropped by the user:Encode each file ​We encode the file related to the current item in the loop:TIPThe item might be empty if you didn’t test the workflow before. We recommend uploading a couple of files in preview mode and testing the workflow before creating this step so it’s easier to visualize things when doing your bindings.Create file in Xano library ​We take the result from the encoding action to add the file in the Xano library:TIPIt’s helpful to test each action along the way because it makes it easier to bind to the result of a previous action.List of encoded files ​We update the list of encoded files with the data of the result from the previous action:Add record in Xano table ​Finally, outside the loop, we make an API call to create a record in our Xano table:WARNINGMake sure the column where you are sending the attachments is a list in Xano:If you try sending multiple attachments to a single structure column, Xano will return an error."
  },
  {
    "h1": "Dropdown​",
    "url": "https://docs.weweb.io/elements/dropdown.html",
    "content": "Dropdown ​A dropdown allows you to select an option from a list, making it ideal for conserving space and presenting multiple choices in a compact form.Components of the Dropdown ​A dropdown consists of two main parts:Trigger: This is the interactive part that, when clicked, toggles the visibility of the dropdown's contents. By default, it includes a button, but feel free to add multiple elements to customize your dropdown trigger.Dropdown Content: This is where the dropdown's content resides. By default, it starts with a list, but you can add various elements to suit your needs.Configuring the Dropdown ​The Dropdown comes with several handy properties to tailor it to your needs:Property NameDescriptionTriggerThis is what activates the dropdown. By default, it's set to click, but you can switch it up to hover or right click if you prefer.PositionThis determines where the dropdown content appears in relation to the trigger. You can choose from Top, Right, Bottom, or Left, with Bottom being the default.AlignThis controls how the content aligns itself—vertically if it's on the right or left, or horizontally if it's on the top or bottom.Offset (x)Adjusts the horizontal spacing from the trigger element. You can use both positive and negative values here.Offset (y)Adjusts the vertical spacing from the trigger element. Again, both positive and negative values are welcome.Dropdown z-indexThis property allows you to set the z-index for the dropdown, which determines its stacking order relative to other elements. A higher z-index value places the dropdown above elements with lower z-index values, making it useful for managing overlapping content.DisabledA simple toggle to enable or disable the dropdown.AnimatedAnother toggle to turn on or off the animation when the dropdown opens."
  },
  {
    "h1": "File Upload​",
    "url": "https://docs.weweb.io/elements/file-upload.html",
    "content": "File Upload ​The File Upload element provides an intuitive way for users to upload files in your application. It supports both single and multiple file uploads with interactive drag-and-drop functionality, file validation, and extensive customization options to match your design system.Features ​Single or Multiple File Uploads: Easily configure for accepting one file or multiple filesDrag-and-Drop Support: Intuitive interface with animated visual feedbackFile Validation: Configure size limits and file type restrictionsVisual Customization: Extensive styling options for all component elementsUpload Progress: Built-in visual progress indicatorAccessibility: Fully accessible with ARIA attributes and keyboard navigationFile Preview: Displays file information with size and upload progressBase64 and Binary Formats: Option to expose file contents in Base64 or binary formatsResponsive Design: Adapts to container size and different screen dimensionsGetting Started ​Using AI ​The quickest way to set up the file upload is by using AI.Ask AI to add the file upload. Make sure to specify: Specific styling requirementsSettings you would like applied:The AI will then create your styled file upload:Continue refining your file upload by asking AI for specific modifications: \"Make the file upload accept multiple image files\"\"Add a custom label to the file upload\"\"Change the border style to solid with a blue color\"\"Show upload progress with a green progress bar\"Manual Setup ​Add the file upload to your page from the Add panelConfigure basic settings: Set upload type to single or multiple filesConfigure file size limits (maximum and minimum)Set allowed file typesEnable or disable drag and dropCustomize appearance through the style panelAdd workflows to handle file uploads and validation errorsBasic Configuration ​Upload Types ​The file upload supports two primary modes:ModeDescriptionUse CaseSingle FileAccepts only one file at a timeProfile photos, document submissionsMultiple FilesAccepts multiple filesPhoto galleries, batch document processingFile Validation ​Control what files users can upload:File Size Limits: Set maximum file size (default: 10MB)Set minimum file size (default: 0MB)For multiple uploads, configure maximum total size (default: 50MB)File Type Restrictions: Choose from preset file types (Images, Videos, PDF, CSV, etc.)Create custom extensions list (e.g., .docx, .pptx, .txt)Drag and Drop ​Enable intuitive file uploads:Set Allow drag & drop to OnUsers can drag files from their file explorer to the upload areaVisual feedback appears as users drag over the componentHandling Uploads ​When a user attempts to upload a file, the element:Provides visual feedback with drag animationsValidates the file to ensure it meets the configured constraintsOnce uploaded, displays file information (name, size, type)Makes file data available through exposed variablesTriggers workflow events allowing for further manual logicStoring Uploads ​On the backend ​Ultimately, to correctly store uploaded files, you will likely need to save them in your backend.As an example, imagine you had UI where the user's upload files and press a save button when done, like soThe steps to be taken would be the following:Have a workflow created on the save button to send the files and appropriately set any state variables (like loaders).Inside the workflow, loop the files uploaded:And for each file in the loop, send it to the backend for upload:TIPIn the example above, we looped the files because our file upload was set to allow multiple files. If your file upload is set to only allow single files, then you would not need to perform any looping.On the frontend ​You have the ability to store uploaded files into the WeWeb CDN, however, this is recommended to only be used for initial testing/MVPs.To do so, you simply need the following:Have a workflow created on the file upload element with the On change trigger.Inside the workflow, have an Upload file action linking to the file upload element:The files will then be stored in the User Storage tab of the Auth menu:Advanced Options ​Exposing File Content ​For client-side processing, access file contents directly:Base64 Encoding:Toggle Expose as Base64 to include base64-encoded file dataUseful for image previews or browser-based processingBinary Format:Toggle Expose as Binary to include binary file dataUseful for advanced file manipulation like editing media or reading file metadata in detail.Read-Only Mode ​Present files without allowing changes:Set Read only to OnUsers can view uploaded files but cannot add or remove filesUseful for review states or displaying previously uploaded contentRequired Validation ​Ensure users provide necessary files:Set Required to OnFile will be required as part of form submissionExample Use Cases ​User Profile Photo Upload ​Configure a single file upload for profile photos:Set upload type to Single fileSet allowed file types to ImageSet maximum file size to 5MBIn the workflow, use the base64 data for previewSend the file to your server for storageDocument Management System ​Create a multi-file document uploader:Set upload type to Multiple filesSet allowed file types to PDF, Word, Excel or use custom extensionsSet maximum total size to 50MBAdd progress indicators and file management optionsProcess uploads in batchesImage Gallery Upload ​Build an image gallery uploader:Set upload type to Multiple filesSet allowed file types to ImageEnable base64 encoding for image previewsCreate a workflow to display uploaded images in a galleryAdd file name display and size informationBest Practices ​Do: ​Provide clear instructions about file requirementsSet appropriate file size limits based on your application needsUse the error event to provide helpful feedbackDon't: ​Set unnecessarily restrictive file size limitsUse only generic error messagesForget to handle uploaded files on your serverForking ​While the file upload element offers extensive built-in customization options, there may be cases where you need functionality beyond what's natively available. In these situations, you can fork the element and modify it to meet your specific requirements.If you are unsure how to fork an element, you can learn more in the dedicated documentation.Forking Example: Custom File Preview ​One reason to fork the File Upload would be to add custom preview functionality:I want to add image preview thumbnails to this forked file upload componentThe AI will then add image preview capabilities:Properties Reference ​Settings ​PropertyOptions/TypeDescriptionUpload TypeSingle file, Multiple filesDetermines if one or multiple files can be uploadedAllow drag & dropBooleanEnable/disable drag and drop functionalityMax file size (MB)NumberMaximum allowed file sizeMin file size (MB)NumberMinimum allowed file sizeRequiredBooleanMakes the file upload field requiredRead onlyBooleanMakes the component read-onlyAllowed file typesAny, Image, Video, Audio, PDF, CSV, Excel, Word, JSON, CustomPreset file type filtersCustom extensionsTextComma-separated list of allowed file extensionsExpose as Base64BooleanInclude base64-encoded file dataExpose as BinaryBooleanInclude binary file dataStyling ​The File Upload component offers extensive styling options to match your application's design. These settings are organized into different sections in the properties panel.Dropzone ​The Dropzone section controls the appearance of the main drop area where users will drag files:PropertyDescriptionBorder colorSet the color of the dropzone borderBorder styleChoose between Solid, Dashed, Dotted, etc.Border widthAdjust the thickness of the border (in pixels)Border radiusControl the roundness of the dropzone cornersBackground colorSet the background color of the dropzonePaddingAdd space between the dropzone border and its contentsMin heightSet the minimum height of the dropzoneTIPUsing a dashed border with a light background color creates a visual cue that helps users identify the dropzone area.Icon ​The Icon section customizes the upload icon that appears in the dropzone:PropertyDescriptionShow upload iconToggle the visibility of the upload iconUpload iconSelect which icon to display from the libraryIcon colorSet the color of the iconSizeAdjust the size of the icon (in pixels)MarginControl the space around the iconIcon positionChoose where the icon appears (Top, Left, Right, Bottom)Label ​The Label section controls the appearance of the primary text that appears in the dropzone:PropertyDescriptionLabelSet the text displayed in the dropzone (e.g., \"Drop files here\")Font familyChoose the font for the label textFont sizeAdjust the size of the label text (in pixels)Font weightSet the boldness of the textColorChange the color of the label textMarginControl the space around the label textTIPClear instructions in the label text help users understand what to do with the dropzone.Info Messages ​The Info Messages section controls the appearance of informational texts like file type restrictions:PropertyDescriptionExtensions messageCustomize the text that shows allowed file typesExtensions message font familyChoose the font for the extensions messageExtensions message font sizeSet the size of the extensions message textExtensions message font weightControl the boldness of the extensions messageExtensions message colorSet the color of the extensions messageExtensions message marginControl the space around the extensions messageMax file messageCustomize the text that shows maximum file sizeMax file message font familyChoose the font for the max file size messageMax file message font sizeSet the size of the max file size messageMax file message font weightControl the boldness of the max file size messageMax file message colorSet the color of the max file size messageMax file message marginControl the space around the max file size messageFile List ​The File List section controls how the list of uploaded files appears:PropertyDescriptionBackground colorSet the background color of the file list containerBorder colorSet the color of the border around the file listBorder radiusControl the roundness of the file list cornersPaddingAdd space inside the file list containerMarginControl the space around the file list containerShadowAdd a shadow effect to the file list containerProgress bar colorSets color of progress bar shown when using Upload file workflow actionFile Item Hover States ​PropertyDescriptionHover border colorSet the border color when hovering over a file itemHover background colorSet the background color when hovering over a file itemHover shadowAdd a shadow effect when hovering over a file itemFile Name ​PropertyDescriptionFont familyChoose the font for file namesFont sizeSet the size of file name textFont weightControl the boldness of file namesColorSet the color of file name textFile Details ​PropertyDescriptionShow file detailsToggle the visibility of file details (size, type)Font familyChoose the font for file detailsFont sizeSet the size of file details textFont weightControl the boldness of file detailsColorSet the color of file details textRemove Buttons ​The Remove Buttons section controls the appearance of the file removal buttons:PropertyDescriptionSizeSet the size of action buttonsBackground colorSet the background color of action buttonsHover background colorSet the background color when hovering over buttonsIcon colorSet the color of icons within the buttonsBorder colorSet the color of the border around buttonsHover border colorSet the border color when hovering over buttonsRemove button hover colorSet the hover color specifically for the remove buttonBorder radiusControl the roundness of button cornersMarginControl the space around buttonsDrag & Drop Animation ​The Drag & Drop Animation section controls the visual feedback when files are dragged over the dropzone:PropertyDescriptionEnable circle animationToggle the circular animation when dragging filesCircle sizeSet the size of the animation circleCircle colorSet the color of the animation circleCircle opacityControl the transparency of the animation circleAnimation speedAdjust how fast the animation playsTIPA subtle animation provides helpful visual feedback to users when they're dragging files over the dropzone.Event Triggers ​EventDescriptionPayloadOn changeTriggered when files are added or removed{ value: fileArray }On init value changeTriggered when initial value changes{ value: fileArray }On errorTriggered when file validation fails{ code: errorCode, data: errorData }Example Event Payloads ​On change ​javascript{ value: [ { name: \"document.pdf\", size: 1258000, type: \"application/pdf\", extension: \"pdf\", id: \"file-1647889433265-x8f2j9s\" } ] }Use this event to:Save uploaded files to a databaseProcess files for further useUpdate UI based on uploaded contentOn init value change ​javascript{ value: [ { name: \"document.pdf\", size: 1258000, type: \"application/pdf\", extension: \"pdf\", id: \"file-1647889433265-x8f2j9s\" } ] }On error ​javascript{ code: \"MAX_SIZE_EXCEEDED\", data: { message: \"File size (15.5 MB) exceeds the maximum allowed size (10 MB)\", fileName: \"large-file.zip\", fileSize: 16252880, fileType: \"application/zip\", constraint: \"MAX_SIZE\" } }Use this event to:Show custom error messagesGuide users on how to resolve validation issuesLog upload attemptsComponent Actions ​ActionDescriptionParametersClear FilesClears all uploaded filesNoneExposed Variables ​VariableTypeDescriptionvalueArrayList of all files uploadedstatusArrayList of the upload status of all files (will only populate if the files are being uploaded to the frontend via the Upload file workflow action"
  },
  {
    "h1": "Flexbox container​",
    "url": "https://docs.weweb.io/elements/flexbox-container.html",
    "content": "Flexbox container ​The Flexbox Container is extremely powerful to design complex responsive pages that look good on every device.You can find the Flexbox Container in the \"Add\" menu > \"Add elements\"Intro to the Flexbox Container ​The one thing to understand about flexboxes is that, the settings you choose at Flexbox level affect the children elements inside that Flexbox.Ok, what does that mean?Let's say you have a Flexbox that contains :an Image, anda Div Block that contains three Text fields.If you apply the vertical display to the Flexbox, the Image and Div Block will appear underneath each other BUT the three text fields inside the Div Block will still appear side by side by default.Why?Because the children elements of the Flexbox you styled are the image and the Div Block. The three text fields are children elements of the Div Block, not the Flexbox.To learn more about flexboxes, consider reading CSS Tricks' complete guide on flexboxes.Flexbox Properties ​WeWeb's Flexbox Container element contains most of the Flexbox properties, including:display children elements vertically or horizontally,justify,alignment,the option to wrap elements or not, andreverse the order of children elements (often used to reverse the order of text and images on mobile.To practice using flexboxes, consider playing the Flexbox Froggy game. It's fun, helpful, and free 🙂🚨️ WARNING 🚨️ ​At the moment, WeWeb's no-code Flexbox Container element does not include all the property settings that exist in the coding world, like \"order\" or \"flex-grow\" for example. If there are flexbox settings you feel we should prioritize, feel free to reach out in the chat and let us know!"
  },
  {
    "h1": "Form container​",
    "url": "https://docs.weweb.io/elements/form-container.html",
    "content": "Form container ​Forms are the backbone of user interaction in web applications. Form containers in WeWeb provide powerful tools to collect and validate user information. Whether you're building checkout flows, job applications, or product configurators, WeWeb's forms help you create effective user experiences while ensuring data integrity.Add a form container ​To add a form container in WeWeb, go to Add > Basics and search for \"form\":Understanding form variables ​When you add a form container to your page, you'll have access to these variables:isSubmittingThis variable tells you if the form is currently in the process of being submitted. It will be:false when the form is idletrue during the brief moment when a user has clicked submit and the form is processingThis is useful for showing loading states or preventing double submissions.TIPisSubmitting does not change automatically. You must manually set it to true when processing starts and false when processing ends using the Set form state action in your workflow.isSubmittedThis variable indicates whether the form has been submitted at least once. It will be:false when the form hasn't been submitted yettrue after the form has been submitted, regardless of whether the submission was successfulYou can use this to show different content or messages after a user has attempted to submit the form.TIPisSubmitted needs to be manually set. The form won't automatically update this value after submission - you need to set it to true yourself using the Set form state action after a successful submission.isValidThis variable tells you about the current validation state of your form. It will be:null when the form hasn't been interacted with yettrue when all required fields are filled and all validation rules are metfalse when any required field is empty or any validation rule failsThis helps you control submit button states or show validation messages.formDataThis is an object that contains all the current values from your form fields. For example, if you have fields named \"email\" and \"password\", you might see:json{ \"email\": \"user@example.com\", \"password\": \"example1\" }fieldsThis is an object that contains information about each form field, including their validation states:json{ \"email\": { \"value\": \"user@example.com\", \"isValid\": undefined }, \"password\": { \"value\": \"example1\", \"isValid\": undefined } }Form validation ​Form validation is the process of checking if information entered into a form meets certain rules or requirements before it can be submitted.Common types of validation methods: ​Required field: ensures essential fields aren't left blankData format: checks inputs match patterns (emails need @, phone numbers need correct digits)Length: verifies text meets character limits (minimum password length, maximum descriptions)Range: confirms numbers fall within acceptable ranges (age limits, reasonable quantities)Comparison: checks relationships between fields (password confirmation matches, dates are sequential)Regular expression: uses pattern matching for complex formats (postal codes, credit cards)Custom logic: implements business rules (username availability, promotion code validity)Handling validation with variables ​Form validation in WeWeb works on two levels - individual fields and the entire form.Field-level validation ​Each input field in your form has its own isValid property that reflects whether that specific field meets all validation requirements:json{ \"email\": { \"value\": \"user@example.com\", \"isValid\": true // This field passes validation }, \"password\": { \"value\": \"ex\", \"isValid\": false // This field fails validation (too short) } }You can use the field-level isValid property to:Show an error message directly below a specific fieldHighlight invalid fields with a red border or backgroundDisplay a checkmark icon next to correctly filled fieldsEnable/disable specific related fields based on validation statusForm-level validation ​The entire form has a global isValid property:true - all fields pass validationfalse - at least one field fails validationnull - validation hasn't been evaluated yetTIPThe global isValid is directly connected to all field-level validation results. Your form is only considered valid when every individual field's isValid is true.You can use the form-level isValid property to:Enable/disable the submit button until all fields are validShow an overall form error message at the topDisplay a progress indicator showing form completion statusTrigger conditional visibility of subsequent form sectionsValidation timing settings ​The Validation property in the Settings tab controls when validation happens:On input change: both field isValid values and the form's isValid update as you type. This will enable the Validation delay propertyOn form submit: the isValid values only update when the submit button is clickedFor example, with \"On input change,\" a text field requiring at least 10 characters immediately sets its isValid to false if the input is too short, which in turn makes the form's overall isValid false. With \"On form submit,\" validation happens only when the user attempts to submit.This system helps ensure data is correct before submission while giving you control over when users see validation messages.Password validation example ​In this example, we show an error message when a password is too long:Set form validation to \"On input change\" so validation happens while typingAdd an error message text element below the password fieldConfigure the error message's visibility to show only when the password field's isValid is falseSet up the password field's validation rule: \"is password smaller than 6 characters\"This creates immediate feedback where the error message automatically appears when the password is too short and disappears when it's valid, all without requiring the user to submit the form.TIPValidation delay vs input debounceThe Validation delay property creates a waiting period before running form validation checks. Its purpose is to optimize performance and improve user experience by preventing unnecessary validation processing during rapid typing. This ensures validation only runs after the user has likely finished entering their data.This is similar to the Debounce property of the Input element.Debounce serves a similar purpose but for workflows that run on input changes. It creates a pause between when a user interacts with an input and when the associated workflow triggers. This prevents workflows from executing too frequently during typing, which helps:Prevent excessive API calls or database queriesReduce server load for resource-intensive operationsMake your application more responsive by batching changesImprove performance when inputs trigger complex calculationsBoth features prevent your application from becoming sluggish due to too many simultaneous operations, with Validation delay focused on form validation processing and Debounce focused on workflow execution.On Submit Validation Error Trigger ​The On submit validation error trigger activates when a form is submitted but fails validation.While the standard On submit trigger only runs when all validation passes, this specialized trigger provides a way to handle validation failures.This allows you to create custom error handling workflows that display helpful messages, log specific validation issues, or guide users on how to correct their input.Autocomplete ​Form autocomplete: enables browser suggestions for all fields based on previously entered information.Input-level autocomplete: allows field-specific control over suggestions, letting you enable or disable autocomplete for individual fields regardless of the form-level setting.WARNINGThese form controls only handle frontend validation that happens in the user's browser. Always implement backend validation too:Frontend validation improves user experience by providing immediate feedbackBackend validation is essential for security since frontend validation can be bypassedAlways validate submitted data on your server regardless of frontend validationNever trust data that comes from the client side, even if it passed frontend validationFor complete security, implement the same validation rules on both frontend and backend.Submit a form ​To allow users to submit the form, you'll need to add a workflow.WARNINGFor the form to be validated properly when the user submits it, the workflow should be on the Form container element itself, not on the buttonTIPLooking at the Navigator on the left in the example above, notice the lightning icon next to the Form container element. There's no such icon next to the Submit button element. This shows us we added the workflow on the correct element. This follows standard web form practices where submission is managed by the form rather than individual buttons, ensuring expected behavior for users.The form submission workflow should be triggered On submit.Workflow actions ​When creating workflows within the Form container, two specialized actions become available:Set form stateSubmit formThese actions can be used not only in workflows attached to the form itself, but also in workflows attached to any element inside the form container (like buttons, inputs, or custom components).Set form state ​Controls form submission status variables:isSubmitting: toggle loading state (On/Off)isSubmitted: toggle submission status (On/Off)Use to manage loading indicators, create multi-step forms, or reset form state.Submit form ​Programmatically submits the form, which:Runs all form validationTriggers the form's submission processSets both submission variables appropriatelyUse for custom submission triggers or conditional submission logic.A practical workflow sequence for form submission: ​⚡ On submit: user clicks the submit buttonSet isSubmitting to On: show loading spinnerAPI call: send form data to your database (or simply add the Time delay action to simulate processing)Check API response:If successful: set isSubmitted to On, show success messageIf error: keep isSubmitted Off, show error messageSet isSubmitting to Off: hide loading spinnerThis simple flow provides feedback throughout the submission process while handling both success and error cases in a user-friendly way:Form input states ​To improve your web app's accessibility and user experience, it's best practice to add states to form inputs. States help provide visual feedback to users based on form conditions.A common example is disabling the submit button until all form fields are valid:In the example above, we're using the form's isValid property to control the submit button's disabled state. When the form validation fails, the button remains disabled, preventing submission attempts with invalid data.You can apply similar state controls to highlight invalid fields, show success indicators, or create other interactive elements that respond to the form's validation state.Learn more about adding states in WeWeb."
  },
  {
    "h1": "Heading​",
    "url": "https://docs.weweb.io/elements/heading.html",
    "content": "Heading ​Headings are essential for structuring your content, providing clear and hierarchical text organization. They ensure readability and enhance the user experience across all devices.In WeWeb, headings are just text elements with a special touch—the HTML tag in the settings is set to a heading tag. You can easily switch between H1, H2, H3, and H4 depending on your needs.While changing these tags might not visibly alter your text, they are vital for helping browsers and search engines grasp the hierarchy and importance of your content. This is particularly crucial for pages focused on SEO or marketing, as these tags communicate the structure and significance of your content.Styling headings is just like styling any other text."
  },
  {
    "h1": "Icon​",
    "url": "https://docs.weweb.io/elements/icon.html",
    "content": "Icon ​The Icon element allows you to use custom SVG icons in your projects. You can upload your own SVG files or use pre-made icon libraries to enhance your UI design.Getting Started ​Add an Icon element to your pageSelect your desired icon from pre-made libraries or your custom uploadsCustomize the color property if neededWARNINGIf you're working with a project that was created prior to the release of this icon element (13.03.2025) and your icon elements appear broken, you will need to manually add the Lucide library. To do so, go to Assets → Icons → Manage icon sets and add the Lucide library.Properties ​PropertyDescriptionIconSelect the icon to display from available libraries or custom uploadsColorChoose the color for your icon using the color pickerSizing Icons ​To change the size of an icon, you need to directly modify its height and/or width properties:Select the icon elementAdjust the height and width values in the sizing properties panelAdding Pre-made Icon Libraries ​Go to the Assets menu in the top barSelect IconsGo to Manage icon setsAdd any pre-made libraries you want to use in your projectManaging Custom Icons ​Uploading Custom Icons ​Navigate to the Assets menu in the top barSelect IconsGo to Custom IconsUpload your SVG files: Upload individual SVG files, orUpload folders containing multiple SVGsWARNINGCustom uploaded icons must be SVG files, and must have their stroke and/or fill set to 'currentColor' for the color picker in the editor to work correctly. If you are unsure how to configure this, please refer to the video below:Exporting Icons ​From inside the Custom Icons menu, you can export all icons from your project.Using Icons in Your Project ​Selecting an Icon ​Once you've added icons to your project:Add an Icon element to your pageUse the icon selector in the properties panel to browse and select iconsBinding Icons Dynamically ​When binding an icon dynamically, you must use the exact name of the icon:An icon called 'align-justify' from the Lucide library would be lucide/align-justifyA custom uploaded icon called 'check' would simply be checkThe syntax follows the pattern: libraryName/iconName for library icons, or just iconName for custom icons (assuming you have not manually added folders to the names of your of custom uploaded icons)."
  },
  {
    "h1": "iFrame​",
    "url": "https://docs.weweb.io/elements/iframe.html",
    "content": "iFrame ​Integrate an iFrame into your web application with ease.The dimensions of the iFrame can be adjusted using the same properties applicable to other elements in WeWeb. Utilize properties such as width, height, max-width, max-height, min-width, and min-height, along with padding and margin, to position your iFrame as desired.Within the settings tab, simply input the iFrame URL. Note that this should be the URL only, not the complete iFrame code.Please ensure that the URL you are embedding supports embedding; otherwise, it will not function correctly."
  },
  {
    "h1": "Image Slider​",
    "url": "https://docs.weweb.io/elements/image-slider.html",
    "content": "Image Slider ​Incorporate a horizontal image slideshow into your web application.Configuring the image slider ​The Image Slider utilizes a flexbox layout for each slide, allowing you to incorporate multiple images within each slide's flexbox.To configure the image slider, follow these steps:Slides: Add image slides manually by clicking the + symbol in the editor. Alternatively, bind the slider to a list of images, ensuring that the fields within the flexbox align with the image sources in the repeating fields.Slides per View: Specify the number of image slides visible at once.Space Between: Define the spacing between image slides in pixels.Effect: Choose from various transition effects, including: Slide: A basic horizontal sliding effect.Fade: A smooth fading transition between images.Coverflow: A 3D effect where images appear to be stacked.Flip: A 3D flip effect for transitioning images.Cards: A card-stacking effect for a unique transition.Transition Duration: Set the duration of transitions in milliseconds.Navigation: Enable or disable arrow navigation for images.Pagination: Toggle the display of image page indicators.Loop: Enable or disable continuous looping of image slides.Autoplay: Activate autoplay and configure the following properties: Timing: Set the autoplay interval in seconds for images.Linear Transition: Toggle linear transition for image autoplay.Mousewheel Control: Enable or disable control via mousewheel for image navigation."
  },
  {
    "h1": "Image​",
    "url": "https://docs.weweb.io/elements/image.html",
    "content": "Image ​Easily add an image to your website by choosing one from WeWeb's local storage or linking to an online source.Configuring the Image ​Styling Options:Image Link: Choose where your image comes from—either a local path or a URL from the web.Fit: Decide how your image fits within its container: Fill: Stretches the image to fill the space.Cover: Scales the image to cover the container while maintaining aspect ratio.Contain: Ensures the entire image is visible, fitting within the container.Overlay: Add a color overlay to your image for a unique effect. Possible options include solid colors, gradients, or patterns.Filters: Apply various filters to enhance your image's appearance, such as brightness, contrast, and grayscale.Configuration Settings:Alt Text: Provide alternative text that appears if the image fails to load.Loading: Choose how your image loads: Lazy: Loads the image only when it enters the viewport.Eager: Loads the image as soon as possible."
  },
  {
    "h1": "Infinite Slider​",
    "url": "https://docs.weweb.io/elements/infinite-slider.html",
    "content": "Infinite Slider ​Integrate an infinite horizontal slideshow into your web application for seamless content presentation.Configuring the Infinite Slider ​The Infinite Slider employs a flexbox layout for each slide, allowing you to incorporate multiple elements within each slide's flexbox.To configure the infinite slider, follow these steps:Slides: Add slides manually by clicking the + symbol in the editor. Alternatively, bind the slider to a list, ensuring that the fields within the flexbox align with the values in the repeating fields.Slides per View: Specify the number of slides visible at once.Space Between: Define the spacing between slides in pixels.Effect: Choose from various transition effects, including: Slide: A basic horizontal sliding effect.Fade: A smooth fading transition between slides.Coverflow: A 3D effect where slides appear to be stacked.Flip: A 3D flip effect for transitioning slides.Cards: A card-stacking effect for a unique transition.Transition Duration: Set the duration of transitions in milliseconds.Navigation: Enable or disable arrow navigation.Pagination: Toggle the display of page indicators.Loop: Ensure continuous looping of slides without interruption.Autoplay: Activate autoplay and configure the following properties: Timing: Set the autoplay interval in seconds.Linear Transition: Toggle linear transition for autoplay.Mousewheel Control: Enable or disable control via mousewheel."
  },
  {
    "h1": "Input​",
    "url": "https://docs.weweb.io/elements/input.html",
    "content": "Input ​Add an input element to your web app to easily gather various types of user input.Configuring the Input ​When setting up an input element, you've got a bunch of options to play with:Input Type: Choose the kind of input you need:Short Answer: Perfect for brief text entries.Long Answer: Ideal for more detailed responses.Email: Specifically for email addresses.Search: A handy search bar.Password: For secure password entries.Number: For whole numbers. Options include: Minimum number: Set the lowest value allowed.Maximum number: Define the highest value permitted.Step value: Specify the increment between numbers.Option to hide arrows: Choose whether to display the increment/decrement arrows.Decimal: When you need decimal numbers.Date: For date entries.Time: For time inputs.Phone: For phone numbers.Color: A color picker for selecting colors.Initial Value: Set a default value that appears when the page loads.Placeholder: Add a hint to guide users on what to enter.Read Only: Toggle this if you want the input to be non-editable.Required: Make the input mandatory by toggling this on.Debounce: Want to make your app feel smoother? Use debounce to pause input processing a bit. It's super handy when you've got workflows or collections that react to input changes. With debounce, you can decide how fast those changes should kick in.Autocomplete: Enable this to suggest possible completions as users type."
  },
  {
    "h1": "Kanban​",
    "url": "https://docs.weweb.io/elements/kanban.html",
    "content": "Kanban ​In this article, we will show you how to:add the Kanban Element to your project,display data in the Kanban Element,create a new card,update your records when a card is moved.Add the Kanban to a Project ​When you drag-and-drop the Kanban Element on the Canvas, you will be asked if you want to import Variables:Should you?Well, it depends if you'd like to see the Kanban with fake data to help you understand how it works.If you don't, then you can disable the option.If you do, the Kanban will include 3 mock data Variables:Selected itemShow detailsFake itemsThe \"isDragging\" Component Variable will be created regardless because it is required to drag-and-drop cards between columns.Display Data in the Kanban ​Once you have the Kanban on the page, you'll probably want to display and sort data in the Kanban.Step 1: bind the Kanban element to a list of items ​If you chose the include Variables options when you added the Element, you can look at the data that is bound in the Variables:In the example below, we bound the items to one of our Collections:Step 2: Explain which field in the list of items corresponds to the columns in your Kanban ​In the example below, our items are \"Stacked by\" the public status defined in the \"Public Statusx\" column of our database:Step 3: Map the Stack Values to the Values in the Database ​In the example below, the values in our database are:Under ReviewPlannedIn ProgressBut on the page, we want to display the tickets that are under review as \"Backlog\" so the \"Under Review\" value is given the \"Backlog\" label:To recap:you will need as many stacks as you want columns in your Kanbanthe labels you give the stacks are what will appear at the top of each column on the pagethe values you give the stacks must match the field values you selected as \"Stacked by\" in step 2. These are case sensitive.🔥 Pro Tip 🔥You can enable the option to display uncategorized cards with the \"Uncategorized stack\" property.Create New Cards ​Notice that when you enable the \"Uncategorized stack\" property, there is an \"Add card\" button.To allow users to create new cards, you could trigger a Workflow when they click on the Button.In the example below, when a user clicks on the \"Add card\" button, we change the value of a \"displayNewCard\" Variable to \"true\":When that Variable is \"true\", we display a Popup Form:When the user submits the Form, we create a new record in Airtable:Note that in the example above, we set the public status to \"Under Review\" by default because we want new cards to be reviewed first.Update Records in the Kanban ​Now let's say you want to update a record when a user drags a card to another column.Step 1: create a Workflow on the Kanban Element ​Make sure to trigger the Workflow \"On item moved\":Step 2: update the record in your database ​In the example below, we are updating a record in Airtable, in the Collection we used to display items in the Kanban:In order to update the correct record, we need to tell Airtable which object, i.e. which row in our base we want to update.In order to do that, we need to send Airtable the \"id\" of the record to update.In the example below, we used a \"getKeyValue\" formula that gets the value of the key \"id\" of the item that was moved:Then, we told Airtable that the new value for \"Public Statusx\" was the value of the stack where the card was moved:WARNINGNote that for now the \"Current value\" is not displayed when we bind our record id and the public status info. In the future, we will improve the display so you can preview the data with the last item moved."
  },
  {
    "h1": "Language Input​",
    "url": "https://docs.weweb.io/elements/language.html",
    "content": "Language Input ​The Language Input dropdown provides the language options available for the page.You cannot modify the options in this dropdown. Instead, the options automatically reflect the languages you have enabled for the page. For more information about page languages, please refer to the App Settings.Once a desired language is selected from this dropdown, the page language changes automatically, eliminating the need to create a specific workflow."
  },
  {
    "h1": "List​",
    "url": "https://docs.weweb.io/elements/list.html",
    "content": "List ​A basic list that you can easily link to a list of items. Plus, it can hold more than just text!Components of the List ​The List is made up of a single repeating element called Item, which includes a text element. Feel free to drag and drop additional elements into this Item, and they'll all be repeated automatically.The Flexbox that holds the Item is initially linked to a default list of [\"Apple\", \"Banana\", \"Orange\"]. You can easily modify this list using the formula editor or connect it to any other variable or collection you prefer.Once you're inside the Item, you can decide which part of the repeating item you want to bind to."
  },
  {
    "h1": "Loader​",
    "url": "https://docs.weweb.io/elements/loader.html",
    "content": "Loader ​Loaders are a great way to improve a user's experience on your web-app.There are two main types of loaders:Loaders on page change, to let the user know they are indeed being redirected after clicking on a linkLoaders during a process, to let the user know their action worked and the data is being fetched or a file is being uploaded for exampleLoaders on page change ​When a user navigates from one page of your app to another, you can now show them a subtle loader to let them know their click triggered a page change:This option is available:when using the \"Link\" setting on an element as shown above, andwhen using the \"Change page\" action in a workflow.It will look something like this:If you want more control over when and how the loader appears, you can use the dedicated \"Page loader\" action in a workflow.In the example below, we decided to display the loader for 3 seconds before changing page:This can be useful when you have a workflow that you know will take time in the background.TIPBy the way, you could also use this \"Page loader\" action without changing page.In the example below, we have a workflow on a click that displays a loader, then fetches a collection, and hides the loader once the collection has been fetched:Loaders on collection load ​At times, your app will be waiting for data from your backend to display in the user interface.When that happens, it is a best practice to display a loader on the page.This lets the user know that nothing is broken, they just need to wait a second for the data.There are two steps to do this in WeWeb:1- add a Loader element where you want it on the page,2- define when you will show or hide the Loader, using the CSS display property or conditional rendering.Add a Loader element ​You can find the Loader Element in the Add > Elements menu:Once you have dragged and dropped the element on the page, you can choose the type of Loader you would like and style it like you would any other element:Bind the Loader to a condition ​Once you have a Loader element on the page, you'll most likely want to display it when certain conditions are met, i.e. when the conditions are true or false.These conditions depend on your use case. Let's look at a couple of examples.Example 1 – Waiting for data from a Collection ​This is a common use case for the Loader element: you are waiting for data from an external source.If the display depends on a Collection being fetched, you can bind the Loader element to the isFetching variable of that Collection:You will do something similar on the container with the elements you want to hide while the data is being fetched.Except in this case, you will bind it to the opposite of the isFetching variable by using the not no-code formula:What we are saying is that:if the Collection has been fetched already – so isFetching is falsethen we want to display the container with the data.TIPIn the examples above, we are binding the condition of the Loader to the CSS display property. Another option would be to bind the condition to the Conditional rendering setting.Example 2 – Loader for a Workflow in Progress ​This can be very helpful when you have a workflow with a For Loop iterator that takes a bit of time for example.If you need to display a Loader while a workflow is in progress, you'll need to create a variable that is a Boolean, i.e. a variable that returns true or false:In the example above, we called our variable workflowInProgress and set it to false by default because, by default, workflows are inactive. They are triggered by an event.Then, you can add a display and hide action where you change the workflowInProgress variable at the beginning and end of your workflow.Since it's a boolean variable with a default value of false, you could use the not no-code formula as shown below:Once that's set up, you can bind the display properties of the Elements you want to show or hide to that Variable 🙂TIPIn the example above, we grouped the boolean variables related to conditional display in one folder.Another approach we love: instead of creating a boolean variable for each workflow, create an object variable that you update with the name of the current workflow."
  },
  {
    "h1": "Masked Input​",
    "url": "https://docs.weweb.io/elements/masked.html",
    "content": "Masked Input ​Easily add inputs to your web app that need to match a specific pattern—like phone numbers!Configuring the Masked Input ​The Masked Input is just like the regular input in WeWeb, but with a twist—you get to add a pattern mask! Here's a quick guide on how to set up your pattern:A pattern mask is simply a string like this: '{#}000[aaa]/NIC-``*[**]'Here's what each part means:0: any digita: any letter*: any character[]: makes the input optional{}: includes a fixed part in the unmasked valueCheck out these examples, each demonstrating how to use pattern masks for different types of inputs:US phone: {(000)} 000-0000 Explanation: This pattern is used for formatting US phone numbers, where the area code is enclosed in parentheses, followed by the main number.French phone: +{33} 000 000 000 Explanation: This pattern includes the French country code (+33) and formats the local phone number in groups of three digits.Bank card: 0000 0000 0000 0000 Explanation: This pattern is for credit or debit card numbers, typically consisting of 16 digits grouped in sets of four for readability.International Bank Account Number (IBAN): 0000 0000 0000 0000 0000 00 Explanation: This pattern accommodates the IBAN format, which can vary in length but often includes up to 22 characters.IP address: 000.000.000.000 Explanation: This pattern is for IPv4 addresses, consisting of four sets of numbers separated by dots, each ranging from 0 to 255.US Social Security number: 000-00-0000 Explanation: This pattern matches the format of a US Social Security number, with three groups of digits separated by hyphens.French Social Security number: 00 00 00 000 000 Explanation: This pattern is tailored for the French Social Security number format, which includes several groups of digits separated by spaces."
  },
  {
    "h1": "Modals (Deprecated)​",
    "url": "https://docs.weweb.io/elements/modal.html",
    "content": "Modals (Deprecated) ​Add modal ​When you drag-and-drop a Modal element in WeWeb, you'll notice in the Navigator that the element is made up of:a section, where you can choose how the modal should behave, anda container, where you can add other elements and customize the style of the modal.TIPIf you consistently move modal sections to the bottom of the HTML tree in the Navigator, it will be easier to find them when you need to edit them.Alternatively, you could choose to force the display of all your modals in the editor or define your own best practice or just search for your modals with the navigator search.Customize modal display ​At section level, you can define how the modal should behave.For example, you can choose:where it is displayed on the page,how it appears (animation, Z axis, transition), andif it should be highlighted with a backdrop or not.TIPDon't forget to check and customize how the modal behaves on tablet and mobile. Learn more about designing responsively in WeWeb.Customize style & content ​At container level (the first Container element inside the Modal section in the Navigator), you can add content and style how the modal looks by customizing its standard CSS properties.For example, you could change its:padding,background color, andborder width.Modals & performance ​To improve your web-apps performance, considering using the Conditional rendering setting to decide when a modal should be rendered in the user's browser:The more modals you have on a single page, the more using Conditional rendering instead of simply hiding the element with the CSS display property will make a big difference.Learn more about conditional rendering vs conditional display.TIPWhen you bind a boolean variable to the Display property or Conditional rendering setting of a Modal element, you'll have the option to enable the Force display in Editor setting.When building, this is helpful to edit your design more easily without switching back and forth between preview and editing mode.Don't forget to turn it off when you're finished editing. Otherwise, other team members or future you might not understand why the modal won't close!"
  },
  {
    "h1": "Paginator​",
    "url": "https://docs.weweb.io/elements/paginator.html",
    "content": "Paginator ​In this article, we explain how to:Style the Paginator elementFilter a collection in the frontend using the Paginator elementFilter a collection in the backend using the Paginator elementStyling the Paginator ​You can style any element inside the Paginator, change the style of the arrows or change the color of the active page number for example.To change the color of the active page number:select the \"Text\" element inside the Paginator,create an active state in the style section of this element,select the active state and style it like you would any other state.In the example below, we styled the Paginator's \"Text\" element so that the active page number appears blue and bold:Frontend pagination ​Before we go any further, note that when you add pagination in the frontend, all your collection items loaded in the user's browser, even if only 10 items are displayed on the page.If you do not want this to happen, consider adding pagination in your backend before fetching the collection in WeWeb.Learn more about server-side (backend) vs client-side (frontend) pagination here.If you do want to add pagination in the frontend, here's how you do it in WeWeb:drag-and-drop the Paginator element on the page that displays the collection you want to paginateensure the collection on the page is bound to the Collection object and not a Collection['data'] arraytell the Paginator which collection you want to paginate using the Collection dropdown:WARNINGThis is not intuitive but, for the Paginator element to work, the Collection it relates to must be bound to the Collection object, not Collection['data']. This is because Collection['data'] only includes the list of items in our Collection and we need the information about the current page which is in the Collection object.To learn more about frontend pagination in the context of a real project, consider watching this video from level 1 of the WeWeb Academy:The limits of frontend pagination ​With frontend pagination, data that is not displayed on the page is still accessible in the browser:This has two consequences:the data being loaded may still be heavy enough to slow the browser down or strain your visitors' data planseven though it is not displayed on the page, the data is accessible to anyone who knows where to look for it, i.e. in the inspector / network.If you want to avoid this, consider adding pagination in the backend instead.Backend pagination ​When working with large amounts of data, it is best practice to paginate your Collection of data in the backend.If you paginate a Collection in the frontend, the entire set of data will be loaded in your users' browsers, even if you only display 10 items on the page.This is a big no-no if you're working with a heavy set of data as your users' browsers will crash.People often talk about millions of records but another way to look at it is in terms of volume. The less you tap into your users mobile data plans, the better.This next steps explain how to setup custom pagination on the Paginator Element.WARNINGHow you add pagination to a table in your backend is specific to your backend. Here, we will illustrate how to add Custom pagination on the WeWeb Paginator element using a Xano endpoint. If you are having trouble to follow along with a different backend, please check the user docs of your backend provider.Step 1: add paging to the backend ​In Xano, you'll need to enable Paging in the Output of your query:If you run and debug your API call, you should now see additional information in Xano like the number of itemsReceived and total number of pages, i.e. pageTotal:In WeWeb, the collection should look something like this with context about the collection in addition to the items:Note that, in the screenshot above, we can see Xano sends back 5 items. This is because we asked for 5 items per page when we enabled Paging in Xano.Step 2: have the backend listen for info about the current page and offset ​With the WeWeb Paginator element, we can send info about the current page and offset to tell Xano what items the user needs to see next. In order to to feed that information to Xano, we will create two integer inputs in Xano – page and offset – which we'll map in the External tab:TIPIn the context of pagination in web development, offset refers to the number of items that should be skipped from the beginning of a dataset when displaying a particular page of results.For example, let's say we have a list of 50 items, and we want to display 10 items per page. To display the second page of results, we would need to skip the first 10 items (i.e., the offset would be 10), and then display the next 10 items.Step 3: test the API call ​Through a \"Run & Debug\" in Xano and/or in a Collection in WeWeb, test your API call to make sure it sends back the data you expect depending on the page or offset you send.Here we chose to tell Xano which page we want:TIPTest your API call with different pages and offsets, including the first and last page to ensure that your backend is sending the right items based on the information the frontend is requesting.Don’t worry about making the call dynamic yet, just try with a few values to make sure the response is what you expect.Step 4: create a paginator variable ​Create a paginator variable of type Object with the default values your backend needs to send the first items you want to display from your table.Usually, the default page value should be 1 – paginator is on the first page – and the default offset value should be 0 – no items should be skipped:Step 5: Paginator workflow ​On the page with the collection you want to paginate, add the WeWeb paginator element with a workflow that:triggers On changeupdates the paginator object variable with the information from the eventrefetches the Collection you are working withThat way your paginator variable will have the up to date offset and current page so however you chose to make the call to Xano, you’ll have the correct info based on user interactions with the paginator.Step 6: Paginator settings ​On the paginator element, enable \"Custom pagination\", and bind:the total items returned by your backend (e.g. Xano sends back itemsTotal),the fixed number of items per page (note: this is NOT the number of items received because if you’re on the last page of the collection, the backend might return only 17 items leftover instead of the full 25 per page for example)the offset – the offset should be current page (from the paginator event) - 1 * number of items per pageStep 7: bind the collection ​In WeWeb, instead of binding your collection to the collection with its metadata, you'll need to bind directly to an array or list of items.If we take Xano as an example, that means instead of binding to Collection['data'] or Collection, you'll need to bind Collection['data']['items']:This is because the container to which you bind the collection expects an Array, i.e. a list of items.The binding of the Collection List items is the same as with any other Collection List. If you're unsure how to display the job title or company logo on the page, please refer to the user documentation on binding.Step 8: make your API call dynamic ​Back in your collection, you can now bind the input you are sending to your backend to the data in your paginator variable (for example, the page or offset).The input you send to your backend will depend on the info your backend needs to return the items you want.And voilà! You should be good to go.Enable the Preview mode to check that everything is working correctly.Setting up backend pagination can be challenging. Please don't hesitate to reach out to the WeWeb Community if you get stuck."
  },
  {
    "h1": "Progress bar​",
    "url": "https://docs.weweb.io/elements/progress-bar.html",
    "content": "Progress bar ​Incorporate a progress bar into your web application to visually represent the completion status of a task or process.You can customize the progress bar with the following properties:Progress Bar Color: Define the color of the progress bar to match your design preferences.Label Position: Choose the position of the label: Element: Display the label on the element itself.Progress: Display the label on the progress section.Within the settings tab, you can set the progress value, which is represented as a simple integer.The progress bar is especially beneficial when linked to the progress of another process or task, providing users with a clear visual indicator of completion."
  },
  {
    "h1": "QR Code reader​",
    "url": "https://docs.weweb.io/elements/qr-code-reader.html",
    "content": "QR Code reader ​In WeWeb, you can find the QR code reader element in the Add menu:This element comes with 2 in-built variables:QR Code Reader - camerasQR Code Reader – codeSelecting a Camera ​The QR Code Reader - cameras lists all the cameras found on the device that is accessing the app.By default, the element will activate the user's default camera but you can choose to reference another camera by typing in its name:TIPBy combining the select and the QR code reader elements, you can create a great UX where users have the option to choose the camera they want to use to scan a QR code.In the example below, you can see we bound the list of cameras found by the QR code reader to a select element:We were then able to bind the \"Camera name\" of the QR code reader to the component variable of the select element:Scanning a QR code ​Once the user scans a QR code with the camera of their choice, the QR Code Reader – code will be updated with the value referenced by the QR code, for example a URL.In the example below, you can see we scanned a QR code that referenced WeWeb's Twitter account:On scan workflow ​Note that the QR code reader element comes with a pre-built workflow with a trigger On scan:This workflow stores the event of the scan in a Scan result text variable in the QR code component folder.You could use bind this variable to other elements in your app. For example, a modal asking the user for confirmation they want to navigate to the URL suggested by the QR code:"
  },
  {
    "h1": "Radio Group​",
    "url": "https://docs.weweb.io/elements/radio-group.html",
    "content": "Radio Group ​A set of checkable buttons—known as radio buttons—where no more than one of the buttons can be checked at a time.Properties ​Name of propertyTypeDescriptionItemsObject listValue per itemBindingWhich object property is the designated value of the radio input. The value attribute defines the unique value associated with each radio button. The value is not shown to the user, but is the value that is sent to the server on \"submit\" to identify which radio button that was selected.Initial valueAnyNameTextRead-onlyBooleanRequiredBooleanValue ​Customization ​Our radio group is built with customization in mind. You can defineExamples ​"
  },
  {
    "h1": "Range Input​",
    "url": "https://docs.weweb.io/elements/range-input.html",
    "content": "Range Input ​Incorporate a slider input into your web application to efficiently capture numerical values along a sliding scale.Configuring Range Input ​The Range Input element offers a variety of configurable properties to tailor its appearance and functionality.Visual Properties:Property NameDescriptionTooltipEnable or disable the tooltip display.Font SizeSet the tooltip font size in pixels.Font FamilyChoose the font family for the tooltip text.Active Range Background ColorToggle the use of an active background color for the range.Range BackgroundDefine the color of the range background.Selector BorderSpecify the color of the selector's border.Selector BackgroundSet the color of the selector's background.Tooltip BackgroundChoose the background color for the tooltip.Tooltip TextDefine the color of the tooltip text.Other Properties:Property NameDescriptionRequiredEnable or disable the requirement for this input in forms.Initial ValueSet the default value for the range input.Minimum RangeDefine the minimum value of the range.Maximum RangeSpecify the maximum value of the range.StepDetermine the increment step for the range values."
  },
  {
    "h1": "Recaptcha​",
    "url": "https://docs.weweb.io/elements/recaptcha.html",
    "content": "Recaptcha ​Integrate Recaptcha into your web applications using WeWeb to enhance security.Recaptcha serves as a robust security mechanism that safeguards websites against spam by effectively differentiating between human users and automated bots. This tool ensures that only legitimate users can access site functionalities, thereby bolstering security and preventing misuse.Configuring Recaptcha ​To integrate Recaptcha, a Google plugin, you must first generate a key through your Google account. This can be accomplished by visiting the Google Recaptcha Admin.Ensure that you configure the following domains:weweb.io - for testing within the editorYour specific domain nameWithin the WeWeb editor:Paste the generated Site Key into the Site Key property.To enable automatic submission of this value with a related form, activate the Send value at submit option.Please note that this is only one aspect of the Recaptcha configuration. For a complete setup, you must also configure the backend. Utilize the private key in your backend to verify the authenticity of requests. For further details, refer to Google's Verify Documentation."
  },
  {
    "h1": "Reorder List​",
    "url": "https://docs.weweb.io/elements/reorder-list.html",
    "content": "Reorder List ​A reorder list lets you set up a list with various categories and draggable items that you can easily move around and rearrange into different categories.Configuring the Reorder List ​The Reorder List is organized into a Stack that includes Header, Items, and Footer containers. In the Items container, everything is draggable, meaning you can move items around freely.Here are the key properties you can configure:Group: This is where you name your list. It's handy when you have multiple lists and need to set rules for moving items between them.Items: This is the list of items you want to repeat. By default, we provide a JSON object with a list of items. You can edit this within the Items container to add or remove elements as needed.Sortable: Toggle this option to enable sorting of the list.Read Only: Use this toggle to allow or prevent editing.Custom Drag: While everything in the Items container is draggable, you might want some elements, like list names or images, to stay put. By enabling the Custom Drag option, you can specify which items can be dragged. When you toggle Custom Drag, you'll be asked for a Class name. Only elements within Items that have this class name will be draggable.Setting drag on elements ​Want to make only specific elements draggable? Here's how:First, turn on Custom Drag for the Stack.Next, pick a class name, like draggable.For each element you want to be draggable, head over to its Settings > HTML attributes. Add your chosen class name to its Class attribute (default is draggable)."
  },
  {
    "h1": "Sans titre",
    "url": "https://docs.weweb.io/elements/responsive-sidebar.html",
    "content": "Coming Soon"
  },
  {
    "h1": "Rich Text​",
    "url": "https://docs.weweb.io/elements/rich-text.html",
    "content": "Rich Text ​Display and edit rich text ​With the Rich text input element, you can:display rich text on a page,allow users to input and edit rich text,allow users to mention other users in the text.In the screenshot above, you can see two sections with:the element in editing mode, where users can type and style contentthe element in read-only mode, where users can see what the content will look like on an HTML page.Style rich text ​When using the Rich text input element, you can:type markdown,show or hide the style bar,add bullet points, ordered lists, links, quotes, and code blocks, andtag / mention other users.Here's what it looks like in action:Add mentions ​If you want to allow users to tag other users, you'll need to define a list of users who can be tagged.In order to do that, you'll need to:select the element on the pagego to the Settings > Mentionsprovide a list of users with an Id and Label,map the Id and Label values of the element to the correct columns (or keys) in your list of users.In the example above, we have an array variable (i.e. a list) with two users. Each user has an id and a name.In the element settings, we bound the users variable to the Mentions Lists property, and mapped the id and name values to the Id and Label properties of the element.Update or create record ​A really cool way to use the Rich text input element is to allow users to create or update content.For example, users could:write articles for you,update their user profile, orcreate a product page.In order to do that, you'll need to:add a button with a workflow triggered On click, andsend the value from the Rich text - value variable.In the example above, we make an API request to POST the value of the Rich text - value variable to an article column in our backend.You can follow the same logic to send data to an Airtable database, Xano, Supabase, or any other backend.Custom menu ​In the design tab of the rich text input element, you can choose to enable Custom menu:This option allows you to design your own editing menu, to match your brand's design system for example:You can add the buttons you want with the style you want and use the Execute component action to trigger the desired behavior:Here’s what it looks like in action with the Toggle Bold, Toggle Italic, and Toggle Underline actions:Rich text component actions include:Focus Rich text to focus the user on the rich text elementSet link to add a link to the selected textSet tag to choose the HTML tag of the selected textToggle bold to make the selected text boldToggle italic to make the selected text italicToggle underlineto underline the selected textToggle strike to strike out the selected textSet color to choose a color for the selected textToggle bullet list to create an unordered list of itemsToggle ordered list to create a numbered list of itemsToggle Code Block to create a code blockToggle Blockquote to create a blockquoteUndo to undo the previous user actionRedo to redo the previous user actionPaste text without formatting ​When users paste text from another source into the Rich text input element, the original styling and formatting might be preserved. If you prefer to have the text inserted without any external styling, you can encourage users to use the “Paste as plain text” option. The shortcut is typically Ctrl + Shift + V on Windows or Cmd + Shift + V on Mac. This bypasses any formatting and pastes the text directly."
  },
  {
    "h1": "Search​",
    "url": "https://docs.weweb.io/elements/search.html",
    "content": "Search ​Search elements ​In WeWeb, you have access to two search elements in the Add panel:one search inputone search input with a dropdown that displays resultsThe logic to filter a collection based on the value of a search will be the same whether you work with a ready-made search element from the Add panel or build your own.Filter data with search term ​TIPIn the video below, we wanted to show you how to build our own search element to filter a list with a default input element so you understand how the pre-built search elements work under the hood.You can save a lot of time by using the ready-made search elements available in the WeWeb Add panel. Simply skip to minute 2 of the video tutorial to learn about the filtering logic.00:00 - Using the ready-made search element vs building a search from scratch 00:40 - Starting with an input, any input element 02:12 - Understanding component variables (and why they're important) 02:45 - Filtering a collection based on the value of the search input 04:48 - Removing the advanced placeholder 05:19 - Slowing down the reactivity of the search very slightly to benefit user experience (debounce) 10:35 - Key takeawaysStyle search results ​In the video below, we show you how you can highlight the search term in search results:Here's the JavaScript code snippet we use in the video:js/* Declare your search term variable */ const search = {searchInputVar} /* Define your regular expression */ var regEx = new RegExp(\"(\"+search.replace(/([\\^\\$\\.\\\\\\(\\)\\[\\}\\{\\}\\+\\*\\?\\<\\>\\=\\-\\|\\:\\!\\&])/g, '\\\\$1')+\")\" , \"ig\"); /* Sanitize the result text */ const sanitizedText = wwFormulas.sanitize({searchResultText}) /* Style the result text that matches the regular expression with a red color and yellow background */ return search ? sanitizedText.replace(regEx, `<span style=\"color:red; background: yellow\">$1</span>`) : sanitizedTextMake sure you replace:the {searchInputVar} in line 2 with your own search input variable, without the {} wrappersthe {searchResultText} in line 8 with the text from your search result inside the (), but without the {} wrappersTIP - Use a global formulaWhile it can be easier to write the formula directly on your search result to ensure the text is styled as expected, we recommend you turn your formula into a global formula with parameters once you have reached the style you want.This will make your formula re-usable throughout your project and much easier to update and maintain in the future."
  },
  {
    "h1": "Sections​",
    "url": "https://docs.weweb.io/elements/sections.html",
    "content": "Sections ​Sections are the first building blocks of any web page.Think of them as chapters in a book. Each section serves a purpose to keep the story interesting.At the end of each section, you want the reader to take action, read on or click on a button.Add a section on the canvas ​We can drag a section anywhere onto the page.If you’re working on a blank page, big blue buttons will invite you to add a new section.If you’re working on a page that already has one or more sections, you can browse template sections in the Add menu: Save a section template ​To save an element or section as a template, select it on the page, and click on the Save to library icon:To add a section template on the canva, go to the Libraries section in Add menu:Learn more about building with WeWeb libraries.Duplicate a section ​In the Multi-page sections of the Add menu, you can see all the sections used in your project, page by page.You can copy or create a new instance of an existing section by dragging it onto the canvas or in the Layout tab: Create an instance – if you want changes you make in the section to be applied to all the instances of this section throughout your project.Create a copy – if you want to create an independent copy of an existing section so that the changes you make in the copy do not affect the original section.Learn more about leveraging multi-page sections to improve the performance of your web-apps.Re-order sections ​The sections you see in the Layout are usually displayed from top to bottom on the canvas.There are exceptions to this, like sidebars and hidden sections that appear in the Layout but not on the canvas, but it helps to think of sections as the logical succession of the content on the page.A classic list of Sections on a blog article page:Top navigation menuSidebar navigation with related articlesHero section with a big heading, excerpt, featured image, and author infoArticle contentComments sectionCall-to-action to subscribe to the newsletterFooterIf you need to re-organize the content on the page, you can select a section, then drag-and-drop it elsewhere on the canvas or in the Layout panel.Sometimes, it’s tricky to select a section and you end up selecting a container instead.You can ensure that you are selecting a Section, by clicking on the section icon in the Layout panel or on the canvas:Style a section ​Sizing ​By default, blank sections will take up the entire width of the page:When you add content inside the Section, the height of the Section will adjust automatically.As you put something inside like a heading, it adds to the height of the section, same thing with a paragraph or a button.That said, you can override the automatic width and height of the section.You can set a box width or minimum height, use viewport width and viewport height or pixels to size your section:Spacing ​You can add margins and padding to give a bit more breathing room to your design: Remember to check if it still looks good on mobile devices and adjust accordingly.Background ​You can set a background color to a section, add an image or video:"
  },
  {
    "h1": "Select​",
    "url": "https://docs.weweb.io/elements/select.html",
    "content": "Select ​You'll find the select and multi-select elements in the Add panel: Select filters 101 ​In the video below, we explain how to use the select element to filter a list of phone calls based on how long they lasted:00:00 - Understanding component variables 01:10 - Configuring selectable options (label != value) 02:29 - Filtering the list based on the option selected by the user 04:15 - OutroDynamic options ​In the example above, we \"hard-coded\" the options displayed in the select element.This is a great approach if you know your options will rarely change. However, depending on your use case, you might want to display dynamic options.For example, if you're a car rental company with new locations opening or closing regularly, you might want to bind the select element to data in a collection:Better UX & performances ​WeWeb's select element comes with advanced options which can boost the UX and performances of your web app, including but not limited to:allow users to search through items (not just scroll)limit number of options displayed and enable infinite scrolling to boost performancesdecide to close or leave the select options open after selectionMulti-select ​In the video below, we explain how you can filter a collection based on values selected by the user in a multi-select dropdown:"
  },
  {
    "h1": "Sidemenu​",
    "url": "https://docs.weweb.io/elements/sidemenu.html",
    "content": "Sidemenu ​The Sidemenu is a versatile navigation component that can be customized to slide in from any edge of the screen. It offers flexible alignment options, allowing it to be positioned along any boundary of the page for optimal user experience.Adding a Sidemenu ​Drag and drop the Sidemenu onto the canvas.You will be prompted to import variables. These variables assist in configuring the Sidemenu, so it is recommended to import them.Configuring the Sidemenu ​To customize the functionality and appearance of the Sidemenu, adjust the following properties:Property NameDescriptionDisplay On/OffToggle this setting to show or hide the Sidemenu.AnimationSelect from seven animation presets to determine how the Sidemenu enters the screen: Fade, Appear from Top, Appear from Right, Appear from Left, Appear from Bottom, Zoom In, and Zoom Out.BackdropEnable or disable a backdrop. When enabled, interactions are restricted to the Sidemenu only.TransitionDefine the behavior of the selected animation.Components of Sidemenu ​The Sidemenu is designed to be responsive, featuring two specific containers for mobile view configuration.Within the Menu container, you'll find the elements displayed when the menu is open, such as the Logo and Links.The Mobile container includes:Icon: Tapping this icon will expand the Sidemenu on mobile devices.Backdrop: This appears when the Sidemenu is expanded on mobile, providing a background overlay.Variables ​The Sidemenu includes two default variables:VariableDescriptionisOpenedThis is a boolean variable that is linked to the Display property. By toggling this variable, you can control whether the Sidemenu is visible (true) or hidden (false).menuWidthThis is an integer variable that is connected to the width property of the menu, allowing you to adjust its width as needed."
  },
  {
    "h1": "Skeleton Loader​",
    "url": "https://docs.weweb.io/elements/skeleton-loader.html",
    "content": "Skeleton Loader ​The Skeleton Loader component provides visual placeholders that mimic your content's layout during loading states. These animated placeholders improve perceived performance and reduce user frustration by indicating that content is loading.Getting Started ​Using AI ​The quickest way to set up skeleton loaders is by using AI:First, think about which content areas you want to show loading states forAsk AI: \"Create skeleton loaders for my user profile page\" or \"Add skeleton loaders to my product cards\"Continue refining your skeleton loaders by asking AI for specific modifications: \"Make the skeleton loaders use the pulse animation\"\"Create a skeleton layout for my article list with title and description\"\"Add rounded corners to match my card design\"\"Create a skeleton for a circular profile picture with two text lines\"Manual Setup ​Add a Skeleton Loader component to your page using the Add panel (search for \"skeleton\" or \"loader\")Style the component to match the dimensions and shape of your content (width, height, border radius)Choose an animation type that matches your design aestheticAnimation Types ​The Skeleton Loader component offers three animation types via the Animation Type property:Wave - A subtle highlight that moves from left to right across the elementPulse - A gentle fading in and out effectWARNINGThe pulse animation requires you to set a background color on the Skeleton Loader for it to appear correctly.Shimmer - A light reflection that sweeps across the elementStyling Your Skeleton Loader ​For the Skeleton Loader to be effective, it's essential to style it properly using the standard styling properties. Here are the key properties to consider:Essential Styling Properties ​PropertyDescriptionWidthSet the width to match your content (can be fixed or responsive)HeightSet the height to match your contentBackground ColorChoose a light gray color that contrasts with your background (e.g., #E0E0E0)PositionIn most cases, you will want the position to be Absolute so that it covers the desired contentWARNINGWithout a proper width, height and background color set, your Skeleton Loader may not be visible.Covering Existing Content ​To create a loading state that covers existing content (like product images or cards that are already rendered):Place the Skeleton Loader in the same container as the elements you want to coverGive the Skeleton Loader a position of Absolute, with a top position of 0 and left position of 0Set the width and height of the Skeleton Loader to 100% to fully cover the contentSet the z-axis value of the Skeleton Loader to be higher than the contents you want to coverWhat these positioning properties do:PropertyWhat it doesPosition: AbsoluteThis means the element (in this case the Skeleton Loader) ignores the position of the other elements in the container and positions itself relative to the containerTop: 0, Left: 0Anchors the element to the top-left corner of the containerWidth/Height: 100%Makes the element expand to fill the entire width and height of the containerZ-axisControls stacking order - the higher the value, the higher the element will be in the visual stackTIPIf your container has a border radius and the Skeleton Loader does not seem to match it, then ensure either your container's overflow is set to hidden, or your Skeleton Loader also has the same border radius set as the container.Conditionally Showing Skeleton Loaders ​To show Skeleton Loaders only during loading states:Create a boolean variable (e.g., isLoading) to use for controlling the displayBind the Skeleton Loader's display to this variableSet up logic to appropriately change the value of this variable when neededOnce everything is set up, the Skeleton Loader will display only during loading, like this:Usage Examples ​Text Content Loader ​To create a placeholder for text content:Place the Skeleton Loader in a container with the text elementGive the Skeleton Loader a position of Absolute, with a top position of 0 and left position of 0Set the width and height of the Skeleton Loader to 100% to fully cover the textSet the z-axis value of the Skeleton Loader to be higher than that of the text elementCard Loader ​To create a placeholder for multiple elements in a card:Place the Skeleton Loader in a container with one of the desired elements to coverGive the Skeleton Loader a position of Absolute, with a top position of 0 and left position of 0Set the width and height of the Skeleton Loader to 100% to fully cover the textSet the z-axis value of the Skeleton Loader to be higher than that of the card or imageDuplicate the Skeleton Loader and place in containers with all needed elementsTIPYou can easily create a container for an element by pressing ⌘ + G with the element selected in the editor. This is useful if you need the element to be in a container so you can place a Skeleton Loader alongside it. Best Practices ​Do: ​Match the skeleton's dimensions and shape to your actual contentUse subtle, consistent animations across your interfaceGroup related skeleton elements to mirror your content structureDisplay skeletons immediately when loading beginsDon't: ​Use bright or high-contrast colors for skeleton elementsMix different animation types in the same loading contextMake animations too fast or distractingKeep skeletons visible for too long (aim for <2 seconds when possible)Common Use Cases ​Article or blog post loading screensProduct card loading in e-commerceSocial media feed item placeholdersProfile information loadingForm field placeholders during data retrievalDashboard widget loading statesForking ​While the Skeleton Loader component offers flexibility through its animation types and styling options, there may be cases where you need functionality beyond what's natively available. In these situations, you can fork the component and modify it to meet your specific requirements.If you are unsure how to fork an element, you can learn more in the dedicated documentation.Forking Example: Custom Animation Type ​One common reason to fork the Skeleton Loader is to create a specialized animation type not available in the standard component. For example, you might want to create a \"Bounce\" animation that adds a subtle up-and-down movement.Here's how you can use AI to help with this process:Modify this forked Skeleton Loader to add a 'Bounce' animation type that adds a subtle vertical movement effectForking Example: Changing Animation Speed ​Another useful customization is having the ability to control the speed of the animation.Here's an example prompt for this:Update this forked Skeleton Loader to add a property for controlling the animation speedProperties ​Settings ​PropertyOptionsDescriptionAnimation TypeWave, Pulse, ShimmerChoose the style of loading animation"
  },
  {
    "h1": "Table​",
    "url": "https://docs.weweb.io/elements/table.html",
    "content": "Table ​The table component is an easy and straightforward way to showcase your data in a table format. It offers basic features, making it perfect for adding your own custom touches. If you're looking for something with more advanced features, consider using the data grid.Adding a Table ​Drag and drop the Table element onto the canvas.Components of the Table ​By default, a table includes two main sections: the Header and the Collection List. Inside the Collection List, you'll find three containers, each representing a row.Initially, both the Header and each Row contain five cells, which means there are five columns. If you want to add more columns, simply duplicate a cell. Keep in mind that, by default, the table isn't linked to any data source, so all the data you see are just static values.Configuring a Table ​To link your table to a data source, head over to the Collection List and bind the Item to a set of repeating elements.You'll notice that all the rows disappear, except for the first one. This remaining row acts as a template, allowing you to bind specific properties of the repeating elements to it.Let's say you have a collection called Sample Jobs. You can easily bind this data to your table by connecting it to the Collection List.You'll notice that the rows repeat 10 times, matching the 10 items in your collection.At first, all the rows look identical. To update the first column with the Job Title, you'll need to bind the text in that cell.Here's how you do it:Click on the text within the cell.Select the binding option to view all the properties of the repeating elements.Connect the Job Title.You can also bind other properties to different columns in the same way.Lastly, feel free to add or delete cells in the header and rows to adjust the number of columns as needed.Styling a table ​For styling your table, a great approach is to create some CSS classes tailored for different cell types and then apply them to the cells you want to style. You can use all the styling options that you have for flexboxes and containers on these cells too."
  },
  {
    "h1": "Text​",
    "url": "https://docs.weweb.io/elements/text.html",
    "content": "Text ​The text element allows you to seamlessly incorporate text into your page.To modify the text, simply double-click on the text element.Additionally, you have the option to bind the text to various sources, such as variables or formulas.For comprehensive styling options, please refer to the CSS properties documentation."
  },
  {
    "h1": "Toggle Input​",
    "url": "https://docs.weweb.io/elements/toggle.html",
    "content": "Toggle Input ​Incorporate a straightforward toggle switch into your web application.Configuring Range Input ​The Toggle Input element offers a range of configurable properties to tailor its visual appearance and functionality.Visual Properties:Property NameDescriptionSelector SizeAdjust the size of the selector as a percentage.Selector Color (Off)Set the color of the selector when it is in the 'off' position.Selector Color (On)Set the color of the selector when it is in the 'on' position.Background Color (Off)Define the background color when the toggle is off.Background Color (On)Define the background color when the toggle is on.Other Properties:Property NameDescriptionInitial ValueSet the default state of the toggle to either true or false.RequiredSpecify whether the toggle input is mandatory.Read OnlyDetermine if the toggle can be modified by the user."
  },
  {
    "h1": "Top Navigation Bar​",
    "url": "https://docs.weweb.io/elements/top-nav.html",
    "content": "Top Navigation Bar ​The top navigation bar is positioned at the top of the page and is designed to showcase essential links and actions for easy access.Components of the Top Nav bar ​The Top Nav Bar consists of two containers: one for Web View and another for Mobile View. It is responsive and automatically displays the appropriate container based on the screen size. You can modify these settings by adjusting the display property in the style panel. Be sure to review this property across different screen sizes to ensure optimal configuration.Web View ​The Web View consists of three main containers:Menu: This container holds the list of links available in the navigation bar.Actions: This section includes two buttons designed for call-to-action purposes.Mobile Icon: This icon is used to open the menu when viewed on mobile devices.Mobile Menu ​The Mobile Menu is composed of two primary containers:Menu: This container displays the list of links available in the navigation bar.Actions: This section contains two buttons for call-to-action purposes."
  },
  {
    "h1": "Video​",
    "url": "https://docs.weweb.io/elements/video.html",
    "content": "Video ​A video element lets you showcase a video that you've uploaded to our database. You have plenty of options to tweak how your video is displayed.Configuring the Video ​Property NameDescriptionFileThis is the local path to your video file uploaded on WeWeb. Just make sure the file size fits within the storage space of your pricing plan.Preview ImageThis is the thumbnail that appears before your video starts playing.Start TimeSet the time (in seconds) where you want your video to begin. By default, it starts at 0.AutoplayTurn this on if you want the video to play automatically when the component loads.MutedToggle this to keep the video muted by default.LoopEnable this if you want the video to start over once it finishes.ControlsDecide whether to show or hide video controls like the play button and volume.PreloadChoose whether the video should load during page load or only when it starts playing."
  },
  {
    "h1": "Array formulas​",
    "url": "https://docs.weweb.io/formulas/array.html",
    "content": "Array formulas ​These formulas are very useful to manipulate arrays, like changing their content, filtering them, etc.💡 Good to know 💡 ​These formulas won't replace the array they're using on but will always return a new one. To replace the array by its new value, you should use a workflow to store the returned result as the new content of the array.add ​This formula will add one or multiple values at the end of an existing array. It's the JavaScript equivalent of push.Example ​In this example, we have a variable countries which equals to [\"France\", \"USA\"], so an array of strings containing the countries where WeWeb employees live. But we're missing some countries! To solve this, we'll use the add formula to add two new countries.contains ​This formula will check if a value exist in a given array. It always returns a boolean, meaning it will either return true or false.Example ​Let's get back to our countries array variable, which now equals [\"France\", \"USA\", \"Belgium\", \"Croatia\"]. If we use the contains formula with this array and \"France\", it will return true. With \"Canada\", it returns false, as Canada isn't in the list of countries.createArray ​The createArray formula is useful to create a whole array from scratch, without any code. It's the equivalent of writing the whole array in JavaScript.Example ​Let's say we want to create the countries array (containing the places where WeWeb employees live, meaning [\"France\", \"USA\", \"Belgium\", \"Croatia\"]) in a workflow, without needing to type any JavaScript. To do this, we would write this formula:compare ​This formula will compare that two arrays are equals. Meaning they both have the same values and that their values are in the same order (same index for each). This formula always returns a boolean, which means true or false.Example ​If we take our countries array which contain [\"France\", \"USA\", \"Belgium\", \"Croatia\"], compare will return true or false in these use-cases:same values, same order -> truesame values, different order -> falsedifferent values -> falsedistinct ​distinct iterates over the values in an array, and will return a new array with only unique values. Meaning that if a value is present twice or more in the array, it will be returned only once.Example ​Let's say we have an array with WeWeb employees names, but we wrote one of them twice by mistake. By using the distinct formula, we're able to correct this mistake.filterByKey ​This formula will iterate over an array of objects, and return an array where only the object's with a certain key have a certain value.It seems hard to understand like that, I know... But check the example and it'll become super clear 😉Example ​Let's say we have an array of users with objects containing their names and role in the web app:json[ {\"name\": \"Quentin\", \"role\": \"admin\"}, {\"name\": \"Joyce\", \"role\": \"normal\"}, {\"name\": \"Aurélie\", \"role\": \"admin\"}, {\"name\": \"Kévin\", \"role\": \"normal\"} ]We want to filter this array to only have users who are admins. We can do this easily with the filterByKey formula:Learn more about the filterByKey formula in this video tutorial.findIndex ​findIndex, when given and array and a value, will find the index in the array of the first element which equals the given value. If the value isn't found, it will return -1. It's equivalent to JavaScript's indexOf.🔥 Pro tip 🔥Array indexes begin at 0, not 1.Example ​If we take the countries array, which includes [\"France\", \"USA\", \"Belgium\", \"Croatia\"], it will return 2 when we use findIndex for \"Belgium\", -1 for \"Germany\" as it's not in the array.findIndexByKey ​This formula is equivalent to the findIndex formula but for arrays of objects. It'll return the index of the first object in the array whose key is equal to value.Example ​Let's get back to our array of users with objects containing their names and role in the web app:json[ {\"name\": \"Quentin\", \"role\": \"admin\"}, {\"name\": \"Joyce\", \"role\": \"normal\"}, {\"name\": \"Aurélie\", \"role\": \"admin\"}, {\"name\": \"Kévin\", \"role\": \"normal\"} ]If we try to find the first object whose \"role\" equals to \"normal\", we'll get the index 1 (the second object). We'll get the index 2 to match on \"name\" equals \"Aurélie\" and -1 when matching on \"John\" as this name doesn't exist in the array.getByIndex ​This formula will return an element in a array at a specific index.Example ​Let's get back to our array of users with objects containing their names and role in the web app:json[ {\"name\": \"Quentin\", \"role\": \"admin\"}, {\"name\": \"Joyce\", \"role\": \"normal\"}, {\"name\": \"Aurélie\", \"role\": \"admin\"}, {\"name\": \"Kévin\", \"role\": \"normal\"} ]If we use getByIndex on the second index, we'll get back Aurélie's object.groupBy ​groupBy, when given an array of objects, will return a new array where objects are grouped by their value for a given key.Example ​Again, we go back to our array of users with objects containing their names and role in the web app:json[ {\"name\": \"Quentin\", \"role\": \"admin\"}, {\"name\": \"Joyce\", \"role\": \"normal\"}, {\"name\": \"Aurélie\", \"role\": \"admin\"}, {\"name\": \"Kévin\", \"role\": \"normal\"} ]Let's say we want to regroup them by role type (admins together and normal users together). We can use the groupBy formula applied on the \"role\" key for this.join ​This formula will join all the elements of an array into a string, separating them by a separator (optional, , by default). It's equivalent to JavaScript's join.Example ​Say we want to write a string telling people where WeWeb employees live, using the countries array which equals to [\"France\", \"USA\", \"Belgium\", \"Croatia\"]. We can easily do this with string concatenation and join.length ​It will return the length of an array, meaning the number of items inside it. Same as JavaScript's length.Example ​Using it again on countries which is [\"France\", \"USA\", \"Belgium\", \"Croatia\"], length will return 4 as there's four countries in this array.lookup ​Given an array of objects, this formula will return the first object where the key equals to a value. The key is optional, and equals \"id\" by default. It's equivalent of using getByIndex and findByIndex together.💡 Good to know 💡This formula is very useful to link two arrays together when they are linked by a one-to-one relationship or one-to-many relationship in a database. One example is when you want to link two different Airtable records which are also linked by a lookup inside Airtable.Example ​Let's say, that in our users array, we want to find back the one for Aurélie. We can do this using the lookup formula.As a reminder, here the array:json[ {\"name\": \"Quentin\", \"role\": \"admin\"}, {\"name\": \"Joyce\", \"role\": \"normal\"}, {\"name\": \"Aurélie\", \"role\": \"admin\"}, {\"name\": \"Kévin\", \"role\": \"normal\"} ]Also, small example with getByIndex used with findByIndex.lookupArray ​Same as lookup, but will match an array of values and return all the objects where the value is in the array of values for a given key.🔥 Pro tip 🔥This formula is very useful to link two arrays together when they are linked by a many-to-many relationship in a database. One example is when you want to link more than two different Airtable records which are linked by a lookup inside Airtable.Example ​Let's say we improve our users array with a new member, Raphael, who's a \"superAdmin\":json[ { \"name\": \"Quentin\", \"role\": \"admin\" }, { \"name\": \"Joyce\", \"role\": \"normal\" }, { \"name\": \"Aurélie\", \"role\": \"admin\" }, { \"name\": \"Kévin\", \"role\": \"normal\" }, { \"name\": \"Raphael\", \"role\": \"superAdmin\" } ]If we wanted to get only users that are either admins or super admins, we would use the lookupArray formula.map ​Given an array of objects, this formula will return an array with only the selected key(s) from each object.Example ​Again, we take our users array of objects:json[ { \"name\": \"Quentin\", \"role\": \"admin\" }, { \"name\": \"Joyce\", \"role\": \"normal\" }, { \"name\": \"Aurélie\", \"role\": \"admin\" }, { \"name\": \"Kévin\", \"role\": \"normal\" }, { \"name\": \"Raphael\", \"role\": \"superAdmin\" } ]If we wanted to get an array of the users' names only, we would use the map formula like so:merge ​Given two or more arrays, the merge formula will return a single array containing all the former arrays.Example ​Let's say we have two arrays with these values:js// countries array [ \"France\", \"USA\", \"Belgium\", \"Croatia\" ] // countries2 array [ \"Germany\", \"India\", \"Japan\" ]The result of merging those two arrays will give a bigger array containing all the countries:prepend ​The prepend formula adds one or more values at the beginning of a given array.Example ​Let's say we have a countries array with the following values:js// countries array [ \"France\", \"USA\", \"Belgium\", \"Croatia\" ]By prepending \"Germany\" to it, we'll get this result:remove ​This formula will remove a given value from an array.Example ​Still with our countries array as an example:js// countries array [ \"France\", \"USA\", \"Belgium\", \"Croatia\" ]Here's what happens when removing \"USA\" from it:removeByIndex ​removeByIndex does the same thing as the remove formula, except it does it by removing the element at a certain index in an array, rather than a value.Example ​Same example and return as the example for remove, but with the index:removeByKey ​Given an array of objects, this formula will remove all the objects from the array where the given key is equal to a given value.Example ​Here's an array called users with the following value:json[ { \"name\": \"Quentin\", \"role\": \"admin\" }, { \"name\": \"Joyce\", \"role\": \"normal\" }, { \"name\": \"Aurélie\", \"role\": \"admin\" }, { \"name\": \"Kévin\", \"role\": \"normal\" }, { \"name\": \"Raphael\", \"role\": \"superAdmin\" } ]If we were to remove all the admin users, we would do it like so:reverse ​Given an array, this formula will reverse its values order.Example ​Given back our countries array:json[ \"France\", \"USA\", \"Belgium\", \"Croatia\" ]Reversing it will return this value:rollup ​Given an array of objects, this formula will return all the values for a given key. If the distinct parameter is set to true, it'll return unique values only (false by default).Example ​Here's an array called users which equals to:json[ { \"name\": \"Quentin\", \"role\": \"admin\" }, { \"name\": \"Joyce\", \"role\": \"normal\" }, { \"name\": \"Aurélie\", \"role\": \"admin\" }, { \"name\": \"Kévin\", \"role\": \"normal\" }, { \"name\": \"Raphael\", \"role\": \"superAdmin\" } ]If we were to get the possible roles, we would use the rollup formula like this:slice ​This formula will return the values from an array from the startIndex up to the endIndex (endIndex not included). It's the exact same function as the JavaScript's slice.Example ​Given a countries array:json[ \"France\", \"USA\", \"Belgium\", \"Croatia\" ]Slicing it to get back only [\"USA\", \"Belgium\"] would it be possible by using the slice formula:sort ​Given an array, this formula will sort it in ascending (\"asc\") or descending (\"desc\") mode. It can be applied on a given key for arrays of objects.Example ​Taking back our array called users which equals to:json[ { \"name\": \"Quentin\", \"role\": \"admin\" }, { \"name\": \"Joyce\", \"role\": \"normal\" }, { \"name\": \"Aurélie\", \"role\": \"admin\" }, { \"name\": \"Kévin\", \"role\": \"normal\" }, { \"name\": \"Raphael\", \"role\": \"superAdmin\" } ]To sort it by user's names in ascending order (alphabetically), we would use the sort formula this way:"
  },
  {
    "h1": "Conditional formulas​",
    "url": "https://docs.weweb.io/formulas/conditional.html",
    "content": "Conditional formulas ​Conditional formulas are a way to test for truthiness or falsiness of variables or comparisons and return a different value according to this.if ​if takes 3 arguments, in order:condition the variable or comparison to test truthiness onvalue1 the value to return if the condition is truthyvalue2 the value to return if the condition is falsyExample ​Here, we're using the if formula with a variable (display modal) as a condition. The formula will test if the varibale is true, and because it's false in this case, it'll return the second value.ifEmpty ​Use case ​The ifEmpty formula is used to check if a given value is empty or not.If the value is empty, it returns a specified fallback value. If the value is not empty, it returns the original value.Syntax ​The basic syntax of the ifEmpty formula is: ifEmpty(first_parameter, second_parameter)The first parameter is the value you want to check.The second parameter is the value to return if the first parameter is empty.Examples ​Let's say you want to check if user_input is empty and return \"Default Value\" if it is, the formula would be: ifEmpty(user_input, \"Default Value\")If user_input has a value, the formula will return that value.If it is empty, it will return \"Default Value\".Here's the ifEmpty formula in action to check if a collection has returned items or not:not ​The not formula takes a variable or camparison, and return the opposite boolean value.Ok, so what does it means? 😆If a variable or comparison is truthy, it will return false. If a variable or comparison is falsy, it will return true.So, this formula is useful when you need to invert a condition.Example ​In this example, we apply not to the display modal from before, which is false. So the return value is true.If we take back the example from the if formula, it will now return the first value as the comparison is now not(false), so true.switch ​The switch formula takes an expression, then checks its equality with each value and return the matching result.Example ​Here, switch takes the variable user location as a an expression, which equals to \"USA\". It'll then loop over values, match the one which equals \"USA\" too, and return the matching value, which is Hello from the US 👋\"."
  },
  {
    "h1": "Date formulas​",
    "url": "https://docs.weweb.io/formulas/date.html",
    "content": "Date formulas ​Date formulas are useful to manipulate date objects inside WeWeb.Date plugin ​In order to access no-code date formulas, you'll first need to add the Date extension plugin:TIPWhen you install the Date plugin, we add the Day.js library to your WeWeb project.It's a small 2kB library but we don't include it by default because not every project needs to work with dates and we don't want to add the weight of the library on projects that don’t need it.Once you have added the Date plugin, you'll be able to see all the related no-code formulas in the explorer tab:Favorite date format ​In order to display dates in a uniform way throughout your project, you can configure your favorite date format at plugin level:TIPWorking with dates can be tricky at first. If you get stuck on formatting, we recommend you to through this article on the ISO date format.date ​If you use date in a formula with no parameters, you will get the current date and time in Coordinated Universal Time (i.e. the UTC timezone).The no-code date formula can take the same parameters as the JavaScript newDate() function.dateRealtime ​Same as date, dateRealtime will return the current date and time in Coordinated Universal Time (i.e. the UTC timezone).That date, however, will be updated every second in real-time:toDateISO ​This formula allows you to set a date in ISO format:the first parameter of the formula should be a date,the second parameter is the format you want to display the date inTIPIf you have configured a favorite date format at plugin level, the second parameter of the toDateISO formula is optional:formatDate ​This formula allows you to format a date:In the example above, you see:first we start with a date formula that returns a date in ISO format,then we wrap the formatDate formula around it to display the date in the preferred format we configured at plugin level,we add a second parameter to the formatDate formula to display the date in a different format,finally, we change the display language to Spanish.toTime ​This formula calculates the time between now and X, and returns the information in text format:In the toTime formula, the relative time compares the date now, to the date in the first parameter.For example:Today, August 23rd, 2023 was \"2 months ago\"Today, August 23rd, 2024 is \"in 10 months\"The formula will accept the following parameters:a date in ISO format (required),whether to display the suffix or not (optional), andthe language in which the text should be displayed (optional)fromTime ​This formula calculates the time between X and now, and returns the information in a text format.In the fromTime formula, the relative time compares the date in the first parameter, to the date now.For example:On August 23rd, 2023, today was \"in 2 months\"On August 23rd, 2024, today will be \"10 months ago\"The formula will accept the following parameters:a date in ISO format (required),whether to display the suffix or not (optional), andthe language in which the text should be displayed (optional)compareDate ​This formula allows you to compare two dates:You can count the number of:years (year or y),quarters (quarter or Q),months (month or M),weeks (week or w), etc.TIPWhen you hover over a no-code formula name in the WeWeb, you can view tooltips on what parameters and values it expects.By default, the result of the compareDate formula will be a round number.If the floating parameter is true, you can see decimals in the calculation. For example, there are 4.6 months between November 4th, 2023 and March 23rd, 2024:toTimestamp ​The toTimestamp formula expects a date in ISO format and will return the timestamp value for that date in a number format:getBrowserTimezone ​The getBrowserTimezone formula will return the timezone your user's browser is in.convertDateTimezone ​The convertDateTimezone formula allows you to display a different date and time depending on the user's timezone.The first parameter must be a date that contains time and timezone information.For example, the date formula returns the date and time in the UTC timezone. Here, we are converting the current date and time to the date and time in New York:By default, or if you add false as a third parameter, the result will show the date and time in the new timezone.You can, however, choose to preserve the date and time of the original timezone:formatDateTimezone ​The formatDateTimezone formula allows you to take a date provided in ISO format, and display it:in the format of your choice, e.g. \"MMMM D, YYYY - HH:MM\"converted to the timezone of your choice, e.g. \"America/Mexico_City\"in the language of your choice, e.g. es for SpanishTroubleshooting ​Working with dates can be tricky at first.Here are a few things to consider when a date formula is not behaving as you would expect:ISO date values and date formats should be strings. Make sure to enclose them in between quotes \"like_this\"Timestamp values should be numbers. If you are storing timestamps in a text format, use the toNumber formula around it to convert it so the date formulas can work with itISO date formats are easy to mess up. When in doubt, check out this article with numerous examples of ISO date formats"
  },
  {
    "h1": "Intro to formulas​",
    "url": "https://docs.weweb.io/formulas/intro-to-formulas.html",
    "content": "Intro to formulas ​To manipulate data in your frontend, you can use WeWeb formulas.Common examples include but are not limited to:filtering a list of items,formatting text, orchanging a style based on conditions.Binding formulas ​You can use WeWeb formulas in any binding:In the example above, you can see:we opened the binding explorer,went to the formula tab to look for the pre-built switch formula, andwrote a formula directly in the explorer to format the text on the page based on the value of item in our collection.This formula is local in the sense that, if we wanted to use it elsewhere in our app, we would have to re-write or copy/paste it.Create a global formula ​As your app grows in complexity, we recommend you build global formulas in the Actions tab that you can then use throughout your app:In the example above, you can see:in the Actions tab,we created several global formulas,the formatNumber_nocode formula takes a Text input that expects a numberin the binding explorer, global formulas can be found in the From project section of the formula tabBind to a global formula ​Global formulas are helpful because you can use them everywhere:In the example below, you can see:we opened the binding explorer to a text element,went to the formula tab,used our global formatNumber_nocode formula, andbuilt on top of it to format additional text.Global vs local formulas ​In some cases, it makes sense to create formulas that are scoped to a specific element or component.In other cases, it's helpful to create global formulas that you can reuse throughout your app.As a general rule, if you catch yourself re-writing or copy/pasting formulas multiple times, it's a sign you might want to create a global formula instead because, if you need to debug or improve it down the line, you can do it in one place.In addition, using global formulas will allow you to see which ones are being used on a page:"
  },
  {
    "h1": "Math formulas​",
    "url": "https://docs.weweb.io/formulas/math.html",
    "content": "Math formulas ​Math formulas are a way to do mathematics operations inside your WeWeb formulas.average ​The average formula takes any number of values, variables of arrays (that are of type Number) and returns the average of all of these values (or the values inside the variables or arrays).Example ​Here, both examples show the result of the average of the numbers 2, 3, 5 and 3, which is 3.25.rollupSum ​This formulas loops over an array of object, and in each object, will take the value for a specific key and sum all of these values.Example ​Here, we use a variable called user orders which equals an array of objects. Let's see its content:json[ {\"name\": \"Quentin\", \"orders\": 3}, {\"name\": \"Kevin\", \"orders\": 2}, {\"name\": \"Joyce\", \"orders\": 1}, {\"name\": \"Damien\", \"orders\": 5} ]We'll tell rollupSum to loop over user orders, take the orders key in each object, and sum all of them. And the sum of 3 + 2 + 1 + 5 is indeed 11.round ​This formula will round the value given to it (could be a variable, but it needs to be a number). The precision of this rounding (meaning the number of decimals) can be set as a second parameter, which is zero by default.Example ​In this example, we round the number 3.265 with a precision of zero (meaning to the nearest integer), and then with a precision of 1 (meaning 1 decimal).sum ​This formula will sum all the values given to it (they should be all of type number). These values can be multiple variables or an array of numbers.Example ​Here, we'll sum the numbers 2, 3, 5 and 3 to give 13. In the second example, these values are given through a variables which is an array of these values.toNumber ​The toNumber formula will convert a string to a number, when possible.It can work with strings containing integer or decimal numbers. The decimal character has to be a dot (.) as the function is based on English notation.🔥 Pro tip 🔥 ​This formula is useful when you need to send a number to your backend, or du computation on numbers, but when the number is cast as a string initially. This can happen when you get the number from another API where it's sent as a string, or when using a value from a form input.Example ​In this example, we'll convert a string to a integer and then another string to a decimal. Watch how strings were converted as the result isn't enclosed in \" anymore, meaning it's indeed a number now."
  },
  {
    "h1": "Object formulas​",
    "url": "https://docs.weweb.io/formulas/object.html",
    "content": "Object formulas ​Object formulas are useful to manipulate objects inside WeWeb.createObject ​This formula helps you create JavaScript objects using nocode. List pairs of keys and values that will be transformed into an object.Example ​Let's say we want to create this object using a formula:js{ name: \"quentin\", age: 29, job: \"growth\" }We would do it in WeWeb like so:getKeyValue ​This formula will return the value for a given key in an object.Example ​Taking back our previous object, now stored in a person variable:js{ name: \"quentin\", age: 29, job: \"growth\" }Let's say we want to get back the value for the job key. We would do it like this:compare ​This formula will check if two objects are equal, meaning if they have the same key and values.Example ​keys ​The keys formula will return all keys from a given object as an array.Example ​Using our previous person object:js{ name: \"quentin\", age: 29, job: \"growth\" }Using the keys formula will give us:omit ​Given an object, this formula will return it without some listed keys.Example ​Using our previous person object:js{ name: \"quentin\", age: 29, job: \"growth\" }Let's say we want to remove the age from it. We'll use omit for this:pick ​This formula will do the exact opposite as omit. Meaning it will return an object with certain given keys only.Example ​Let's say we want to do the same as the previous example, but using pick. We would do:setKeyValue ​setKeyValue will add a given key with a given value to an object.Example ​Using our previous person object:js{ name: \"quentin\", age: 29, job: \"growth\" }We want to add a country key to it. Here's how we would do it:values ​This formula will return all the values from a given object as an array.Example ​Using our previous person object:js{ name: \"quentin\", age: 29, job: \"growth\" }Here's how to list all of the values:"
  },
  {
    "h1": "Operators​",
    "url": "https://docs.weweb.io/formulas/operators.html",
    "content": "Operators ​= ​Check the equality between two values. It's the nocode equivalent of JavaScript's ==.Example ​!= ​Opposite of =. Check for inequality between two values. Equivalent of JavaScript's !=.Example ​and ​This is a logical AND, that will return true only if all operands are also true or return the first falsy operand if any, otherwise the last truthy operand. Equivalent of JavaScript's &&.Example ​or ​This is a logical OR, that will return true if at least one of the operands is also true, or return the first truthy operand/ Equivalent of JavaScript's ||.Example ​+ ​This operator will add two numerical values together, or concatenate string values. Equivalent or JavaScript's +.Example ​"
  },
  {
    "h1": "Text formulas​",
    "url": "https://docs.weweb.io/formulas/text.html",
    "content": "Text formulas ​Text formulas are useful to manipulate strings (text data) inside WeWeb.capitalize ​This formula will capitalize each word inside a string, meaning it'll replace the first letter of each word by its capitalized counterpart.Example ​concatenate ​The concatenate formula will regroup multiple strings intro one. It's like adding texts to each other.Example ​contains ​This formula will return a boolean (true or false) according to if a text is present inside another one.Example ​indexOf ​indexOf will return the index of the position of a substring inside a text. If the substring isn't in the initial text, it will return -1.Example ​Let's take the text \"hello world\", if we were to search the position of the substring \"world\" inside it, indexOf will return 6 as \"world\" begins on the sixth index (remember, spaces and special characters do count in strings!).lower ​This formula will lowercase a given string.Example ​split ​The split formula will separate a text into an array, based on a given separator.Example ​subText ​Given a certain text, this formula will return part of it from a given startIndex up to an optional endIndex (not included).Example ​textLength ​The textLength formula will return the length of a text, meaning its number of characters (spaces and special characters included).Example ​toText ​Given a number, a boolean or an array, this formula will return it as a text value.Example ​uppercase ​This formula will return an uppercased version of a string.Example ​"
  },
  {
    "h1": "Utils formulas​",
    "url": "https://docs.weweb.io/formulas/utils.html",
    "content": "Utils formulas ​toBool ​Given a value, this formula will return a boolean value (true or false) based on the value truthiness of falsey-ness.Example ​"
  },
  {
    "h1": "Library dependencies​",
    "url": "https://docs.weweb.io/libraries/dependencies.html",
    "content": "Library dependencies ​What is a dependency? ​In web development, encountering dependencies is inevitable when working with libraries.When using WeWeb libraries, there are three types of dependencies to be aware of:Plugin dependencies.Library dependencies.Coded component dependencies.When you publish, add or update a library in WeWeb, it's important to be aware of these dependencies.In the example below, you can see that this library has two dependencies, one to the Date plugin, and one to the Starter Kit library:Plugin dependencies ​A plugin dependency occurs when a component, class, or template within the library relies on a plugin.For example, if Library A includes a date picker component that requires the Date plugin, you'll need to add the Date plugin to your project for Library A to function correctly.Library dependencies ​A library dependency occurs when one library depends on another library.For example, if Library C uses items from Library D (such as templates, classes, colors, etc.), you'll need to add Library D to your project to fully leverage Library C's capabilities.Coded component dependencies ​A coded component dependency occurs when the library uses a specific version of a coded component.For this type of dependency, there is no action required on your side. When you add or update a WeWeb library that uses coded components, we will automatically import or update the coded component to your project."
  },
  {
    "h1": "Import Figma styles​",
    "url": "https://docs.weweb.io/libraries/figma-styles-import.html",
    "content": "Import Figma styles ​Add WeWeb plugin in Figma ​In order to import styles from Figma or any other source, you have to install our plugin in Figma:LOOKING TO IMPORT A FIGMA DESIGN?The present article is about importing Figma styles to a WeWeb library. With our plugin, you can also import Figma designs on a WeWeb page.Learn how to import a Figma design.Export Figma style ​In your Figma project, open the plugin and select whether you want to import colors or typography:Clicking on generate will store the exported styles to your clipboard.Import style to WeWeb ​To import the copied styles to WeWeb, navigate to the Library panel and click on the Figma icon.All you have to do next is paste your output from Figma to the input and click on Import styles:After you receive message of a successful import, you will find your styles in the library:Importing from other sources ​If importing typography from other sources, input needs to be formatted as displayed in the sample input below.Typography ​json[ { \"type\": \"typo\", \"name\": \"Typography/Heading 1\", \"fontSize\": \"64px\", \"lineHeight\": \"72px\", \"fontWeight\": \"Medium\" }, { \"type\": \"typo\", \"name\": \"Typography/Heading 2\", \"fontSize\": \"48px\", \"lineHeight\": \"56px\", \"fontWeight\": \"Semi Bold\" }, { \"type\": \"typo\", \"name\": \"Typography/Heading 3\", \"fontSize\": \"32px\", \"lineHeight\": \"40px\", \"fontWeight\": \"Medium\" } ]Colors ​json[ { \"type\": \"color\", \"name\": \"Light/Background/bg\", \"value\": \"#ffffff\" }, { \"type\": \"color\", \"name\": \"Light/Background/bg-secondary\", \"value\": \"#f7f7f7\" }, { \"type\": \"color\", \"name\": \"Light/Background/bg-tertiary\", \"value\": \"#ebebeb\" } ]"
  },
  {
    "h1": "Intro to libraries​",
    "url": "https://docs.weweb.io/libraries/intro-to-libraries.html",
    "content": "Intro to libraries ​A library is a collection of reusable design assets and UI elements that helps you build applications faster while maintaining consistency. It includes typographies, colors, spacings, components, templates, and classes that can be shared across your workspace and reused across different projects. It is essentially a way for you to build your design system.WARNINGIn our previous UI, you would access the Library panel via Libraries in the top bar. However, this has now been replaced by the Assets menu in the top bar. Please keep this in mind if you still see mention of the Libraries button in the top bar throughout our documentation.Why use libraries ​Colors, spacings, and typographies allow you to build user interfaces with a consistent look-and-feel, while templates and components help you build faster.To access the library of your project:Open the Assets menu in the top barClick LibraryYou will now see the library of your project:If you start with a blank project, it will be empty but you can add:Components.Templates.Classes.Spacings, colors, and typographies.TIPEach WeWeb project has its own library, but you can:share that library with the rest of your workspace, andadd other libraries from your workspace to a project.Learn more about sharing libraries in WeWeb.Typographies ​In the fourth tab of the Library panel, inside the Typographies section, you can create and edit typographies so that all text elements bound to a typography are updated accordingly when a typography is updated:In the example below, you can see:In the Typographiessection, we created the Small typography in the Label folder.We bound that typography in the Styles tab of the selected text on the page.TIPWhen creating a typography, we recommend using a default font:That way, users will be able to use the library without needing to add a specific font to their project.If you associate a typography to a specific font, users will need to have that font installed in their project for the library to work as expected. Otherwise, when the project is published, the font displayed on the page will fall back to the browser's default font.Colors ​In the fourth tab of the Library panel, inside the Colors section, you can add and organize colors that you can then bind to the CSS color property in the Styles tab of the right panel.In the example below, we bound the text of one of our labels to the Blue 600 color in our project library:You can also use library colors in formulas:In the example above, the text color will be different if it's in a primary or secondary button.Spacings ​In the fourth tab of the Library panel, inside the Spacings section, you can add and organize spacing styles that you can then bind to the CSS properties in the Styles tab of the right panel:In the example above, we bound the corner radius of our label container to a 16px spacing.Classes ​In the third tab of the Library panel, you will be able to see all the style classes in your library.While you won't be able to rename or delete classes through this panel, it can be helpful to get an overview of what classes are used in an external library or to check if a class is attached to a specific library.Learn more about working with CSS classes in WeWeb.Components ​In the first tab of the Library panel, you will find reusable components that you can use to build a UI that has a consistent look-and-feel, without having to no-code the same functionalities multiple times.Learn more about WeWeb components.Templates ​In the second tab of the Library panel, you will find section and element templates that you can use as UI building blocks to design the frontend of your apps faster:How to add a template in a library ​To save an element or section as a template, select it on the page, and click on the Save to library icon:How to add a template on a page ​Once you have saved templates to your project library, you will be able to drag-and-drop them on the page.Go to Add > Assets to view available templates and components:TIPElements with a green icon are components.Rename library item ​In the Library panel, select the tab where the item is located, select the item you wish to rename, rename it and save it:Delete library item ​In the Library panel, select the tab where the item is located, hover over the item you want to delete, click on the three dots next to it and click on delete:Templates vs components ​When you drag-and-drop a template on a page, it will create a copy of the template. If you later make a change to the template, those changes will not be reflected in the copies you created before.When you drag-and-drop a component on a page, it will create a new instance of the component. If you make a change to the component, those changes will be reflected in all the instances of the component you created before."
  },
  {
    "h1": "Intro to the marketplace​",
    "url": "https://docs.weweb.io/libraries/intro-to-the-marketplace.html",
    "content": "Intro to the marketplace ​The WeWeb marketplace allows you to:work with marketplace UI kits & templatessubmit your templates or UI kits to share with othersImport a project ​To start working with a template or UI kit from the marketplace, simply:go to your WeWeb workspace,click on Create project,select the Marketplace tab,search or browse through available projects, andclick on Create project when you want to add it to your workspace.Once you have added the project to your workspace, you can start working with it as you would with any other project from your workspace.TIPA library imported from the WeWeb marketplace works like any other library. If you wish to use it in other projects, you will first need to share it with the rest of the workspace.Learn more about working with shared libraries in WeWeb.Submit a project ​To submit a template or UI kit to the WeWeb marletplace:visit marketplace.weweb.io,select the workspace with the teamplate or UI kit you'd like to submit,create a marketplace profile for this workspace (if you haven't already), andfill out the submission form with the required information."
  },
  {
    "h1": "Share libraries​",
    "url": "https://docs.weweb.io/libraries/share-libraries.html",
    "content": "Share libraries ​In WeWeb, you can work with shared libraries.These libraries can come from other projects in your workspaces, or from the WeWeb marketplace:Common use cases for working with shared libraries include but are not limited to:Leveraging popular libraries to build faster, similar to how you'd leverage Tailwind or Bootstrap in the code world.Working with a single UI kit across multiple projects for a company that requires you to follow strict brand guidelines.Share a library ​To share a library with the rest of your workspace, you will need to:open the project where you built the library you want to sharego to Libraries and click on Sharename your commitAdd a shared library ​Go to Libraries and click on the little book icon to view Available and Marketplace libraries.The Available tab lists:all the libraries that have already been added to the current project, including marketplace libraries.all the libraries that have been shared in your workspaces but haven't yet been added to the current project.The Marketplace tab lists all the libraries from the WeWeb marketplace that can be added to the current project.To start using one of these libraries in your project, simply click on Add:This will move the library up to the Added section of the panel in the Available tab, like the \"Habit tracker\" library in the example above.WARNINGCan't find the library you're looking for?Open the project with the source library you're looking for, go to Libraries and click on Share as described in the \"Share a library\" section above.Remove a library ​To remove an external library that you added to a project, go to Libraries and open the shared libraries panel.In the Added section, select the library you want to remove, open the three dot options menu, and click on Remove from project:Update a shared library ​Whether you are sharing a library with others or working with an external library others shared with you, you will want to make changes and updates at some point.There are three steps to updating a shared library:make the changes in the librarypublish those changes so they are available to other projects in the workspaceupdate the library in the projects that use it1. Make changes to a shared library ​To make changes to a shared library, simply go to that projects and make all the changes you want.For example, you could edit a typography, add or delete spacings, templates, or components.2. Publish changes of a shared library ​Once you are ready to commit those changes to make them available to other projects in the workspace, you can click on Share, fill out the form, and complete the publish :TIPTry to be descriptive when adding a commit message to library updates.This will help users of your library understand what's new and how a library update might affect their projects.3. Update the library in the projects that use it ​Once the changes to a library have been shared to the workspace, you will see a notification in the projects that use it.When you're ready, you can go to Libraries, open the shared libraries panel, and update the relevant library:Use library versions ​At times, you may want to rollback or rollforward to different versions of a shared library.You can do this by going to Libraries, opening the shared libraries panel, clicking on the three dot options, and Change version:"
  },
  {
    "h1": "Starter Kit​",
    "url": "https://docs.weweb.io/libraries/starter-kit.html",
    "content": "Starter Kit ​Why use the Starter Kit? ​To help you build faster, we built a Starter Kit library that you can use throughout your projects.Whenever you create a new blank project, you will be able to access all the related UI elements in the Add menu, under the Assets category:In the example above, we added the Heading component from the Navigation category of the Starter Kit assets.What's included ​The Starter Kit includes, but is not limited to:typographies for headers, labels, footnotes, and body,spacings for radiuses and containers,brand and functional colors,classes for buttons,components, andtemplates.Starter Kit versions ​We regularly add and update assets in the Starter Kit to help you build projects with a consistent look-and-feel, faster.To work with the latest Starter Kit version, open the Libraries panel, view available libraries and update the Starter Kit:TIPWhen working with libraries to develop your web-app, whether you're using WeWeb or custom code, you may encounter breaking changes.When that happens, you may decide to update the (no)code in your web-app to work with the library update or choose to continue working on an older version of the library.The WeWeb Starter Kit library is no different.If needed, you can rollback to a previous version of the Starter Kit library:Remove the Starter Kit ​By default, the Starter Kit is added to new blank projects to save you time and help you build faster.However, if you do not wish to work with the WeWeb Starter Kit, you can remove it from the project all together:TIPIf you change your mind, you can always go to the Marketplace tab of available libraries to add it again later:WARNINGWhen you remove a library from a project, its assets will no longer be available in the project.As a result, you may see warnings informing you that a component from a library is missing:This warning is there to inform you that you removed a library that was being used inside the project. Consider adding it back to solve the issue."
  },
  {
    "h1": "404 page​",
    "url": "https://docs.weweb.io/pages/404-page.html",
    "content": "404 page ​When users of your app try to access a page that doesn't exist, it is best practice to redirect them to a custom 404 page.Page with 404 path ​In order to do this, you'll need to create a new page with 404 as the slug:Then, whenever a user tries to access a page that doesn’t exist, WeWeb will automatically redirect them to that page.Customize 404 page ​By default, this page will be empty but you can customize it like you would any other page.In the example below, we let the user know they're lost and give them an option to navigate back to our homepage:"
  },
  {
    "h1": "Dynamic collection pages​",
    "url": "https://docs.weweb.io/pages/dynamic-collection-page.html",
    "content": "Dynamic collection pages ​OverviewDisplay data from a specific item on a dedicated page.Example: We have a list of characters of Rick and Morty and a dynamic page to show character details of a specific character.Two Options for Creating a Dynamic Collection Page ​Bind to variable dataBind to collection dataIn WeWeb, binding consists of displaying external data in your app. This is often parsed JSON coming from 3rd-party APIs or tools like Airtable or Xano.When bound, the data is displayed in the app. It can be displayed as text, as an image, as a link, as a list, etc. Every time the data is updated, the app is updated too.For more details check out the binding data article.Option 1: Binding dataThis method involves binding the page content directly to a variable. When a user accesses the page, the content is retrieved from this variable. Instead of making an API call to our back end and waiting for its response, we simply update a local variable and display that data on our dynamic page.For example, instead of making an API call to fetch data, you might set a variable with data received from another page. This can be quick and efficient but has limitations.Downside: If a user tries to access that URL directly to the page without going through the initial step that updates the variable, they will land on a page with no information because the variable will be empty.Option 2: Bind to collection dataIn this approach, the page content is bound to data retrieved from a collection.When a user accesses the page, the data is fetched from the collection, ensuring the content is up-to-date and displayed.This method is more reliable, especially for scenarios where users might access the page directly without going through a specific sequence.Choosing the Right Approach: Dynamic Collection Pages offer flexibility in displaying content based on various criteria. In many use cases, you will want to make an API call to your backend to get the information from the specific item you want to display on the dynamic collection page.What you’ll need2 PagesA template page to display dynamic dataAn initial page with items (for this example, we will use a page with a table of data)PluginsInstall Rest API (a data source to display data)Bind to variable data ​Step 1: Create a dynamic collection pageCreate a template page of the information you want to display.Here’s a basic example of a page for the character details. The page has sections for texts, a picture, and a back button to return to my initial page of items.After you create the dynamic collection page, navigate to the initial page with the items you want to have on the dynamic collection page.For this example, we’re starting with the Rick and Morty Database page with all the show's characters.Step 2: Add a Variable WorkflowStep 3: Bind the Information on the Dynamic Collection PageGo to the template page and bind the information found in the variable.For our example, we’ll bind the following information: Name of character, picture of the character, species of character, and location.Congratulations! 🥳 You just created a dynamic collection page using the bind to variable data!Bind to collection data ​Step 1: Create a dynamic collection pageCreate a template page of the information you want to display.Here’s a basic example of a page for the character details. The page has sections for texts, a picture, and a back button to return to my initial page of items.After you create the dynamic collection page, navigate to the initial page with the items you want to have on the dynamic collection page.For this example, we’re starting with the Rick and Morty Database page with all the show's characters.Step 2: Create a New CollectionTo retrieve a specific character instead of the entire collection, create and configure a new collection as an API endpoint for a GET call.Step 3: Bind Data on the Dynamic Collection PageStep 4: Add a variable to the URL path on our template pageStep 5: Add the parameter to the API callStep 6: Link to collection page with dynamic id🥳Congratulations! You just created a dynamic collection page using the bind to collection data!TIPIf the dynamic collection does not update when fetched, turn off Fetch collection automatically for the collection.On the template page, create an action, to Fetch a collection action On page load workflowDetailsIf the dynamic collection does not update when fetched, turn off Fetch collection automatically for the collection.On the template page, create an action, to Fetch a collection action On page load workflow"
  },
  {
    "h1": "Metadata for dynamic pages​",
    "url": "https://docs.weweb.io/pages/dynamic-page-metadata.html",
    "content": "Metadata for dynamic pages ​Use case ​When creating dynamic pages in WeWeb, such as www.myapp.com/article/1, all pages share the same metadata configured in the Editor:However, depending on your use case, you may need different metadata (title, description, keywords, and thumbnails) for each page based on the URL parameter (e.g. for example a unique blog article slug, product id, or event id).In the videos below, we'll show you how to deploy dynamic metadata for your dynamic collection pages in a way that follows best-in-class SEO standards.WARNINGThis is an advanced technical workaround for cases where you don't want to use static collections. Since this isn't WeWeb's primary use case, we don't provide official support for this implementation.Benefits and pre-requisites ​WeWeb setup ​Backend setup ​TIPIn the video above, we are using Xano as an example but similar logic applies no matter what backend you are working with.What's important is that you have an API endpoint that returns page metadata in the following format:json{ \"title\": \"Festival\", \"description\": \"Test Our annual festival is back, promising an array of activities for every age and interest. From thrilling amusement rides and live performances to a marketplace brimming with handcrafted goods, there's joy and discovery around every corner. Learn from artisans during workshops, indulge in diverse culinary delights, and immerse yourself in the festive atmosphere that celebrates our community's spirit.\", \"image\": \"https://xeo6-2sgh-ehgj.n7.xano.io/vault/UUJkO96O/eQbZuT4a7I7Iks60ScIyEXlKZ-s/u16buw../hanny-naibaho-aWXVxy8BSzc-unsplash.jpg\", \"keywords\": \"festival music live\" }Cloudflare setup ​GitHub setup ​Here's the link to the GitHub repository you'll need to fork as described in the video below:WARNINGSince we first recorded the video above, we updated the worker to support dynamic metadata on multiple pages, not just one.This changes how you work with the config file of the worker.In the first version of the worker shown in the video above, the patterns variable of the worker expected an object. Now, it expects an array of objects.In the example below, we are configuring dynamic metadata for an event page and a team profile page:jsexport const config = { domainSource: \"https://f69a71f6-9fd8-443b-a040-78beb5d404d4.weweb-preview.io\", // Your WeWeb app preview link patterns: [ { pattern: \"/event/[^/]+\", metaDataEndpoint: \"https://xeo6-2sgh-ehgj.n7.xano.io/api:8wD10mRd/event/{id}/meta\" }, { pattern: \"/team/profile/[^/]+\", metaDataEndpoint: \"https://xeo6-2sgh-ehgj.n7.xano.io/api:LjwxezTv/team/profile/{profile_id}/meta\" } // Remove or add more patterns and their metadata endpoints as needed ] };This means that, even if you are only setting up dynamic metadata on one page, the patterns variable should be an array with one object inside.In the example below, we are configuring dynamic metadata for only one page:jsexport const config = { domainSource: \"https://f69a71f6-9fd8-443b-a040-78beb5d404d4.weweb-preview.io\", // Your WeWeb app preview link patterns: [ { pattern: \"/event/[^/]+\", metaDataEndpoint: \"https://xeo6-2sgh-ehgj.n7.xano.io/api:8wD10mRd/event/{id}/meta\" } // Add more patterns and their metadata endpoints as needed ] };Deploy & redirect ​We're now ready to deploy our Cloudflare worker and redirect it to our custom domain name:Final checks ​Alright, your app should be ready to go now. This tutorial being on the more technical side, don't hesitate to reach out in the WeWeb Community if you get stuck. We'll do our best to help out."
  },
  {
    "h1": "Intro to pages​",
    "url": "https://docs.weweb.io/pages/intro-to-pages.html",
    "content": "Intro to pages ​A page is the distinct screen that appears when visitors go to a specific web address (URL) on your web app. Each page shows different information and features, like how a \"Contact\" page displays contact details while an \"About\" page shows company information.Create a page ​Here's an interactive tutorial on how to create a page:Let's go over all the steps:Open the page dropdown in the top navbarClick on Add pageName your pageDecide if you want to copy content from an existing pageIf copying from another page, decide if you want some sections to be linkedClick on Create to create the pageTIPLinked sections are referred to as Multi-page sections in WeWeb. They are useful to improve the user experience and page loading time of your web application.Learn more about using multi-page sections in WeWeb.Page name ​The name of the page. This is the name that you will see in the page panel:Page folder ​The folder that the page is in. You can create folders to organize your pages:Draft mode ​Pages with draft mode Enabled won't be included when you publish your WeWeb app.Pages that are in draft mode can be identified by a different color in the Pages panel:WARNINGChanging a page's Draft mode setting only takes effect after you (re)publish the app.For example, if the app was published when Page A had draft mode set to Disabled, changing the draft mode of Page A to Enabled in the WeWeb Editor won't remove the page from production until you publish the app again.Url paths ​This is where you can change the path of the page. This is the path that your users will see in the URL bar when they visit the page.You can also add variables to the path.For example, if you add a variable called product_id to the path, you can access the value of the variable in the page by using the From path in current page section in the data explorer:TIPAdding variables is helpful to create detail pages for your collections. For example, if you have a collection called products, you can create a page called products/{product_id} and then use the product_id variable to display the details of the product.Learn more about dynamic collection pages.Trigger workflows ​This is where you can setup the workflows that will be triggered when the page is visited.In the example below, before we fetch the collections present on the page, we trigger a workflow to update the current user's preferences:You can trigger page workflows:on app load before fetching collections,on page load before fetching collections,on app load,on page load,on page scroll,on page resize,on collection fetch error,on page unload.Use cases include, but are not limited to:reacting to a user scrolling up or down the page,updating a variable before a collection is fetched,checking for a Stripe purchase after a page is loaded,manipulating collection data before displaying it on the page,displaying a customized error message when a collection fetch fails, etc.Custom code ​This is where you can add custom code to the page.You can add custom code either:in the page header, so that the code is loaded right before the page is loaded (useful to add custom CSS or JS, but hurts SEO performances).in the page body, so that the code is loaded right after the page is loaded (useful for tracking scripts, doesn't hurt SEO performances).TIPWhen you add custom code at page level, the code is only added on that page.If you want to install app-wide custom code, you can do it in the Custom code section in the Settings panel.Learn more about adding custom code at app level.WARNINGWhen you add custom CSS to a page or project, you should not add any <head> or <body> tags. WeWeb handles those tags for you.Languages ​In the Languages panel, you can:Add languages to your projectDefine the default language of your projectDecide if you want to add the default language slug to the URL path of the current pageDecide which languages should be enabled on the current pageToggle between active languages to preview the page content in different languagesAssuming you have multiple languages enabled on a page:all the text elements on the page will invite you to provide the content in those languagesyou can then toggle between languages, andthe appropriate text will be displayedDuplicate ​Here, you can duplicate the page. This is useful if you want to create a page that is similar to another one, but with different content.The Duplicate page panel provides the same options as the Create new page panel with the Copy from option selected:Create collection page from ​Here, you can create a static collection page:Static collection pages are helpful if you want to publish collection pages with pre-rendered content.WARNINGTo create a static collection page, you will need to bind the Page collection and Page default path to a static collection.Learn more about static collection pages and dynamic collection pages.Make {page} the homepage ​Here, you can make the current page the homepage of your app. The homepage is the page that will be displayed when you access the root URL of your app.Remove page ​Here, you can delete the page. This is useful if you want to remove a page from your app:"
  },
  {
    "h1": "Multi-page sections​",
    "url": "https://docs.weweb.io/pages/multi-page-sections.html",
    "content": "Multi-page sections ​WeWeb apps are SPAs ​When you publish a WeWeb app, you publish a standard Vue.js Single-Page Application.Single-Page Applications are great to build smooth user experiences where users can navigate seemlessly between different views in the app.TIPCompared to Multi-Page Applications, SPAs achieve increased speed and responsiveness because, instead of loading all the content of a page on page load, it only loads new content.For example, when a user navigates from page A to page B, the navigation menu that was loaded when the user arrived on page A is not loaded a second time when they arrive on page B.To leverage that feature of Single-Page Applications in WeWeb, you would need to create a new instance of a multi-page section.Multi-page sections ​In WeWeb, you can add multi-page sections by going to the Add > Multi-page sections menu:Once you're on the Multi-page sections menu, you can drag a section that exists on one page, and drop it on the current page.When you do this, you will be invited to choose between creating an instance or creating a copy of that section:Benefits of instances ​When you create a new instance of a section, the changes you make on one instance of the section will be reflected in all the other instances of that section.Create a new instance if you want the section to remain the same on all pages no matter what changes you make.When you publish your app, the section will be loaded once. Other instances of the section will not be reloaded.Benefits of copies ​When you create a new copy of a section, the changes you make in the original will not be reflected in the copy, and vice versa.Create a new copy if you want to take inspiration from an existing section but want the new section to be independent of the other.When you publish your app, both sections will be loaded.Instance vs copy example ​In the example below, you can see that we chose to:create a new instance of the sidebar menu because we don't want to have to reload this menu when the user navigates to a new page,create new copies of the header and content sections because these sections will be different on each page and should be loaded when the user navigates to the new page"
  },
  {
    "h1": "Navigation​",
    "url": "https://docs.weweb.io/pages/navigation.html",
    "content": "Navigation ​Navigation is a system that enables users to move between different pages and sections of a website or application. You can think of it as the way users move around your web app - whether it's clicking a menu item to visit the Products page, using the back button to return to a previous page, or selecting a product to view its details. This is how users find and interact with different parts of your application.Understanding URL paths ​URL paths are the addresses of your pages - what users see in their browser's address bar. Think of them as street addresses for your website - they help users find exactly where they want to go.Simple URLs ​When you create a page in WeWeb, it automatically gets a simple URL. These URLs are straightforward and static, meaning they don't change.For example, in the URL https://yourdomain.com/products:yourdomain.com is your domain (your website's main address)/products is the path to your specific pageSome examples of simple URLs:URLDescription/aboutYour About page/productsYour Products page/contactYour Contact pagePath may only contain 'a-z', '0-9', '_', '-' and '/', and can only start and end with 'a-z' or '0-9'.Dynamic URLs ​Sometimes you need URLs that can change based on what content you're showing. These are called dynamic URLs, and they use parameters to change parts of the URL.For example, in https://yourdomain.com/products/category/smartphones:/products/category is your base path (static part)/smartphones is a category parameter (dynamic part)Setting up dynamic URLs ​Select your page from the Pages panelClick on \"URL paths\" in the page settingsIn the URL paths panel, you'll see: English unique path: This is where you set up your URL structureParameters: These are the parts of your URL that can changeTIPA dynamic product page URL might look like:Template: products/category/{{param}}Real URL: products/category/smartphonesAnother URL: products/category/beautyParameters always use double curly braces: {{parameterName}}Choose clear parameter names that describe their purposeYou can test your dynamic URLs using the default values in the editor\"English unique path\" is the URL structure for accessing content in English, letting you define custom routes for each language.For example, if you were building a multi-language site, you might have:English path: /products/category/{{param}}French path: /produits/categorie/{{param}}Spanish path: /productos/categoria/{{param}}WARNINGA page might work when previewing it in the editor in French, but will fail when visitors try to access it in English if you haven't created the English content version. Learn more about page languages:TIP✅ Dynamic URLs are better for:Product pages that change based on category or brandBlog posts with different articlesUser profilesSearch results pagesRetrieve URL parameter value ​Once you have defined URL parameters in your page settings, you can access them through WeWeb's Variables tab in the Formula editor. These parameters automatically update based on the URL, allowing you to fetch data for specific items, show or hide content based on the current value, filter collections and control component visibility.For example, if your URL is /products/category/{{param}}, you can use the parameter to fetch and display only products from that category:TIPURL paths are only available on the page where you create themThe Home page cannot have URL paths. To handle URLs like mydomain.com/1:Create a regular page (e.g., \"Main\") with URL path {{id}}Add workflow \"On page load\" to HomeUse Navigate to action to redirect to Main pageExample:User visits: mydomain.com (Home)Auto-redirects to: mydomain.com/1 (Main page)Users can now access mydomain.com/2, mydomain.com/3, etc.Navigation methods ​TIPConsider using Multi-page sections for improved navigation performanceWhen navigating between pages, consider implementing multi-page sections to improve the performance of page transitions. Multi-page sections allow you to preload content from other pages, resulting in smoother transitions and faster loading times. This is especially beneficial for frequently accessed pages or when you want to create a seamless user experience.You can learn more about multi-page sections in their dedicated documentation.Now that you understand how URLs work in WeWeb, let's look at the three ways to navigate between pages:Link ​The most common way to navigate is using the Link to property. This creates regular links that users can click on, just like standard website links. It's perfect for navigation menus, buttons, and any clickable elements.For example, if you have a products page with URL parameters set up (/products/category/{{param}}), you can create links to specific categories:Select any element you want to make clickableIn the Settings tab, find the Link sectionChoose the target pageAdd any URL parameters needed:Assuming you are using the URL path in an API request to fetch a collection, you will get different results:Link properties ​PropertyDescriptionLink toChoose link type: Page (internal navigation), URL (external websites), Download (file downloads), Email (mailto:), or Phone (tel:)PageWhen \"Page\" is selected, choose which page to navigate to (e.g., Products, About, Contact)ParametersDefine dynamic parameters for the URL (e.g., param = smartphones to create /products/category/smartphones)SectionJump to specific sections: \"Top of page\", \"Header Section\", or \"Main Section\". Enables smooth scrolling to page areasOpen in new pageToggle to open link in new browser tab (On/Off)QueriesAdd URL query parameters (?key=value) for filtering, sorting, or tracking. Examples: ?sort=price_asc, ?ref=homepage, ?campaign=summerLoader on page changeDisplay loading indicator during page transitions and data fetchingTIPDisable the Preserve collection on navigation property so the collection can be \"reset\" when you navigate. Otherwise, your collection might show stale data from the previous page.You do not need to reset URL paths. This is all done by WeWeb automatically.Navigate to workflow action ​Sometimes you need navigation to happen automatically, like after a form submission or when certain conditions are met. This is where the Navigate to action comes in.Instead of waiting for a user to click, the Navigate to workflow action can be triggered by:Form submissionsAPI responsesButton clicks with additional logicWorkflow completionsProperties ​PropertyDescriptionTypeChoose navigation type: Internal link (page navigation) or External link (URL)Page/PathSelect destination: Page (internal pages) or Path (custom URL path)Page*Select the target page to navigate to when \"Page\" is selectedSection*Choose section to scroll to: \"Top of page\", \"Header Section\", or \"Main Section\"ParametersDefine dynamic parameters for the URL (e.g., param = smartphones to create /products/category/smartphones)Open in a new tabToggle to control if navigation opens in new browser tab (On/Off)QueriesAdd URL query parameters (?key=value) for filtering, search terms, or trackingLoader on page changeShow/Hide loading indicator during page transitions with \"Show page loader\" toggleNavigate to the previous page ​Allows users to go back to their previous page, similar to clicking the browser's back button. This is useful for:\"Back\" buttons after form submissions\"Return to previous page\" linksCancel buttons that return users to where they came fromYou can set a default redirect page (like Home) that users will go to if there's no previous page in their history.TIPA workflow is a series of actions that happen in response to a trigger. You can learn more about workflow actions here.TIPLink to vs Navigate toLink toCreates HTML <a> tags in the published app - better for SEO and accessibilityUse for navigation menus and clickable elementsAdds \"Active link\" state to the target elementNavigate toUses JavaScript navigation - less optimal for SEO and accessibilityMore flexible for workflow automation and programmatic navigationWARNINGAvoid setting both Link to property and Navigate to action on the same element - this can cause navigation conflicts in the editor.Queries ​URLs in WeWeb can have two types of parameters:Path parameters: /products/category/{{param}}Query parameters: /products?category=electronicsQuery variables automatically capture and store URL query parameters. When you navigate to a page with query parameters, the corresponding query variables update to match the values in the URL.Here's how they work:Create a query variable (e.g., searchTerm)Add it to the Queries property during navigation:Name: \"searchTerm\"Value: \"smartphones\"The URL will update (e.g., yourpage?searchTerm=smartphones) and the query variable searchTerm automatically updates to \"smartphones\".You can use these variables anywhere in your app without writing any code!To modify the query programatically, you can also use the Change variable value workflow action.TIPYou might need query parameters for reset password flows. For example:User clicks reset password link: myapp.com/reset-password?token=abc123The token query parameter is automatically captured by a query variableYour app can then use this variable to validate the reset password requestQuery parameters are also perfect for sort and filter features, just like YouTube's video timestamp sharing (e.g., youtube.com/watch?v=123&t=150). Users can share links/filtered views by simply copying the URL (e.g., products?sort=price_desc&category=phones). The & symbol in URLs is used to separate multiple query parameters.SPA Navigation ​A Single Page Application (SPA) works like a desktop app in your browser - instead of loading entire new pages when you click around, it just updates the parts that need to change.Same page navigation ​When navigating to the same page in WeWeb:Editor: Page will reload for preview purposesPublished app: No page reload, content updates smoothlyTo navigate to the same page to avoid page reloads in the published app, simply select the current page on navigation:Now, in the published app, this is what will happen:TIPNavigating to the same page will trigger a page reload in the editor, but not in the published app, which is great for SPA navigation.WARNINGBalance SPA navigation with dedicated pagesWhile SPA navigation can provide a smooth transition and improved user experience, it's important to create dedicated pages for distinct sections of your application. Sections like account settings and sign-in pages should generally be implemented as separate pages rather than all within a single page. Building too much on a single page can lead to difficulties in maintaining and scaling the page as more and more is built on the page.Use SPA-style same-page navigation for smaller UI updates and transitions, but rely on dedicated pages for major functional areas of your application.wwParams ​When navigating in the editor, you might notice wwParam appearing in your URLs. Don't worry - this is normal and only happens in the editor, not your published site. Here's why:The WeWeb editor has two separate windows running at the same time:The editor window, where you see all your tools and settingsA preview window (iframe) - where you see how your app looksThese windows need different kinds of information:The editor needs to know about your project settings, tools, etc.The preview needs to show your actual appWhy wwParams exists ​When you navigate in your app using parameters (like /products/shoes):The editor needs to know about this navigationThe preview needs to show the right contentBoth windows need to stay in syncwwParams is WeWeb's solution to keep these two windows synchronized. It ensures that when you change pages or parameters in one window, the other window updates automatically to match.In your published site, wwParams isn't needed because there's only one window. It's just a tool to help during development.WARNINGOAuth TestingWhen implementing OAuth or any authentication with URL redirects, make sure to add both your published URL and editor URL to your OAuth provider's allowed redirect URLs. This ensures the authentication service works in both environments.Current page data ​The CurrentPage object helps you access information about the page you're currently on. You can use it in formulas and workflows to get details about your page.Common properties ​PropertyDescriptionExamplenameThe name of your pageCurrentPage.name returns \"Products\"idUnique identifier of the pageCurrentPage.id returns \"bb851ad8-bac2-4878-b199-0dc3445efe37\"pathThe current URL pathCurrentPage.path returns \"products/category/\"langPage language codeCurrentPage.lang returns \"en\"Status properties ​PropertyDescriptionpageLoadedBoolean indicating if page has finished loadingfolderParent folder of the page (if any)metaImagePage meta image for SEO (if set)Additional properties ​paths: contains URL path informationlangs: available language versionsmeta: page meta informationtitle: page title informationsections: page sectionspageUserGroups: access control groupsTIPThis is useful for:Display different content based on page name (e.g., \"Welcome to \" + CurrentPage.name)Create dynamic navigation text (e.g., If(CurrentPage.name = \"Cart\", then \"Back\" else \"Cart\")Handle multiple languages (e.g., If(CurrentPage.lang = \"en\" then \"Buy\" else \"Acheter\")Show/hide elements on specific pages (e.g., If CurrentPage.name != \"Contact\")Create dynamic text combining page data (e.g., CurrentPage.name + \" - \" + CurrentPage.path)"
  },
  {
    "h1": "Page metadata​",
    "url": "https://docs.weweb.io/pages/page-metadata.html",
    "content": "Page metadata ​Page metadata is the information that is used by search engines to display your page in search results. Search engines use metadata to understand your pages. Without proper metadata, search engines would have to guess what your page is about - leading to confusing or unhelpful search results.TIPThe present article explains how to add static metadata to a WeWeb page.If you need to learn how to set dynamic metadata on a page, please refer to this guide.Google and search engines ​Title Tag ​The Title Tag helps Google understand your page's main topic and determines how your page appears in search results. It's the first thing both Google and users see, serving as the clickable headline in search results. This also determines the title displayed in the browser tab.TIPInclude your main keyword near the beginningKeep it under 60 characters to avoid truncation in search resultsMake it descriptive but conciseMake it unique for each pageWrite for humans first - make it compelling and clickableMeta description ​The meta description provides a brief summary of your page content that appears beneath the title in search results. While not directly used for ranking, it acts as a \"pitch\" to users, helping them decide whether to click on your result. A compelling meta description that accurately previews your page content can significantly increase click-through rates from search results.TIPLength: Keep it between 150-160 characters to avoid truncation in search resultsContent: Include your main keywords naturally, accurately describe the page contentAction: Include a clear call-to-action when appropriateUnique: Write different meta descriptions for each pageStyle: Write in active voice and make it compelling to clickMeta keywords ​Meta keywords are searchable terms you can add to your page. While they don't affect rankings on major search engines like Google, they can help with internal site search and are sometimes used by specialized industry tools. For best SEO results, focus instead on creating good titles, descriptions, and content with naturally integrated keywords.Hide page ​If you check this option to hide the page in Google and other search engines, the page will not be indexed by search engines.TIPIndexing is the process where search engines store and organize web pages after scanning their content. This allows them to quickly retrieve relevant pages when users search. If a page isn’t indexed, it won’t appear in search results.Favicon ​This is the icon that will be displayed in the browser tab.Technical specifications: ​Must be square (1:1 aspect ratio)Minimum size: 8×8 pixelsRecommended size: At least 48×48 pixelsAny valid favicon format is acceptedURL must be stable (avoid frequent changes)TIPThe favicon can only be set on your home page and will apply to all pages of your web app. Having a single source of truth (the home page) makes it easier for Google to track and update favicon information. This also improves crawling efficiency, as Google's crawlers don't need to check every page for favicon information.Open graph (Social metadata) ​Open Graph image ​This is the image that will be displayed when you share the page on social media. It should be in a specific format, such as aspect ratio: 1.91:1 and minimum dimensions: 1200x630 pixels. For further details, click here.Open Graph Title ​This is the title that will be displayed when you share the page on social media. More info on how to set it up here.Open Graph Description ​This is the description that will be displayed when you share the page on social media. More info on how to set it up here.Structured data ​Structured data is like a special label system for your website that helps search engines (like Google) better understand what's on your pages. Think of it as giving Google a clear set of instructions about your content - whether it's a product page, an article, a recipe, or just your company information.Search engines use structured data to create rich descriptions that display extra details like ratings, images, or prices, ultimately increasing the chances of users clicking on your site.In WeWeb, structured data can be added through the page metadata settings. The format should be JSON-LD, which might look intimidating but it's just a standardized way to write information.Here's what you need to know:It must be valid JSON-LD formatThe content should match what's actually visible on your pageFor example, if you're adding structured data for your company page, you might include:Your company nameAddressContact informationType of businessLogotypescript{ \"@context\": \"https://schema.org\", \"name\": \"Sweet Dreams Bakery\", \"address\": { \"@type\": \"PostalAddress\", \"streetAddress\": \"123 Main Street\", \"addressLocality\": \"San Francisco\", \"addressRegion\": \"CA\", \"postalCode\": \"94105\", \"addressCountry\": \"US\" }, \"telephone\": \"+1-555-123-4567\", \"email\": \"hello@sweetdreamsbakery.com\", \"@type\": \"Bakery\", \"image\": \"https://sweetdreamsbakery.com/logo.png\" }TIPStructured data should match the main content of each specific page.If it's a recipe page, you'll want to include recipe details (cooking time, ingredients, etc.)If it's a product page, you'll include product information (price, availability, etc.)If it's a business contact page, that's when you'd include business details (address, phone, etc.)"
  },
  {
    "h1": "Private pages​",
    "url": "https://docs.weweb.io/pages/private-pages.html",
    "content": "Private pages ​Pre-requisiteTo make a page private in WeWeb, you first need to have added and configured an authentication plugin.For authenticated users ​Assuming you have added and configured an authentication plugin, you will be able to decide if everybody can access a page or only authenticated users:If you choose the Authenticated users option, the page will only be accessible to users that are logged in.TIPInside the WeWeb editor, you will be able to access all pages, including private pages, even if the user is not logged in. This was done to avoid users being stuck when building in WeWeb.WARNINGWhen defining redirections in your authentication plugin, make sure you redirect unauthenticated users to a public page. If you redirect unauthenticated users to a page that is only accessible to authenticated users, you'll be creating an infinite loop and your app will crash.For user groups ​If you have defined user roles in your backend and user groups in your authentication plugin, you will also have the option to restrict access to a specific group or groups:TIPInside the WeWeb editor, you will be able to access all pages, including private pages, even if the user is not part of the required user group. This was done to avoid users being stuck when building in WeWeb.WARNINGWhen you add several roles to a user group, a user needs to have BOTH these roles to be part of the user group. It's an AND statement, not OR.In the example below, the members of the Premium customer user group must have both the Customer and the Premium roles associated with their user profile:Security ​It's important to understand that gating content, making a page private, is more of a UX feature than a security measure.It is best practice to gate content because, by making a page private in the frontend, you make it clear to the user that they are not allowed to access the content on that page.However, in web development, security always happens in the backend. To protect your data, you must secure the API endpoints or tables in your backend, even if the page that triggers those calls is private.In other words, if users need to be authenticated or have a specific role to view or edit data, your backend should have access control checks that ensure that users have the proper authorizations when trying to access or update data.Learn more about securing your web-apps here:"
  },
  {
    "h1": "Sitemap​",
    "url": "https://docs.weweb.io/pages/sitemap.html",
    "content": "Sitemap ​A sitemap is a file where you provide information about the pages, videos, and other files on your app, and the relationships between them. Search engines read this file to crawl your site more efficiently.When you publish a WeWeb app, an XML sitemap is generated automatically but you can also create your own custom sitemap if needed.Auto-generated sitemap ​When you publish a WeWeb app, an XML sitemap is generated automatically with all the public, static pages of your app.You can view it at subdomain.yourdomain.com/sitemap.xml.It will look something like this:xml<?xml version=\"1.0\" encoding=\"UTF-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"> <url><loc>https://www.joycekettering.rocks/onboarding/</loc><lastmod>2024-07-12</lastmod><changefreq>monthly</changefreq><priority>0.5</priority><xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"https://www.joycekettering.rocks/onboarding/\" /></url> <url><loc>https://www.joycekettering.rocks/post_login_page/</loc><lastmod>2024-07-12</lastmod><changefreq>monthly</changefreq><priority>0.5</priority><xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"https://www.joycekettering.rocks/post_login_page/\" /></url> <url><loc>https://www.joycekettering.rocks/new-password/</loc><lastmod>2024-07-12</lastmod><changefreq>monthly</changefreq><priority>0.5</priority><xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"https://www.joycekettering.rocks/new-password/\" /></url> <url><loc>https://www.joycekettering.rocks/forgot-password/</loc><lastmod>2024-07-12</lastmod><changefreq>monthly</changefreq><priority>0.5</priority><xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"https://www.joycekettering.rocks/forgot-password/\" /></url> </urlset>In the example above, taken from https://www.joycekettering.rocks/sitemap.xml, you can see the sitemap includes 4 pages:/onboarding/post_login_page/forgot-password/new-passwordThe app actually contains more pages but these pages are either:private pages, ordynamic pages.As a result, there are not included in the auto-generated sitemap.This is because WeWeb assumes that you want to keep private pages private from search engines and, when you publish dynamic collection pages, the information regarding those pages are in your backend, not WeWeb.Custom sitemap ​If the default WeWeb sitemap does not fulfill all your requirements, you can upload your own custom sitemap.Go to More > Files, and upload your custom sitemap: Name the file as you with but make sure:it has an .xml extentionits path is set to /sitemap.xmlThis will ensure that when you publish your WeWeb app, the auto-generated sitemap is overwritten by the custom sitemap you uploaded."
  },
  {
    "h1": "Static collection pages​",
    "url": "https://docs.weweb.io/pages/static-collection-page.html",
    "content": "Static collection pages ​A static collection page is a page, which is bound to a collection, will duplicate itself for all of the items in the collection.But, for each item, it'll keep the same design. It's useful to create a page that will display all the items of a collection.Use case ​Let's say you have a collection of products.On your homepage, you'll display all of the products of this collection, but then redirect each of them to a page with more information about each product.You will then create a static collection page, and bind it to the products collection.This page will then duplicate itself for each product, and display the product's information.WARNINGTo create a static collection page, you need to have a collection setup in your app, with the static mode.TIPStatic collection pages are statically generated when you push the app to production. This means that they will be generated only once, and then they will be served directly from the CDN. This is why they are so fast and good for SEO.Create a static collection page ​Some explanations:You have to bind a static collection to the page. This is the collection that will be used to duplicate the page for each item in the collection.You have to bind the page path, which is a field in the collection, to the page path. This is the field that will be used to generate the URL of the page. For example, if you have a collection of products, and you want to create a page for each product, you can bind the page path field to the product name field. This way, the URL of the page will be https://your-app.com/product-name.Then, on every element or workflow in this page, you'll be able to access the data of the item that is currently displayed:(here, we show you how to bind a title, and we've done the same for the domain and the image, hence the final result)Link to a static collection page ​First of all, you can link to a static collection page from any collection list that uses the same collection.Indeed, WeWeb will automatically know to which instance of the static collection page to redirect to, based on the element in the collection list the user clicked on.Let's see how to do it:"
  },
  {
    "h1": "Auth0​",
    "url": "https://docs.weweb.io/plugins/auth-systems/auth0.html",
    "content": "Auth0 ​Plugin configuration ​To connect your Auth0 account to WeWeb, you’ll need 3 pieces of information:Your Auth0 DomainYour Auth0 TokenA default application name1. Your Auth0 domain ​in Auth0, go to Applications > APIscopy the URL for your API audiencepaste it in WeWeb.2. Your Auth0 token ​back on the Applications > APIs screen in Auth0click on Auth0 Management API > API explorercreate a test application (if you don't have one already)copy the token and paste it in WeWeb3. Default application name ​By default, this will be the name of your WeWeb project but you can change it if you want to refer to a Single Page Application you created previously in your Auth0 workspace:Define redirections ​In order for the signup, login, and sign out flows to work properly, you'll need to define pages where users are directed:after they signed in – for example a personalized dashboardafter they log out or when they try to access a private page without being logged in – for example a login or a home pageWARNINGThe Page to redirect after the user signed-in should be a public page. If you wish to redirect authenticated users to a private page, you should create and select an empty public page with a workflow triggered On page load that redirects them to the page of your choice.This may seem strange but it's how third-party authentication works on the web: the browser needs to get a cookie from the auth provider, and read it before fetching the user and redirecting them to the chosen page. If you redirect to a private page, you'll get an error because the browser won't have had time to read the cookie and fetch the user before arriving on the private page. It needs a short stop on a public page first.Auth0 configuration ​Once you have configured the Auth0 plugin in WeWeb, Auth0 will automatically create 2 applications which are both equally important to add authentication to your WeWeb project:a Machine to Machine application, named API Explorer Applicationa Single Page Application, named whatever you defined in the default application name aboveTIPIf you don't have a Single Page Application in Auth0, we will create one for you automatically but if you already have one or more, we'll leave them.Machine to Machine ​Machine to Machine is a private application that allows Auth0 to communicate with the public application you publish. It's what allows your app to get the list of all available roles in Auth0 for example.Make sure to give the Machine to Machine application permission to interact with your app:WARNINGIf you don't have a Machine to Machine application in Auth0, you will not have a token and will therefore not be able to setup the Auth0 plugin in WeWeb.Single Page Application ​Single Page Application is a public application that allows the WeWeb app you published (or are consulting in preview mode inside the WeWeb Editor) to communicate with Auth0. For example, it's what allows users to signup, login, or get their info when they're logged.There are a few things you need to configure in the Settings of your Auth0 SPA to ensure users can signup, login, and sign out.Application Login URI: this should be the URL of a dedicated login page on your published application.Allowed Callback URLs: this should include the URLs where users are redirected after logging in (e.g. in preview mode and on the live app).Allowed Logout URLs: this should include the URLs where users are redirected after logging out (e.g. in preview mode and on the live app).Allowed Web Origins: this should include the domain name of your published app and https://editor.weweb.io so that you can test your user flows inside the WeWeb Editor.TIPWe recommend including several URLs in each \"Allowed\" field:the relevant URLs inside the WeWeb Editor so you can test the Auth0 plugin while you're building, andthe relevant URLs of your published app, so everything works live.Signup & login flows ​You can allow new users to sign up or login to your app by triggering a workflow with one of the Auth0 Login actions with the Sign in or Sign up option enabled.In the example below, when a user clicks on a button on our page, an Auth0 popup will open and they will be invited to fill out their information to sign up to our app:There's no other action required in the workflow. After signing up or logging in, the user will be redirected to the page defined in the Auth0 plugin configuration:TIPDon't hesitate to check your list of users in Auth0 to ensure your signup and login flows are working correctly. In the screenshot below, we can see our list of users and when they last logged in:Roles & permissions ​In some cases, you'll want to restrict access to pages of your web-app based on roles & permissions.In order to do this, there are a few steps to take:define roles in Auth0 (those will be automatically added to WeWeb via the plugin)create user groups in WeWeb and define what role or roles a user needs to be part of that groupdefine what user groups are allowed to visit the page you want to gate1. User roles in Auth0 ​To define user groups in WeWeb, you first need to create user roles in Auth0 > User Management > Roles > Create RoleThen, you can assign roles to users in User Management > Users > Assign RolesOnce you have user roles in Auth0, you'll be able to see them in WeWeb:2. User groups in WeWeb ​Assuming you've added user roles in Auth0, you'll be able to create user groups in WeWeb and define what role(s) users need to have to be part of each group:WARNINGWhen you add several roles to a user group, a user needs to have BOTH these roles. It's an AND statement, not OR.Restrict page access ​By default, when you add a new empty page in your WeWeb app, everybody can access it, even users who have not signed in.You can limit access to your WeWeb app at page level:go to the page settings > Private accessrestrict access to Authenticated usersif applicable, select which authenticated user group(s) can access the pagePersonalize UX ​You can personalize the popup displayed to users when they signup or login in the Branding section of your Auth0 account:"
  },
  {
    "h1": "OpenID​",
    "url": "https://docs.weweb.io/plugins/auth-systems/open-id.html",
    "content": "OpenID ​OpenID is a layer on top of the OAuth 2.0 protocol that allows you to authenticate users and get their basic profile from the OAuth provider of your choice, including but not limited to Google, Slack, LINE, etc.How you configure the OpenID plugin in WeWeb will depend on the OAuth provider you are working with. In this article, we will demonstrate using Google OAuth.Provider setup ​Before you can configure the WeWeb plugin, you'll need the following information from your OAuth provider:the domain WeWeb should send the request to via OpenIDa client IDa client secreta scope (i.e. what information you want to get)a response typeHow you get this information will depend on your OAuth provider.To allow users to signup or login with their Google account, you would need to:go to the Google Cloud Console, andcreate a new projectOnce you've created a project, you'll be able to configure the provider's consent screen and get credentials so WeWeb can make secure requests to the provider via the OpenID plugin.OAuth consent screen ​The OAuth consent screen is the screen the user will see when they choose to connect with the provider.For example, the Google consent screen looks something like this:To configure the Google OAuth consent screen, you'll need to go to APIs & Services > OAuth consent screen:At that stage, the provider will ask for some information such as:Branding – For example, what is the name of your application and its logo.Contacts – For example, a developer and/or support email address.User type – Whether your app is reserved for people in your company (internal) or open to people outside your organization (external)Authorized domains – A list of domain names that are authorized to make a request for autentication to the provider. For example,weweb.io so it works when you're testing inside the WeWeb Editor,weweb-preview.io to test the auth flow on a published app without a custom domain, andyour own custom domain to ensure it works properly on your live appScopes – To define what users will be giving access to (e.g. just their basic info or also their calendar).Test users – A list of test users who can test the app while it's under development.TIPDepending on the provider, some of these will be optional. What is never optional is listing which domains are authorized to make a call to the provider. Make sure to get those right and don't forget to add your custom domain later if you don't have it from the start.API keys & credentials ​In order for the provider to authorize the call you make through the OpenID plugin in WeWeb, you'll need create OAuth credentials in the provider's interface and copy them in WeWeb when you configure the plugin (but more on that later).In Google, you can do this by going to APIs & Services > Credentials > Create credentials > OAuth client ID:At that stage, the provider will ask for information such as:Name – You will be invited to name the credentials. It doesn't really matter what you name it but it's helpful if it's descriptive enough that you know where you're using them. For example, you could name them: OpenID via WeWebAuthorized JavaScript origins – A list of all the domains your web-app is hosted on. For example:the WeWeb editor: https://editor.weweb.ioyour app in staging: https://4132ed05-ba19-4dc2-9867-ba4d4f9a9d76-staging.weweb-preview.ioyour app in production: https://www.your-custom-domain.comAuthorized redirect URIs – A list of URIs where users can be redirected after being authenticated. For example:the page in the WeWeb editor: https://editor.weweb.io/4132ed05-ba19-4dc2-9867-ba4d4f9a9d76/86d66b45-bedd-47e9-a2ae-c1af5a1b2f5dthe page in the app in staging: https://4132ed05-ba19-4dc2-9867-ba4d4f9a9d76-staging.weweb-preview.io/post-login/the page in production: https://www.your-custom-domain.com/post-login/These links should correspond to the page where users are redirected after being authenticated through the OpenID plugin in all the environments of your app (e.g. the WeWeb editor, in staging, in production).It should match the URIs of the page you defined in the OpenID plugin in WeWeb:WARNINGIf you need to update these later, for example when you add a custom domain to your app, keep in mind that it can take 5 minutes up to a few hours for the new settings to take effect:We recommend you stay patient when testing new settings. Testing new settings right away and reverting back because you don't see the difference instantly is a great way to get confused and feel stuck.Plugin configuration ​In WeWeb, you'll find the OpenID plugin in the Plugins > Authentication menu:When you add the plugin, you'll be invited to provide information that will allow WeWeb to make calls on behalf of your app to your OAuth provider:the domain of your OAuth providerthe OAuth 2.0 credentials created for your app (i.e. the client ID and client secret)the scope values you want OpenID to return from the User Info endpoint, e.g. profile, email, address, or phone. Learn more about different scope values in OpenID's user docsthe response type. Learn more about different OAuth flows in this video by Oracle and through OpenID's user docsIn the example below, you can see:we are working with Google as a provider, andare asking for the user email and profile of the userRedirections ​Once you have told the OpenID plugin how to communicate with your OAuth provider, you will need to define pages where users are redirected:after they sign-inwhen they are not signed-inIn the example above, we named those pages Post login and Login but we can choose to redirect them to any page we want. For example, we could redirect authenticated users to their profile page and unauthenticated users to the app's home page.Signup and login flows ​Once you've added the OpenID plugin to your WeWeb project, you will get access to dedicated OpenID actions in workflows:When you use one of the login actions in a workflow, the user will be automatically redirected to the page you defined in the OpenID plugin after the authentication is successful.Even if you have a Change page action after the login action in your workflow, the OAuth flow will resolve on the redirect page defined in the plugin and authorized in the provider dashboard.Advanced redirection ​If you want more flexibility on where to redirect authenticated users, you could update a destination page variable before the login action in your workflow to define where the user should be redirected after the login:Then, on the post-login page, you can trigger a workflow On Page Load that checks the destination page variable to decide if the user should stay on the post-login page or be redirected to another page like the user profile in the example below:"
  },
  {
    "h1": "Supabase authentication​",
    "url": "https://docs.weweb.io/plugins/auth-systems/supabase-auth.html",
    "content": "Supabase authentication ​WARNINGThe video above was recorded before the latest WeWeb UI update but the logic remains the same. If you're unsure where to find something in the new interface of the WeWeb editor, you can see what changed here.Plugin configuration ​Supabase comes with an in-built authentication system which you can use in WeWeb.To add the Supabase Auth Plugin in WeWeb, go to Plugins > Authentication:Assuming you have already provided your Supabase project URL and public API key when setting up the Supabase Data source, the only thing left to do will be to add your private API key:In Supabase, you can find your private API key in Settings > API:WARNINGAs the name suggests, you'll want to keep this API key secret. Assuming you copy it properly in the Private API key field of the Supabase Auth Plugin and don't use it anywhere else in your WeWeb project, WeWeb will never make it public.You will then be invited to choose a page to redirect unauthenticated users, i.e. users who are NOT signed-in:WARNINGMake sure you redirect unauthenticated users to a public page. If you redirect unauthenticated users to a page that is only accessible to authenticated users, you'll be creating an infinite loop and your app will crash.Sign up and log in flows ​WARNINGBy default, Supabase restricts auth emails to your organization's members only. To enable sign-up functionality for all users, you must set up a custom SMTP provider in your Supabase project. Without this setup, new users outside your organization will not be able to sign up or receive auth-related emails.Once you have added the Supabase Auth plugin to your WeWeb project, you will get access to:dedicated Supabase Auth actions in workflows, anddedicated UI elements in the Add menu.In the example below, you can see we added the Login UI element related to the Supabase Auth plugin:That UI element comes with a predefined workflow using the Login with email action but you have access to many more:TIPIf you choose to design your own forms, remember to place the workflow on the form container and trigger it On submit if you want to validate the fields of the form when users submit it (as opped to triggering the workflow On click of a button).Sign up workflow ​In the example below, we added a workflow on a sign up form, chose the On submit trigger, and added the Supabase Sign up action:Then, we mapped the email, password, and metadata information in the form to the email, password, and metadata in Supabase before choosing what page the new user should be redirected to:In the example above, we made sure to add the user's name as an item in that user's metadata.In Supabase, you can find the user's metadata in JSON format in a dedicated field of the users table, named raw_user_meta_data:The same logic will apply to any Supabase action you want to trigger.Reset password flow ​You'll need three things to allow users to reset their passwords:a WeWeb page where users type in their email address and submit a password reset requestthe URL of your website and an email template properly configured in Supabasea WeWeb page where users are redirected when they click on the link in the email sent by Supabase1. Forgot password page ​In WeWeb, you'll need to create a page where users can make a request to reset their password.That page needs to include:an email input field, anda workflow with the Supabase Auth Forgot password action.You can design your own custom page or simply use the Reset password UI element that comes with the Supabase Auth plugin:In the example below, we trigger a Forgot password action on form submit, tell Supabase where it should send the reset password email, and say we want the user to be redirected to the Choose new password page when they click on the link in that email:2. Supabase configuration to send password reset email ​In Supabase, you'll need to add the URL of your live app by going to Authentication > URL Configuration:In the example above, we added the URL of our project in the WeWeb Editor because we are still building the app but we would change it to the URL of our staging website or live website as we progressed through the building and publishing process.WARNINGThe URL should not reference a specific page.You can personalize the email Supabase sends by going to Authentication > Email Templates > Reset password:WARNINGThe {{ .ConfirmationURL }} variable in the email template will automatically refer to the page you chose to redirect users in step 1. Do NOT modify it.TROUBLESHOOTING TIPSIf you are not receiving the reset password email as expected:check if the the email was sent to your spam folderexperiment with and without a / at the end of the URLcheck that the URL corresponds to the environment you made the reset password request in (e.g. the WeWeb editor, the staging URL ending with staging.weweb-preview.io, or the live app)if testing with the WeWeb Editor URL, make sure to include only the first part of the URL. Do not include the page id after the second /3. Confirm password page ​Back in WeWeb, you will need to create a page where users can type in and submit their new password.You can design your own custom page or use the Change password UI element that comes with the Supabase Auth plugin.In the example below, we triggered a workflow on a form submission and:check if the two password input values are identicalif they're not, we display an error messageif they are, we use the Confirm password action to send the new password to SupabaseOAuth with providers ​When using Supabase for authentication, sign up and login with an email address is enabled by default but you can also enable other methods of authentication, including but not limited to Google OAuth, Azure, GitHub, LinkedIn, and Slack:Each provider will have their own configuration steps which you'll need to work out using their documentation.Broadly speaking, it will look something like this:In the provider's interfacecreate the projectadd authorized domainscreate OAuth credentialsdefine redirect URLsIn Supabasesave the OAuth credentials of the provideradd the base URL of your websitedefine one or more URLs where users can be redirected after logging inIn WeWebtrigger a workflow with the Login with provider actionselect what provider's consent screen you want to displayselect which page users should be redirected to after they successfully log inWARNINGWhen you use the Login with provider action with the Supabase Auth plugin, it's important to redirect to a public page to read the cookie from the external provider with the user information. This will allow you to then move on to a private page without any errors.This is not WeWeb or Supabase specific, it's part of a standard OAuth flow:Update user metadata ​In the default users table of a Supabase project, you can add user metadata in the raw_user_meta_data column which expects a JSON.To pass user metadata from WeWeb to Supabase, you have two options.1- select a key in the Metadata dropdown when using the Sign Up or Update User Metadata action in a workflow2- bind the Metadata field to update Supabase with custom metadata.This fields expects an array of objects where, for each object, you explicitly say this is my key and this is the corresponding value for this item. For example:In the example above, we used a no-code formula to create the array of objects but, if you're used to the syntax, it can be easier to write in JavaScript:Here's a code snippet you might find helpful to avoid typos:jsreturn [ {\"key\":\"favorite_joke\", \"value\":\"something about an elephant\"}, {\"key\":\"favorite_chocolate\", \"value\":\"dark\"} ]WARNINGYou will not be able to update the user metadata of users who are logging in through a third-party provider because their metadata is related to the OAuth provider they are authenticated with.If you wish to request further information from these users, we recommend creating a profiles table in the public schema of your Supabase project that is synced to your users table.Learn more about working with user profiles in Supabase.User roles & permissions ​Now let's say we want to gate content and set different permissions based on a user's role. We will need to:create a roles table in Supabase with the list of available rolescreate a join table in Supabase that maps the users with a roletell the Supabase Auth plugin in WeWeb where it can find the information1. Add roles in Supabase ​In Supabase, we'll need to create a roles table with a list of roles and a join table that links the roles table with our users table.First, let's create a roles table with three roles and make sure that each role had a UUID and a name:WARNINGIn order for the integration to work with the Users tab in WeWeb, it is crucial that the role title is a text field named name.2. Join roles and users in Supabase ​Second, let's create a userRoles join table:In the join table above, you can see we have an id field that is uniquely identifiable thanks to a UUID.This unique id is linked to a userId, which is also a UUID. More specifically, it is the UUID we find in the id field of the users table in the auth schema:Each row in our userRoles table is also linked to a roleId which is the UUID we find in the id field of the roles table in the public schema:3. Link users in WeWeb to roles and users in Supabase ​Once we've added our list of roles in Supabase and created an empty join table to link our roles with users, it's time to go to WeWeb.In Plugins > Supabase Auth > 3. Roles table, we'll click refresh and select the relevant Supabase tables we just created:Once you've told WeWeb where to find the roles and the join table in Supabase, you'll be able to easily view and maintain user roles in the Users tab in WeWeb:When you make a change to a user in WeWeb, it will automatically be updated in Supabase.Users vs Profiles ​So far, we've showed you how to work with the default users table that Supabase generates in the auth schema when you create a new project.Note that, for security purposes, the information in that users table is not exposed on the auto-generated API.How does this affect your project in WeWeb?Let users update their information ​Let's say you want to let authenticated users update their own information, then you don't need to set up anything else in Supabase.You could simply create a user profile page in WeWeb and display their information when they sign in, based on the data you have in the user variable:Display other users' information ​In some use cases, you might want to display other users' information.For example, if you're building an HR portal in WeWeb, you might want HR employees to have access to a list of applicants and their user profiles.You wouldn't be able to do that with the users table in the auth schema because each user's information is only available to them.For such a use case, Supabase recommends creating a profiles table in the public schema to store user data that you want to access via the API.In WeWeb, you would then be able to create a Collection to get data from the profiles table.Learn more about managing user data in Supabase:"
  },
  {
    "h1": "Token-based authentication​",
    "url": "https://docs.weweb.io/plugins/auth-systems/token-based-auth.html",
    "content": "Token-based authentication ​Add plugin ​To connect your WeWeb app to a token-based authentication system, go to Plugins > Authentication > Token Based Auth:Configure plugin ​When you add the Plugin, you will be invited to choose the authentication type:Auth Bearer Token,Auth Basic Token, orCustom HeaderDepending on the authentication type you choose, you will be invited to add further information.For Auth Bearer Token or Auth Basic Token authentication, you will be invited to provide a user endpoint (required) and refresh token endpoint (optional):For Custom Header authentication, you will also be invited to fill out the custom header name:TIPIf you're unsure how to complete this step, please contact the provider of the authentication system you are attempting to set up.Define dedirection ​Choose a public page where you want to redirect users when they are not signed in:WARNINGChoose a public page. If you redirect users to a private page when they are not logged in, you will create an infinite loop in your app and your users' browser will crash.User roles & user groups ​In your backend ​In order to gate content in WeWeb based on user roles and permissions, you first need to have information about roles in your backend and that information needs to be accessible to WeWeb via API.For example, you could create a role column in your user table and make it available in the me endpoint so that, when a user logs in to your app, you fetch their role at the same time.In the WeWeb plugin ​Assuming you have roles defined in your backend, you'll have to tell the Token Based Auth plugin where to find the user role in the backend:WARNINGThe Role key is case sensitive. If the column name in your backend is Roles, you should type this in exactly: roles won't work.The Role type must match the data type where you store user role(s) in your backend. In the example above, it's a single Text in a column named role but other common use cases could be a List of texts named roles or a List of objects named users.In the WeWeb Auth tab ​Once you've told the plugin where it can find the user roles in your backend, you'll need to create the user roles and user groups in WeWeb:go to the Auth tab,add the user roles you have in your backend, andadd user groups and decide what role(s) a user needs to be part of a group.WARNINGThe Role name should be exactly the same as in your backend (casing included) because that's how the WeWeb plugin will be able to identify the users that have that role.In addition, when you add several roles to a user group, a user needs to have BOTH these roles to be part of the user group. It's an AND statement, not OR.In the example below, the members of the Premium customer user group must have both the Customer and the Premium roles associated with their user profile:Private pages ​When you setup the Token Based Auth plugin, an Authenticated users user group will be created by default even if you don't define additional user groups.You can use this user group to restrict access to a page:If you have user roles in your backend, you can add user groups in WeWeb that refer to those user roles and restrict access to pages further:Signup and login workflows ​When you add the Token Based Auth Plugin to a WeWeb project, new elements will appear in the Add menu under the Plugins section:signup forms,login forms, anduser profile forms.You can add an authentication form by drag-and-dropping it on the Canvas.You will find a no-code workflow on the Form Container which you can configure to suit your needs.In step 1, we make an API request to POST the user's email and password to our auth provider. The URL endpoint and requested information will depend on your auth provider:In step 2, we store the user token from the result of the previous action:In step 3, we fetch the user before redirecting the user to another page in step 4.In the example above, we are using a Custom Header authentication type but the logic remains the same for signup, login, custom header, auth bearer, and auth basic.Based on the information provided by the user in the Form, i.e. the Component Variables in the Form Container, you:make an API call to your auth provider with the API request action,store the user token with the Store token action,fetch the user with the Fetch user action, based on the token stored in action 2, andredirect the user to the appropriate page with the Change page action."
  },
  {
    "h1": "WeWeb Auth​",
    "url": "https://docs.weweb.io/plugins/auth-systems/weweb-auth.html",
    "content": "WeWeb Auth ​Plugin limitations ​At WeWeb, we specialize in frontend development. The WeWeb Auth plugin was built on top of Amazon Cognito to help you build a proof-of-concept app with basic authentication needs.WARNINGThe WeWeb Auth plugin is helpful to test an idea inside the WeWeb Editor or with a small user base on a published app.It is not intended to build a web-app that scales with a large user base or complex roles and permissions.Plugin limitations include:the number of user signup emails you can send is limited to 20/day.the number of password recovery emails you can send is limited to 20/day.the list of users cannot be synced with backend.To develop a secure web-app that scales, we recommend integrating an external authentication system, using:one of our native integrations (e.g. Xano Auth, Supabase Auth, Auth0), orone of our backend-agnostic plugins (e.g. token-based auth, OpenID).WeWeb authentication ​You can use WeWeb's native authentication system to build a proof-of-concept app with basic authentication needs.WARNINGThe video was recorded before the latest WeWeb UI update but the logic remains the same. If you're unsure where to find something in the new interface of the WeWeb editor, you can see what changed here.Add the plugin ​To add WeWeb Auth, go to Plugins > Authentication > WeWeb Auth.Leave the default Configuration options and choose the page where users are redirected when they are not signed in. For example, a login page:TIPNote that, if you click on the Configuration options, you'll see the template emails we send out when you invite new users to join your app. If you'd like to change those template emails, please use the contact us link to let us know.WARNINGIf you remove the WeWeb Auth plugin from your project, it will delete all users, roles, and groups from WeWeb. You will not be able to retrieve this information after removing the plugin.Manage users ​In the Auth panel, you can add users one by one manually or import a CSV file with a list of users:Add Users ​Attributes The email address is required. All other attributes are optional.Note that, for now, you can only add string attributes. So if you select the image attribute, you will need to pass it a URL in string format.Password For each user, you can generate a password or set one manually. If you set one manually, it will need to be at least 6 characters long.Invitation email Here you decide if you want to send an invitation email to the user or not.Update user ​In the Auth > Users sub-menu, you can select a user to edit their info, attributes, password, and user roles.Note that, while you can update a user's password, you cannot see their current password for obvious security and privacy reasons.You can also:Block a user. Blocked users will not be able to authenticate to your WeWeb app.Unblock a blocked user.Copy a user's ID.Delete a user. Deleted users will not be able to authenticate to your WeWeb app.User roles & user groups ​To assign a role to a user, go to Auth > Users and select the user you want to assign a role to:To gate content in WeWeb based on user roles and permissions, you will need to:open the Auth panel,go to the Roles tab,create user roles,create user groups, andrestrict access to pages based on user groups.How user groups work ​A user group is a combination of user roles.Let's say you're building a web app for a car rental company. You could have 3 user roles:Admin, for employees,Customers, andPremium, for employees and loyal customers.And 2 user groups:Admin, that would allow you to gate content so non-employees can't access itPremium customer, that would display the best cars to premium customersWARNINGIt's important to understand that a user needs to have all the roles listed in the user group.In the example below, the members of the Premium customer user group must have both the Customer and the Premium roles associated with their user profile:Private pages ​One of the main uses for user groups is to gate content.When you setup the WeWeb Auth plugin, an Authenticated users user group will be created by default even if you don't define additional user groups.You can use this user group to restrict access to a page:If you have defined user roles, you can add user groups that refer to those user roles and restrict access to pages further:Signup, login, logout flows ​Once you have added the WeWeb Auth plugin, you'll want users to be able to:signup,login,logout,change their password,update their user profile, etc.You can do this with dedicated WeWeb Auth workflow actions:You can build your own designs or use the WeWeb Auth UI elements in the Add menu to get started:"
  },
  {
    "h1": "XANO authentication​",
    "url": "https://docs.weweb.io/plugins/auth-systems/xano-auth.html",
    "content": "XANO authentication ​Xano pre-requisites ​In order to set up Xano authentication in your WeWeb project, there are three prerequisites:you already have an account with Xano ✅you have a user table in your Xano database with at least two fields: login and password ✅you have the three authentication API endpoints in Xano ✅Some Xano templates include a user table and the three authentication API endpoints.However, if you don't have both in your Xano workspace, you'll need to set them up manually.Here's how.User table in Xano ​Your user table should include at least two fields:one field where you store the login, for example, a string field with a name or an email field with an email address, andone field of field type password where you store the encrypted password.TIPChoose the field type password when creating your user table in Xano to ensure that the user input is encrypted when the user first creates an account with your web-app. Hashing passwords is best practice and will ensure that you can use Xano’s authentication API points.Authentication endpoints ​For Xano authentication to work, you need three API endpoints:signuploginmeIf you’re using a Xano template that includes authentication, you’ll find these endpoints in the API sub-menu.Otherwise, you’ll need to create these three endpoints yourself by going to API > Add API Endpoint > AuthenticationPlugin configuration ​To add the Xano Auth plugin in WeWeb, go to Plugins > Authentication:You will be invited to provide the following information:a Xano access tokenwhat Xano instance and workspace you want to work with,your Xano custom domain if you have one,the me, login, and signup endpoints from your Xano project, andwhat 3rd-party providers you want to work with (assuming you have any activated in the Xano workspace you selected)WARNINGThe Metadata API Key field expects the value of the Xano personal access token.Make sure to paste the access token itself, NOT the key ID of the access token:Note: you will only be able to view the access token once, when you first create it. Make sure to copy/paste it there and then or you might have to create a new access token down the line.Data source & branching (optional) ​Depending on your Xano plan, you may have the option to support multiple data sources and branches.For example, you could have a live data source and a test data source:In WeWeb, you could decide to work with different data sources depending on whether you're working:inside the WeWeb editor,on the app published in the WeWeb staging environment, oron the published app in production.In the example below, we chose to work with the data from the test data source inside the WeWeb editor, and on the app in staging:As a result, when working in the WeWeb editor or viewing the app published in staging, the data that is displayed will be the data from the test data source in Xano. We will not be able to see or work with the data in the live data source.WARNINGAs per Xano's user documentation, \"it's important to note that a test data source will have exactly the same data schema and structure as your live environment. You cannot change, edit, or delete the schema or database tables in your test data source environment. The test environment allows you to use different data or records so that you can perform tests in your API without affecting your live data.\"The same logic applies if you want to work with different Xano branches. In the example below, we will test the Xano v2 branch in the WeWeb editor and the app we publish on the staging environment but the Xano v1 branch will still be live in our app in production:When we're ready, we can decide to make the v2 branch live in Xano and update the Xano data source plugin in WeWeb.WARNINGWhen working with workflows in WeWeb, we will list all the fields that are available in the LIVE Xano branch, even if you have chosen an EDITING Xano branch for the WeWeb Editor in the Xano data source plugin configuration.To avoid confusion, we recommend that all your Xano branches include the same fields.Global headers (optional) ​If you need to add custom global headers to a Xano call, you can configure these:in the Xano data source plugin,in the Xano Auth plugin,at collection level, orat action level when making a request in a workflow.Define redirections ​Here, you should choose a PUBLIC page where users who are not signed in can be redirected.In the example below, we chose to redirect unauthenticated users to a login page but it could be any page as long as it's a public page:WARNINGMake sure you redirect unauthenticated users to a public page. If you redirect unauthenticated users to a page that is only accessible to authenticated users, you'll be creating an infinite loop and your app will crash.User role configuration ​PRE-REQUISITE IN XANOIn order to gate content in WeWeb based on user roles and permissions, you first need to have information about roles in your Xano database and that information needs to be accessible to WeWeb via API.For example, you could create a role column in your user table in Xano and make it available in the me endpoint so that, when a user logs in to your app, you fetch their role at the same time:Assuming you have information about a user's role in Xano and that information is available in the me endpoint, you can tell the Xano Auth plugin in WeWeb where to find that information.In the example below, we see that the user returned by the me endpoint in Xano provides a single role in a single text in the role column:So we tell the Xano Auth plugin in WeWeb that it can find the role of our user in a text column named role:WARNINGThe Role key is case sensitive. If the column name in your backend is Roles, you should type this in exactly: roles won't work.The Role type must match the data type where you store user role(s) in your backend. In the example above, it's a single Text in a column named role but other common use cases could be a List of texts named roles or a List of objects named users.Signup and login flows ​When you add the Xano Auth plugin to a WeWeb project, you will get access to a new Xano Auth category of UI elements in the Add menu:The login and signup forms both include a workflow with login and signup actions respectively but you'll need to adapt it to suit your login and signup flows.For example, if you want to display a modal for users to login, you could add a Change variable value action to close the modal once the login is complete.In the example below, we added a Change page action to redirect the user after they log in:WARNINGSignup workflows will fail if:the user already exists in the Xano user base, orthe password does not match the requirements defined in Xano.Login workflows will fail if:the user does not exist in the Xano user base, orif the password does not match the user's stored password.Learn how to build a nice UX to manage user errors.Conditional display ​One you've setup user authentication, you'll probably want to display some things conditionally.For example, you'll want to display a logout button when the user is authenticated.You can do this by binding the display of your login and logout buttons to the isAuthenticated variable in the User tab:WARNINGConditional display and conditional rendering can help you build a nice user experience but should not be used as a security measure to hide user data.Always make sure only authorized users can access personal information.Learn more about building secure web-apps with WeWeb.Private pages ​By default, once you've added the Xano Auth plugin to your WeWeb project, you'll be able to make pages private.You'll have the option to choose if a page should be accessible to everybody or authenticated users only:If you have gone through the User role configuration step in the Xano Auth plugin, you will also be able to:add user roles in WeWeb (these role names should match the role names you have in Xano),create user groups and decide what role or roles a user needs to be part of that group, andmake a page private based on these user groupsNote that you can also make a page private to a user group at page level:WARNINGIt's important to understand that a user needs to have all the roles listed in the user group.In the example below, the members of the Premium customer user group must have both the Customer and the Premium roles associated with their user profile:Fetch Current User Data ​Once you have setup authentication in your project, you'll probably want to display data that is related to the current user.For example, if you were building a web-app where users can view and download their pay slips, you'd want to fetch and display only the pay slips from the user who is currently logged in.Filter data in the backend ​In theory, you could get all the pay slips from all the users and filter the Collection in WeWeb based on the current user but you definitely do not want to do that.Why?Because if you did that, you would be loading all the information from all your users in the frontend.Even if you added a filter and only displayed the current user's information on the page, other people could access it in the browser.So what should you do?You should filter the data on the current user at backend level, i.e. make sure Xano only sends you the information from the user who is currently authenticated.How do you do that?In Xano, you would have a table with all your users, and a table with all the pay slips. Each pay slip would be linked to a user.Now let's take a different example. Let's work on a web-app where users can apply to jobs.In Xano, we have a list of job applications. Each job application is linked to a user_id in the user table:Clone the API endpoint closest to the data you need ​In our case, we want to return a list of job applications for the current user.In the API menu, we have a default API to GET all the records from the application table.Let's clone this endpoint to create a new one that will only GET the applications of the authenticated user:Secure the endpoint with authentication ​Now that we have this new user-application endpoint, we need to make sure our GET request will only go through if the user making it is authenticated:Pre-requisite: you have set up a user table with authentication endpoints in Xano.Why are we doing this?So that we can get the user's id from the authentication token provided by Xano when the user logs in. This ensures that no one can guess what API request to call with a user email for example.Add a filter to query user specific records ​Instead of querying all the records from the application table, we want to query only the records where the linked user's id matches the id in the authentication token generated when a user logs into our web-app:Getting the filtered data to WeWeb ​Now that we have an endpoint that requires authentication and sends back filtered data based on the authenticated user, we can create a data collection in WeWeb in the Data panel:And that's it!You've now ensured that only an authenticated user can access their own data.WARNINGTo fetch data from a Xano endpoint with authentication enabled, you must first login as a user in WeWeb.In the example above, you can see user 1 is authenticated in WeWeb. As a result, Xano returns all the applications with user_id 1.The same logic applies to call endpoints that require a specific role with a precondition on the Xano endpoint. You must be logged in as a user that has the requested role(s) in your WeWeb application to be able to call such endpoints successfully.Troubleshooting Xano Authentication ​If you're experiencing issues with the Xano signup or login forms, you can test the entire workflow or one action at a time and look at the response when it fails.Xano will return an error message in response > data > message:Most common errors ​trying to sign up a user that already exists in the user base in Xano (need to login instead),trying to sign up a user with a password that doesn’t match Xano’s default requirements (at least 6 characters and 1 capital letter at the time of writing),trying to login a user that doesn’t exist in the user base in Xano (need to signup instead)trying to login with invalid credentials.If you don't find a solution using the WeWeb debugger, consider using the Run & Debug command in Xano directly to make sure everything is properly set up in the back-end.Forgot Password with Xano Auth ​WARNINGBefore we show you how to set things up in WeWeb, let's explain what you need to setup outside of WeWeb.If you are using the Xano Auth Plugin in WeWeb, there are 2 pre-requisites to enable users to reset their password securely.Pre-Requisite #1: Sendgrid AccountPre-Requisite #1: Sendgrid AccountFirst, you'll need to open a Sendgrid account.This will enable you to send an email with a \"magic link\" to users who have forgotten their password.When the user clicks on that link, they will be redirected to a page of your WeWeb app where they will be invited to choose a new one.But more on that later…Pre-Requisite #2: Magic Link Endpoints in XanoPre-Requisite #2: Magic Link Endpoints in XanoIn Xano, you will need 3 API endpoints in addition to the 3 usual authentication endpoints (i.e. signup, login, and me).These 3 additional endpoints are:magic-link – sends a unique link to user who forgot their passwordmagic-login – allows the user to login without a password using the magic linkupdate-password – updates the user's password in the user tableIn order to get these 3 new authentication endpoints, we recommend you:add this Password Reset snippet in Xano,watch their video explaining how the Password Reset snippet works, andwatch this video on how to configure your environment variables in Xano.You can leave the redirect URL values empty for now. We'll come back to these a couple of paragraphs down.Once you've setup Xano and Sendgrid as explained above – barring the redirect URLs – you'll be able to set things up in your WeWeb user interface.Step 1: Create Dedicated Pages in WeWeb ​In WeWeb, you'll want to create 2 pages.The first page with a \"Change password\" section: The second page with an \"Reset password\" section: Once you have created the \"Update password\" page, you'll be able to update the magic_link_redirect_uri variable in your Xano settings:The value will be the URL of the page which contains the \"Update password\" form.TIPFor testing purposes during the setup and/or if you are not yet ready to publish your WeWeb project, you can paste the URL of the page in the Editor – with the https://editor.weweb.io/abcd123 format – instead of the URL of the published page – with the https://abcd123.weweb-preview.io format.Step 2 – Workflow to Request Magic Link ​On the \"Forgot password\" Form Container, you'll notice there is a Workflow.Here's how you update it to ensure the user receives an email with a magic link when they submit the form:copy the Xano API endpoint that requests a magic link, andbind the email query string field to the email value variable in the form.Depending on how you created your endpoints in Xano – using the Starter template or installing the Magic Link with Sendgrid extension for example – the endpoint may have a different name – request-magic-link or magic-link for example.TIPBefore moving to the next step, add your email address to your user table in Xano, then test the workflow with your email address to make sure you receive a magic link in your inbox.Step 3 – Workflow to Reset the User's Password ​You'll also need to update the Workflow on the \"Update password\" Form Container.Action 1: Login with the magic link ​First, you'll need to copy the API endpoint that allows the user to login with a magic link:Again, the API endpoint may have a different path depending on how you created it in Xano. Make sure it's the one that allows the user to login with a magic token instead of a password.Then, in WeWeb, you'll need to create a Variable of type Query, named token:Why of type Query?Because when the user clicks on the magic link in the email, they will be redirected to the URL you pasted in the Xano settings with an additional query string at the end that contains a magic token.It will look something like this:Why name it token?Because, as you can see from the screenshot above, in the magic link provided by Xano and Sendgrid, the parameter at the beginning of the query string is token.If we want WeWeb to get the value from this query string, we need to give our Query Variable the same name.Finally, you'll need to bind that token variable to the magic_token field:Why name the field key magic_token?Because that's the name of the input variable in Xano by default:WARNINGIf your input variable is named differently in Xano, make sure the field name matches in WeWeb.Action 2: Update the password ​When the user submits the form, the first step will be to log in using the magic token in the magic link. That's what we saw in action 1.The second action will be to update that user's password in the user table with the information submitted in the form.EndpointFirst, you'll need to paste the update-password endpoint from Xano.You should bind the password and confirm_password values to the Form Variables and the Authorization field to the authToken returned by Action 1 of the Workflow:TIPMake it a habit to \"Run & Debug\" your API endpoints in Xano before testing things in WeWeb. When something is broken, this will help you figure out if you should look for a solution in Xano or WeWeb.I'm sure the Xano team will fix this quickly but we ran into a couple of glitches during our setup using their Starter template.Here's how to make sure the update-password endpoint is setup correctly:1- User field_value ​First, make sure the user inputs are setup correctly in the update_password endpoint.The field_value which should be auth > id:Depending on how you created the endpoint, it may be missing or appear as text > id.2- Input types of password and confirm_password variables ​In the Starter template, these two variables are of type Password.After chatting with Xano's support team, it turns out you should delete these two variables and add two Text Inputs instead:\"Sounds weird, but let me explain. When Xano has a password as type: password, it's hashed and secured so it can not ever be viewed again. So, when you send \"password\" and \"confirm_password\" as password type values, they both have different hashes, and when your precondition says \"hey, are these the same?\" Xano is going to say \"no, they're not\" because those hashes are unique every time they generate. So, if you just change those inputs to text, everything should work.\"So your two text inputs should look like this:Action 3: Redirect user to a login page ​Once the user has updated their password, you'll usually want to redirect them to a login page.If you'd like to redirect them to another page, we recommend you add a step before the Change page Action where you will login the user with their new credentials.TIPYou can setup an On error workflow that triggers if the user's new password doesn't match the conditions in Xano in terms of length and complexity for example.And that's it!You've successful setup a forgot password flow for your users using WeWeb, Xano Auth, and Sendgrid 🙂OAuth (social sign-in) ​Pre-requisites ​Before you can setup a signup and/or login flow with a third-party provider in WeWeb, you'll need to:created and configured a project with the OAuth provider of your choice (e.g. Google, Slack, LinkedIn, etc.)installed and configured the related OAuth extension in Xano with the OAuth credentials provided by the providerTIPIf you are new to OAuth and need help understanding how to configure things with your provider, consider reading our article on how to add Google OAuth with OpenID where we go into more detail about:setting up an OAuth consent screen, andconfiguring the correct redirect URLs with a provider.Assuming you have added and installed an OAuth extension in Xano, you will be able to see the provider(s) in the configuration of the Xano Auth plugin:TIPIf you can't see the OAuth provider you're looking for, check that it is correctly installed in Xano in Marketplace > Purchased:Login or signup flow ​The first step to allow users to signup or login with an OAuth provider is to trigger a workflow, for example, on click of a \"Continue with Google\" button.In that workflow, you'll need to:choose the Login Provider action,select which provider you want to work with, andredirect the user to a public, blank pageThis last step is crucial (more on this in a second).In our case, we named the page Login with provider redirect page to be super explicit but of course, you can choose a shorter name. It doesn't really matter since the user will not even notice they are routed through this page.Public blank page for 3rd-party ​Before your app is fully secured, it needs to render a page to save the authentication cookies and get back the user from the OAuth provider. That needs to happen on a public page.Then you can redirect the user to the page of your choice, public or private.The process is the following:user selects Oauth provider on your WeWeb appuser is redirected to the Oauth provider consent screenuser is redirected back to your WeWeb app, on a public page, where cookies are setupuser is redirected to a private page on your WeWeb appWe took care of steps 1 through 3 when we created the workflow with the Login Provider action above and redirected users to an empty public page.Now we need to trigger a workflow on that page so that the authenticated user is immediately redirected to the page we want them to see post signup/login:The workflow should have:a trigger On Page Load (before fetching collections) because you want to redirect the user as soon as possiblea Change page action that redirects the user to the page you want them to see after signing up or logging inThat's it, you've got OAuth configured on your Xano project."
  },
  {
    "h1": "Airtable data source​",
    "url": "https://docs.weweb.io/plugins/data-sources/airtable-data.html",
    "content": "Airtable data source ​TIPIf you enjoy learning with video, consider watching our 4-part Airtable mini-course to learn the basics of the WeWeb x Airtable combo:How to get and display data from Airtable in a WeWeb appHow to search and paginate an Airtable collection in a WeWeb appHow to use Airtable related fields in a WeWeb appHow to write data to Airtable from a WeWeb appAdd the Airtable plugin ​In order to get data from Airtable, you first need to add Airtable as a data source in WeWeb:Go to PluginsBrowse through Data sourcesSelect AirtableAdd your personal access tokenMake sure to click Continue to add the pluginThen Add a collection of Airtable dataAccess token vs API key ​WARNINGIn 2022, Airtable shut down API keys. You now have to enter your Personal Access Token to connect your Airtable account to WeWeb.You can create Airtable access tokens here.Make sure to set it up with the access to the base you want to use in WeWeb, and the proper scopes:data.records:read so that your app can read data from Airtabledata.records:write so that your app can write data to Airtableschema.bases:read so that your app can read the schema of your Airtable base and know which types to use in workflows' actionsAccess token vs token ID ​WARNINGWhen configuring the plugin in WeWeb, make sure you are adding the Airtable access token itself and not the token id of the access token.When configuring the Airtable plugin in WeWeb, a common mistake is to add the TOKEN ID of an Airtable access token:That won’t work.You need to make sure you copy the access token itself when you first create it:You won’t be able to see it again so if you didn’t copy the Personal Access Token when you first created a token, you might need to create a new one.Create a collection ​Once you’ve connected an Airtable account to WeWeb, you will be able to create Airtable data collections in WeWeb:TIPTo build dynamic web applications, we highly recommend creating Dynamic collections.However, if you run into Airtable rate API limits, you may want to consider working with a Cached collection instead.Learn more about WeWeb collection modes.Select data to fetch ​Once you've selected a source for your collection, you will get access to the Configuration tab, you can select very precisely what data you want to fetch from Airtable.Required fields include the base, table, view, and fields you want to fetch:Filters by formula ​SECURITY WARNINGFilters by formula are a performance tool, NOT a security or privacy tool. Indeed, filters by formula can help you optimize the performance of your web app by optimizing the data you load on the page. However, keep in mind that the query parameters are visible in the API call that is made to Airtable by the frontend.This is not specific to WeWeb. It is how Airtable's API currently works.If you need security: make sure to use a backend with the capacity to enable authentication and access control checks on API endpoints (e.g. Xano) or RLS on the database (e.g. Supabase).Learn more about adding security to the web-apps you build with no-code tools.With filters by formula, you can query data with filters so that Airtable only sends specific data to your WeWeb frontend.The filters available are documented in Airtable's own API documentation.For example, you can user a filter by formula to search a text through a list of items: SEARCH(stringToFind, whereToSearch)In WeWeb, it would look something like this: 'SEARCH(\" ' + variable + ' \", Car_name)'The tricky part here will be getting the quotes right because the Airtable API expects the search term to be in between quotes like it is here:Indeed, in the Current value displayed in WeWeb, you can see the entire formula is in between quotes and so is the search term \"Volk\". That is the data format expected by Airtable's API. Make sure to stick to it.WARNINGFilters by formula are a performance tool, not a security or privacy tool. Indeed, filters by formula can help you optimize the performance of your web app by optimizing the data you load on the page. However, keep in mind that the query parameters are visible in the API call that is made to Airtable by the frontend.This is not specific to WeWeb. It is how Airtable's API currently works.If you need security: make sure to use a backend with the capacity to enable authentication and access control checks on API endpoints (e.g. Xano) or RLS on the database (e.g. Supabase).Learn more about adding security to the web-apps you build with no-code tools.Fetch data ​Once you've configured the data you want to fetch from Airtable, you can decide if you want to fetch this collection automatically and if you want to preserve it on navigation:Fetch automatically ​When Fetch this collection automatically is enabled, the collection will automatically be fetched when a page that contains the collection is loaded in the user's navigator.Sometimes, you want to disable this option to have finer control of where and when the data is fetched.For example, you might want to fetch a collection when a user clicks on a specific button in your app.Preserve on navigation ​When Preserve on navigation is enabled, the collection is only fetched the first time a user loads a page with that collection.Sometimes, you want to disable this option to have finer control of where and when the data is preserved in the user's navigator.For example, you might want to make sure that a user's data is not preserved on navigation so that, if two users login from the same computer, user A can't see user B's data after they've logged out.Sort, filter, and paginate the data in WeWeb ​At this stage, you have fetched the data from Airtable. It is available for use in WeWeb.Any sort, filter, or pagination you add here is done in the frontend. This means that, even if the data is not displayed on the page, it is accessible in the user's browser. Learn when to use frontend vs backend filters.Learn how to display Airtable collection data in WeWebUpdate Airtable data ​Use case: when a customer returns a rental car, you want employees at the rental location to update the mileage of that car.In order to do this, you will have to create a workflow that allows users to create, update, or delete a record in Airtable:Once you have chosen the type of action you want to trigger, you will be invited to send information to Airtable:In the example above, you can see:we will update the recordin the Fleet - Dynamic collectionthat has the same id as the id in our selectedLine variablewe will update the Mileage columnwith the the 506 valueWARNINGIf the field in Airtable is a number, make sure to send a number. If you try sending a text to a number field, you will get an error. If you try sending a number to a multi-select field, you will also get an error.Learn more about variables and data types.Partial update ​If you want to update specific fields in Airtable and not an entire record, make sure to only select the fields you want to update.In the example below, you can see (on the right) that we only selected the Mileage field. As a result, when we test our action, we can see in the payload sent to Airtable (on the left) that we are only sending data to update the Mileage field of the record:If we select all the fields without filling in values, we are telling Airtable, please replace the values in these columns with null.In the example below, the columns Car_name, Image, PDF, etc. will now be empty for that record in Airtable because we told Airtable the value for these fields are null:Host Airtable images and files on a CDN ​It is no longer possible to use Airtable's attachment hosting because links will only last 2 hours before they need to be regenerated.What's the impact on your WeWeb projects?When using dynamic collections, you can still use Airtable attachments as image or file URLs in WeWeb because the links are fetched when you fetch a collection (on page load by default or when you trigger the fetch in a Workflow).However, if you are using static or cached collections, you'll need to upload your Airtable attachments to a CDN like Cloudflare or AWS S3, and use the links from the CDN in WeWeb.We realize it's hard tedious work, so we made a small tutorial on how to fix this automatically on Airtable by using Xano to host images, and a small Airtable automation.Step 1: make sure you've got a Xano instance and an endpoint to upload content.Step 2: in Airtable, create a new text column on your table that'll be used to store the images' URLs in the CDN:Step 3: in Airtable, create an automation that is triggered \"When record updated\" and watch your former image/file column:Step 4: add an action to run a script and copy/paste this script:javascriptconst xanoBaseUrl = 'https://xc0b-vcze-d4we.n7.xano.io' // Edit this variable to match your Xano instance subdomain let table = base.getTable('property') let config = input.config() let recordId = config.updatedRecordId let record = await table.selectRecordAsync(recordId, {fields: table.fields}) let images = record.getCellValue('images') // Update this value to match your image/file attachment column let imagesUrlCdn = [] for (let image of images) { let imageUrl = image.url let result = await fetch(xanoBaseUrl + '/api:SJOHbPGi/upload/image', { // Update this path to match your Xano upload file endpoint method: 'POST', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify({'content': imageUrl}) }) let response = await result.json() let imageUrlCdn = xanoBaseUrl + response.path imagesUrlCdn.push(imageUrlCdn) } await table.updateRecordAsync(record, { 'images_urls': imagesUrlCdn.join() // Update the key to match your newsly created URL column })Step 5: replace xanoBaseUrl by your own Xano instance and change the column names in the script to match the ones in your table (they are marked with comments in the script).Step 6: activate the automation in Airtable. Now, every time an attachment is added to the column in Airtable, the newly created URL column will display the CDN's URLs, joined by a comma (\",\").To use the images in WeWeb, simply use this newly created column as your images source inside your project (you can get back the URLs by splitting the string on the commas, like so):"
  },
  {
    "h1": "Algolia​",
    "url": "https://docs.weweb.io/plugins/data-sources/algolia.html",
    "content": "Algolia ​Configure the Algolia plugin ​To read Algolia data in WeWeb, you first need to add the Algolia plugin: Once you added it to your project, you'll be invited to copy/paste your Algolia Application ID, Search-Only API Key and Admin API Key in WeWeb: These are available in the Algolia dashboard under settings > API keys: Add an Algolia Collection in WeWeb ​Algolia's whole purpose is to efficiently full-text search among a set of records. So, the first thing to do inside the WeWeb app is to add a search input that we'll use later to search the Algolia collection.Inside WeWeb, go to the Add panel and drag and drop a Search bar to your app: Now, time to add a new collection. Click on Data, then on + New, you'll be invited to give your collection a name and choose Algolia as a data source: In the configuration panel, select the Algolia index you want to use for your collection. Also, select the search bar you just added before and bind it as the collection search parameter: Add a pagination (optional) and finish by fetching your collection. If everything went fine, the records should appear like so: If not, double-check your Algolia configuration!Display Algolia data in WeWeb ​Assuming you were able to fetch data from Algolia in a WeWeb Collection, you'll be able to bind the data from that collection on your pages.In the example below, we chose to display the Aloplia CRM index (containing a logo, name, job title, company and industry) in a Data Grid element: 🔥 Pro Tip 🔥You can bind arrays of data to any Container in WeWeb. Just bear in mind that the first child of the Container you bind the Collection to will be the repeated item. With that in mind, you might want the first child Element to be another Container with a number of items inside like a title, description, button or image.Search Algolia Data inside WeWeb ​Algolia's whole purpose is to benefit from its powerful search. In order to do so, first configure your Algolia search in your Algolia index dashboard.Once the search is setup, we only need one more thing to do inside WeWeb.Remember the search input we drag and dropped before?We need to select it and add a on change workflow, that will trigger a fetch collection action on the Algolia collection:And voilà! You now have a fully working Algolia search inside your WeWeb app 👏"
  },
  {
    "h1": "REST API data source​",
    "url": "https://docs.weweb.io/plugins/data-sources/rest-api.html",
    "content": "REST API data source ​Add plugin ​To work with external APIs that don't have a native WeWeb integration, you can go to Plugins > Data sources > REST API:There is no configuration required.Make API calls ​Once you have added the REST API plugin to a WeWeb project, you will be able to:create a data collection that fetches data from a REST APIcreate a workflow that makes an API requestTIPWe recommend using collections when you are fetching data that might need to be filtered and paginated.To make an API call that creates, updates, or deletes a record, you will need to create a workflow.Security ​When you make an API call with the REST API plugin in WeWeb the request is made by your application (i.e. client-side request from the frontend, your browser).You should never use private API keys in REST API calls made through the client.Learn more about public and private API keys.Create a collection ​To get and display data sets that might need to be filtered or paginated, you can create a collection in WeWeb.In the example below, we fetched a list of characters from the Rick & Morty API:You can see that:in the Data tab,we clicked on New to create a new collection,we gave it a name and chose REST API as a data source,we configured our API calls as we would in tools like Postmanwe have options to filter and paginate the collection in the frontend, decide when the collection will be fetched, and if we want it to be preserved on navigationWARNINGWeWeb's REST API plugin only accepts HTTPS requests. If you're trying to follow this tutorial with a public API that uses HTTP requests, WeWeb will return an error message.Headers ​If your data can only be accessed by authenticated users, don't forget to add Authorization headers to your API call and login as a user of your WeWeb app. Otherwise, the API will return an error when you try to create the collection.Result key ​Sometimes, APIs will return the data you need in a nested object. When that happens, it can be helpful to use the Result key field to fetch only the information you need.For example, when we get a list of characters from the Rick & Morty API, the API returns two objets:info, with info that we could use to setup backend pagination, andresults, with a list of Rick & Morty characters.If we don't intend to setup backend pagination on that collection, the info object is useless to us and adds uneccessary complexity when working with this data set.To access the information inside the results object directly, we can add results as a value in our Result key field:TIPThis is not a WeWeb specific practice. In web development, you always want to avoid fetching data you don't need.API calls in workflows ​Once you've added the REST API plugin to your project, you will have access to the REST API Request action.In the example below, you can see we:chose the REST API Request action type,decided to make a POST request,entered the URL or our endpoint,bound the name of two fields to update with values, andconfigured authorization headers to tell our API who is making the callResolving CORS Issues ​When you make an API call in WeWeb the request is made by your application (i.e. client-side request from the frontend, your browser).But sometimes, APIs only accept requests that come from a server (i.e. server-side requests from the backend) and return CORS errors. This is the case for the Twitter API for example.You can bypass CORS issues by enabling the Proxy the request to bypass CORS issues option on your API call:WARNINGWhen you enable the Proxy the request to bypass CORS issues option, WeWeb will proxy the request to bypass CORS errors but the information will still be visible in the client.This option is not meant to keep private tokens private. You should never use private API keys in REST API calls made through the client.Debugging API Requests ​When you start working with APIs, you'll run into a lot of errors.It's completely normal and nothing to worry about 🙂WeWeb will display error messages to help you figure out what went wrong.The top 4 reasons for errors are:you're trying to make an http request when WeWeb only accepts https requeststhe API you are working doesn't accept client-side requests (see \"Resolving CORS issues\" section above)you are trying to get or udpate data that is protected in your backend but you are not logged in as an authorized user to get or update this datayou are sending data to the API in a format it does not recognize. For example, trying to update an integer field but sending a string.Learn more about debugging API requests."
  },
  {
    "h1": "SmartSuite​",
    "url": "https://docs.weweb.io/plugins/data-sources/smartsuite.html",
    "content": "SmartSuite ​WARNINGSmartSuite's API is still in alpha. You might encounter issues when trying to use it in your project. Please refer to: https://help.smartsuite.com/en/articles/4356333-smartsuite-api-overviewConnect a SmartSuite account ​In order to get data from SmartSuite, you first need to add SmartSuite as a data source in WeWeb:To find your SmartSuite API key and Workspace ID, follow the in-app \"How to find it\" instructions:Add a SmartSuite collection ​Once you’ve connected a SmartSuite account to WeWeb, you will be able to create SmartSuite data collections in WeWeb:At this stage, you have fetched the data from SmartSuite. It is available for use in WeWeb.You can add frontend filters and pagination and display the data in your WeWeb project.Update and Delete SmartSuite data ​You can update, and even delete, data in SmartSuite from WeWeb. To do this, you'll need to use the SmartSuite actions in your workflows.For example, let's say that you bound a SmartSuite collection to a Datagrid in WeWeb. Then, you could set up the on row update and on row delete workflows this way:For the delete a record action, you just need to pass the ID of the record to delete.How to Update Single and Multi-select Fields in SmartSuite? ​SmartSuite has a specific format for single and multi-select fields. To help you update these fields, we've created a custom action that you can use in your workflows.This action, named get field choices will return all the current available values for such a field. Then, when updating the record, you can pass the ID of the value you want to set using a lookup formula.Here's a video on how to use it:"
  },
  {
    "h1": "SQL​",
    "url": "https://docs.weweb.io/plugins/data-sources/sql.html",
    "content": "SQL ​Security warning ​WARNINGThe SQL plugin should be used with caution, only for internal app where every user can be trusted.We developed this plugin for specific enterprise needs, building self hosted internal apps. It is not secure to expose such app on internet.Configure query ​The best way to work with SQL queries is to create a custom formulas with parameters.Here is an example: In the example above, we used the following code in our formula:return ` SELECT ${column} FROM myTable WHERE ${column} = '${where}';TIPWhen adding your formula, remember to select the Javascript option to open the code editor and to click on Create to save the formula.SQL request in workflow ​Then you can create a workflow or a collection and use this formula when you need to bind a query. You can easily work with variables in the formula to create Dynamic queries.Like this:"
  },
  {
    "h1": "Supabase​",
    "url": "https://docs.weweb.io/plugins/data-sources/supabase-data.html",
    "content": "Supabase ​Supabase is an open-source backend-as-a-service platform that simplifies app development with integrated tools like a real-time PostgreSQL database, user authentication, file storage, and serverless functions. As an open-source alternative to Firebase, it enables you to build secure, scalable applications without managing complex backend infrastructure.Plugin configuration ​The Supabase plugin connects WeWeb directly to your Supabase project, enabling you to manage your tables, API endpoints, database functions, secrets and integrations right from within the WeWeb interface.To add the plugin in WeWeb:Navigate to Back-end > Add Supabase:Once you've added it, you will have the option to connect to your project in Guided or Custom mode for self-hosted Supabase projects:Grant the necessary permissions to Supabase.Back in WeWeb, you will see that your account is connected and that you will be able to select your existing Supabase project or create a new one:Upon clicking on \"Continue\" to confirm the setup, we can see additional plugin information, such as the configuration, and realtime collections:TIPRealtime tables allow you to see changes to data immediately when they happen, without needing to refresh the page. By default, Supabase disables realtime on tables for performance reasons.This means:You need to turn on realtime both in Supabase first, then in WeWebWhen realtime is on, any changes to your data (like updates, new entries, or deletions) show up instantly for usersIf we click on the Backend panel, the tables from our database:In this guide, we will be working with the properties and properties_images tables.Fetching data ​We can create a collection in WeWeb using Supabase as a data source. This will essentially allow us to get data from specific tables and store them in a collection, which is just a place to store data.Go to Data > NewChoose Supabase as a SourceSelect which database table you want to pull data from:Guided mode ​Guided mode will be enabled by default, which is a mode that pre-configures the collection to pull in data from every available table column without requiring manual selection.In the example below, we decided to exclude the data from the created_at, created_by and updated_ columns in our properties table:As a result, our collection will look like this:Advanced mode ​Advanced mode lets you get information from multiple connected tables at once, rather than just one table at a time.TIPIn web development, this relational retrieval of informations is termed a 'join'.You can join tables when they have fields that relate to one another, allowing you to retrieve records that have the relation from the joined tables.For example, think of your property listings like this:The properties table stores the basic details of each property with the columns:id, address, bathrooms, bedrooms, description, price, square_feet, titleThe property_images table stores multiple images for each property:id, image_url, property_idEach image is linked to its property using property_idimage_url is where the actual image link is storedThe relationship works because each row in property_images has a property_id that matches an id in the properties table, allowing you to know which images belong to which property.A collection can show data from two connected tables. To do this, use this format: name_of_second_table:id(which_columns_you_want)In our properties example, if we wanted to get the related images of a property we would write: property_images:id(image_url)This tells WeWeb to:Look at the property_images tableConnect it to the main properties tableShow only the image_url column from property_imagesSo for each property, you'll see its own details plus its related images, all in one collection:TIPIn the example above, we used a one-to-many database relationship. One property can have many images, but you can also accomplish one-to-one relationships, that is, one property can have one main image from the property_images table. Suppose you have a column in the properties table called main_image which points to the property_images table. We can get its value by writing main_image: main_image(image_url):Row-Level Security ​Row-Level Security (RLS) is a security mechanism that controls who can access or modify which rows in a table. Without RLS, anyone with database access can view, update, or delete all rows.Imagine a school database with a students table. Without RLS, everyone could see all students' records. But with RLS:A student can only see their own grades.A teacher can see only their students' grades.The principal can see everyone’s grades.By default, Supabase allows full access to all data so you can quickly set up and test your apps without restrictions. However, once you enable RLS on a table, Supabase blocks all access until you create explicit policies defining who can read or modify data.Enable RLS for your tableDefine policies for the table:In the example below, we have the following policies:Enable insert for authenticated users only INSERTEnable read access for all users SELECTEnable delete for property owners DELETEEnable update for property owners UPDATEWARNINGIf RLS is enabled for a table but no policies are defined, WeWeb will not be able to fetch data for your collection. To ensure proper access, always create the necessary policies.Filtering, Pagination & Sorting ​When working with large amounts of data in Supabase, you might need backend filtering, pagination and sorting. WeWeb handles this at the collection level. You don't need to set these up in Supabase - simply select your collection and go to the Query configuration section.This means even with, for example, 50,000 records or more, you can efficiently control how your data is loaded and displayed.In the example below, we are getting only five records because the pagination limit is 5!"
  },
  {
    "h1": "Xano​",
    "url": "https://docs.weweb.io/plugins/data-sources/xano-data.html",
    "content": "Xano ​Xano is a visual development backend platform that lets you build custom APIs, manage databases, and handle server-side logic without writing traditional code. Through its visual interface, you can create data storage systems, user authentication, and API endpoints - essentially everything needed to power modern web applications.Add Xano plugin ​In order to get data from Xano, you first need to add Xano as a data source in WeWeb, in Plugins > Data sources:TIPXano recently deprecated API keys. You now have to create an Access Token to connect a Xano account to a WeWeb project.If you have existing WeWeb projects that use the deprecated method of authentication, you don't need to do anything.However, you can choose to update them by going to the plugin configuration step and adding an Access Token:This will ensure your project continues to work properly in the event that Xano stops supporting the deprecated API key completely in the future.No other action is required on the WeWeb side of things. Updating the Xano data source plugin configuration will not affect the collections you previously added to WeWeb using that plugin.Plugin configuration ​When you add the Xano data source plugin, you will be invited to:Add your personal access tokenSelect the Xano instance you want to connectAdd the custom domain of your instance (if you have one)Select the workspace you want to connectWARNINGThe Metadata API Key field expects the value of the Xano personal access token.Make sure to paste the access token itself, NOT the key ID of the access token:Note: you will only be able to view the access token once, when you first create it. Make sure to copy/paste it there and then or you might have to create a new access token down the line.TIPThe custom domain field is optional. It is useful if you need to:replace the base URL of Xano with the custom domain you setup in Xano, orreplace an old base URL with a new base URL (e.g. if you went from a free plan to a paid plan in Xano)Generate access token in Xano ​To generate or find your access token in Xano, you have 2 options.Option 1 - go to Account > Metadata API:Option 2 - go to the Metadata API section in the Settings of your instance:WARNINGBy default, when you create an access token in Xano, all the options will be enabled:Depending on your use case, you may want to customize those settings.Bear in mind, however, that these settings will affect what you can and cannot do in WeWeb.For example, if you remove the reading rights to the Database and API Groups, WeWeb will have no way of fetching the data from your tables.Data sources (optional) ​Depending on your Xano plan, you may have the option to support multiple data sources.For example, you could have a live data source and a test data source:TIPAs you can see above, Xano will display a banner at the top of your workspace to remind you what data source you're looking at at any given moment.In WeWeb, you could decide to work with different data sources depending on whether you're working:inside the WeWeb editor,on the app published in the WeWeb staging environment, oron the published app in production.In the example below, we chose to work with the data from the test data source inside the WeWeb editor, and on the app in staging:As a result, when working in the WeWeb editor or viewing the app published in staging, the data that is displayed will be the data from the test data source in Xano. We will not be able to see or work with the data in the live data source.WARNINGAs per Xano's user documentation, \"it's important to note that a test data source will have exactly the same data schema and structure as your live environment. You cannot change, edit, or delete the schema or database tables in your test data source environment. The test environment allows you to use different data or records so that you can perform tests in your API without affecting your live data.\"Branching (optional) ​Depending on your Xano plan, you may have the option to support multiple branches.In Xano, a branch is \"a copy of a workspace's business logic (APIs, Functions, Addons, and Tasks).\"WARNINGBranches in Xano do not apply to the database. To enable test data in Xano, you need to create a test Data source.Creating a branch in Xano allows you to make changes to your API endpoints, functions, add-ons and tasks in a safe environment, without affecting your app in production.In the example below, we created a v2 branch in Xano to add features related to admin permissions in our app:In WeWeb, we continue to use the Xano v1 branch in our app in production, but we use the Xano v2 branch to test things in the WeWeb Editor and in our app published in staging:When we're ready, we can decide to make the v2 branch live in Xano and update the Xano data source plugin in WeWeb.WARNINGWhen working with workflows in WeWeb, we will list all the fields that are available in the LIVE Xano branch, even if you have chosen an EDITING Xano branch for the WeWeb Editor in the Xano data source plugin configuration.To avoid confusion, we recommend that all your Xano branches include the same fields.Global headers (optional) ​If you need to add custom global headers to all your Xano calls, you can configure these in the Xano data source plugin:Or at collection level:Get data from Xano ​Once you have configured the Xano data source plugin, you will be able to create a collection to get Xano data into WeWeb:Select a source ​In the Data tab, when you create a new collection, you will be invited to:name the collection,select a data source (for example Xano), andchoose a collection mode (for example dynamic).TIPTo build dynamic web applications, we highly recommend creating Dynamic collections.However, at times, when you need to pre-render content or bypass API rate limits from a data source, you may want to consider working with a Static or Cached collection instead.Static: the collection will be fetched once, on our servers, while the app is built. Everytime this collection is used in your app, the data will be pre-rendered (better for SEO, can slow down the publish process).Dynamic: the collection will be fetched on the client side, when the app is loaded. This is the best option if you want to fetch data that changes often (like a list of products).Cached: the collection will be fetched on the client side, but from our servers. This is the best option if you want to fetch data that changes often, but you want to avoid hitting any API rate limit (but you'll need to refresh the data yourself when it changes).Configuration ​When you create the collection, you will be invited to choose the API group and endpoint you want to use in WeWeb.In the example below, we call a GET endpoint in Xano that returns all the tickets related to the user who is currently authenticated to our app:WARNINGIf authentication is enabled on your Xano endpoint, you will need to login as a user of your app in WeWeb to fetch data. Otherwise, Xano will return an Unauthorized error.Same goes if your endpoint requires a user to be have a specific role to read data. You will then need to login as a user with that role to create the collection and fetch data in WeWeb.Fetch data ​By default, Xano collections are fetched automatically and preserved on navigation:This means that:if a collection is used on a page of your app, it will be fetched automatically, andif the user navigates to another page, the collection will not be refetched.There may be use cases where you want to change these default settings.Why disable automatic fetch?If you have a collection that you don’t need immediately on page load, you should consider disabling the automatic fetch to improve performances. For example, you might want to fetch a collection when the user opens a modal on a page and not on page load.If you disable the automatic fetch on a collection, you'll need to remember to trigger a workflow that fetches the collection every where you need it in the app.Why disable preserve on navigation?A common use case where you don't want to preserve on navigation: a collection that fetches a single item selected on a previous page (if you preserve on navigation, there might be a blink where the info from the previously selected item appears while the API call takes place to fetch the info of the new selected item)This is especially problematic if the collection data concerns a specific user with potentially private information. You want to make sure that data is not preserved on navigation in case 2 users connect to your app using the same browser.Sort, filter, and pagination ​Once you have fetched data from Xano, you can add sort it, filter it, and paginate it in the frontend:WARNINGThe video above was recorded on a previous version of the WeWeb editor but the same logic still applies.Once you have added a data collection in WeWeb, you will be able to display that data on a WeWeb page. Learn how to display collection data.Update Xano data ​To update a table in Xano from a WeWeb app, you'll have to create a workflow that makes a request to Xano.In the screenshot below, you can see that:we make a request to Xanothat will affect the Joyce's tutorial - careers API groupwe're making a POST call in the application tableupdating three fields in the tablewe pass the values of these three fieldsUse case: when an authenticated user applies to a job, we make a request to Xano to update the application table with the id of the selected job and authenticated user as well as the URL of the resume that was uploaded by the user.TIPIf the field in Xano is an integer, make sure to pass an integer value in your API call. If you try sending a string to an integer field, you will get an error. If you try sending an integer to a field that expects an array, you will also get an error.Learn more about variables and data types.Using Xano Auth? ​If you have added the Xano data source plugin and are using the Xano Auth plugin for authentication, you do NOT need to bind the user's auth token when adding a Xano collection or using a Xano action in your workflows.The Xano data source plugin will automatically recognize the current user's authentication token and send it to Xano when making an API call.You only need to manually bind the current user's authentication token if you are making API calls to Xano via the REST API plugin and not the Xano data source plugin.Migrating from Airtable to Xano? ​It's fairly common for Airtable enthusiasts to switch to backends like Xano or Supabase when scaling web-apps.WeWeb's Xano plugin facilitates the switch from Airtable to Xano.Step 1 – You can use Xano's import function to import Airtable tables. The import will keep the same field names and references between tables: Step 2 – In WeWeb, you can then change the data source of your collection from Airtable to Xano.Your collection lists and collection list items will remain unchanged on the page because WeWeb will automatically recognize the data structure.TIPThere may be issues with table and column names that include spaces in Airtable because those spaces will automatically be replaced by underscores (_) in Xano. As a result, WeWeb will think it's two different tables or columns and your bindings will break.To prevent this from happening, you may want to rename the tables and columns in Airtable with underscores instead of spaces, and refresh your Airtable collections in WeWeb before doing the import in Xano."
  },
  {
    "h1": "Calendly​",
    "url": "https://docs.weweb.io/plugins/extensions/calendly.html",
    "content": "Calendly ​Add plugin ​Go to Plugins > Extensions, search for the Calendly plugin and add it to your project:Add element ​To add a Calendly embed element on a WeWeb page, click on the Add Calendly components button at plugin level:Or open the Add panel and click on Calendly in the Plugins section:Display calendar ​To display a Calendly calendar:click on the Calendly embed element on your page,go to the element's settings tab, andpaste the URL of the Calendly calendar you wish to display.Pre-fill options ​When the Pre-fill options setting is On, you can provide the name and email that will be pre-filled on the details page of your Calendly booking form:"
  },
  {
    "h1": "Charts​",
    "url": "https://docs.weweb.io/plugins/extensions/charts.html",
    "content": "Charts ​Add the plugin ​To add charts to your WeWeb project, you'll need to add the Charts plugin in the Plugins > Extensions menu:Once you have add the Charts extension to your project, you will have access to new charts elements in the Add menu:Like all WeWeb elements, you can simply drag-and-drop chart elements onto a page to start using them.Guided vs Advanced modes ​WARNINGChart elements have two settings: Guided and Advanced.The mode you choose will influence:how the data you bind needs to be structured, andhow you customize the design of your chart.Data structure ​The Guided mode expects a single array of objects with all the data you need to display in each object.The Advanced mode allows you to bind multiple data sets that relate to each other BUT the related items need to be in the exact same order in each data set for the data to be displayed in the same order.Knowing this, it's important that you bind the data you want to display in the correct format. In order to do this, you can either:ensure your backend returns in the information you want to display in a format the mode you chose will understand, oruse a workflow in WeWeb to transform the data returned by your backend so that it is structured in a way the mode you chose will understand.Design ​To customize the design of your chart in Guided mode, you can use the Style tab of WeWeb as you would for any other element.To customize the design of your chart in Advanced mode, you will need to define the style of your chart in the Datasets array and Options object you bind in WeWeb.TIPTo design a custom chart in Advanced mode, we recommend you test the labels, datasets, and options directly in the Chart.js documentation to ensure you are able to get the result you want from the library.First, pick a chart type, for example a line chart as we did in the example below.Then, play around with the Config and Setup in the dedicated article of the Chart.js documentation.For more advanced configuration options, don't hesitate to explore the Charts.js documentation to learn all the ways you can label axes or style a legend for example.Finally, once you are happy with how your chart looks in the Charts.js documentation, you can copy/paste the corresponding values in the Labels, Datasets, and Options fields in WeWeb and start building on top of data collections.Pros & cons of each mode ​The Guided mode allows you to build charts very fast, but you may run into customization limits.The Advanced mode allows you to access all the customization options available in the Chart.js library. As a result, it can be more complex to build the chart you want, but you will never feel limited.See the line chart and stacked bar chart examples below to get a better understanding of the differences between the Guided mode and Advanced mode of the Chart plugin.Line chart ​Let's look at a use case where we want to display the monthly values of 2 types of transactions (rentals and purchases):Guided mode ​In Guided mode, we would need to bind the chart to one array of objects.Once we passed this list of items to the graph element, we could then decide what will be displayed on the Y-axis and X-axis of the graph:In the example above, you can see that:we selected a chart elementwent to its settingsselected the Guided modebound the data to an array of objects where each item contains valuesdecided to display the month values on the horizontal axisdecided to display the data values on the vertical axisgrouped items by type so that the rental and purchase transactions would be displayed on two separate linescustomized the color of each lineAdvanced mode ​To achieve the same result in Advanced mode, it would require more effort (the chart would be more customizable, but more on that later).Indeed, instead of binding the chart element to a single array of objects, we would need to bind values to the three advanced settings: Labels, Datasets, and Options.In Labels, we would pass the array of labels we want to display on our X-axis:In Datasets, we would bind our data sets (in our example, one data set for rental transactions, and one data set for purchase transactions):If you'd like to experiment on your side, here's the JavaScript array we are returning:jsreturn [{ label: 'rental', // name of the data set data: [65, 59, 80, 0, 10, 105, 40], // values of items in the rental data set fill: false, // if we add a color fill or not borderColor: '#4BC0C0', // color of the line and legend border backgroundColor: '#4BC0C0', // background color of the legend tension: 0 // how rounded the line is }, { label: 'purchase', data: [55, 69, 115, 0, 40, 75, 30], fill: false, borderColor: '#FF6384', backgroundColor: '#FF6384', tension: 0 }]TIPTry playing around with these settings, for example changing the backgroundColor of one data set to \"red\" and the tension to 0.3.Finally, in Options, we would style our graph, including the legend of the graph:If you'd like to experiment on your side, here's the JavaScript array we are returning:jsreturn { maintainAspectRatio: false, // to keep the height of the graph defined in the \"Styles\" tab plugins: { legend: { display: true, // change to false if you want to hide the legend position: \"top\", // choose where you want to display the legend maxHeight: 100%, // to set a maximum height on the chart labels: { boxWidth: 10, // change the width of the label usePointStyle: true // display a rounded label instead of rectangle }, }, } }TIPTo design a custom chart in Advanced mode, we recommend you test the labels, datasets, and options directly in the Chart.js documentation to ensure you are able to get the result you want from the library.First, pick a chart type, for example a line chart as we did in the example above.Then, play around with the Config and Setup in the dedicated article of the Chart.js documentation.For more advanced configuration options, don't hesitate to explore the Charts.js documentation to learn all the ways you can label axes or style a legend for example.Finally, once you are happy with how your chart looks in the Charts.js documentation, you can copy/paste the corresponding values in the Labels, Datasets, and Options fields in WeWeb and start building on top of data collections.Bar / line chart combo ​If you'd like to design a chart that displays bars for one dataset and a line for another, you'll need to:use the Chart - Line UI element in Advanced mode, andadd the type: \"bar\" to the dataset you want to display as barsStacked bar chart ​In the video below, we show you how to create the same stacked bar chart in Guided and Advanced mode:You will learn how each mode you affects:how you need to structure your data,the time it takes to design a simple chart,the extent to which you can customize a design."
  },
  {
    "h1": "Google Maps​",
    "url": "https://docs.weweb.io/plugins/extensions/google-maps.html",
    "content": "Google Maps ​Add Google plugin ​To add the Google plugin, go to Plugins > Extensions > Google:That's it. No configuration required at plugin level.Once you have added the Google extension, you will be able to access Google Maps and Google reCAPTCHA elements.Add Maps element ​You will find the Maps element in Add > Google:You can drag-and-drop this element in the Canvas or in the Navigator:How the map element works ​Before you can display locations on the map, you'll need to provide the following data:A Google API keyName of the locationLatitudeLongitudeWith that in mind, there are two-prerequisites to use the map element in WeWeb:you are able to generate a Google API Keyyou have added a Collection with a list of locations in WeWebGoogle configuration ​Create a Google API Key ​The first thing the map element needs is a Google API Key that is enabled for the Maps Javascript API:To get this API key, you will need to:Log into to the Google Cloud PlatformCreate a developer projectEnable the Maps Javascript API as shown aboveCreate an API key in the Credentials menu as show belowAdd editor.weweb.io/* as an HTTP referrerRestrict the API key to the Maps Javascript APIEnable the free trial in GoogleIf you get stuck here, please consult the Google developer documentation.WARNINGYou will notice our API key is visible in our screen recordings. Rest assured that we have deactivated these keys after recording. An API key should always be kept secret. Do not share your API keys with anyone.HTTP referrer ​For the Google Maps element to work properly inside the WeWeb editor and when your app is published, you need to tell Google what HTTP referrers you authorized:editor.weweb.io/* to authorize the WeWeb editor,weweb-preview.io/* if you've published your WeWeb without a custom domain, andyourcustomdomain.com/* if you've published your WeWeb project on a custom domain.Map settings ​In the specific settings of the map element, you will be able to:paste the Google API key,bind your list of locations in the Markers field,map the column names of your location collection, andtoggle settings on and off (e.g. zoom control, street view control)WARNINGThe Markers field expects a list of locations in an array.You can bind it to collection data, an Array variable, or use the createArray formula to define your list of locations.Display data on the map ​There are three steps to display data based on the marker that is selected by a user.1- Create a variable of Object type ​2- Update the variable based on the marker clicked by the user ​Create a workflow to update the selectedMarker variable you created in step 1.This workflow should be:executed on the Map element in your navigatortriggered on marker click,to update change variable value of the selectedMarker variable you created in step 13- Add a Text element on the page ​It could be anywhere on the page and styled any way you want.The point is that you will bind this element to information from the selectedMarker variable which will change every time a user clicks on a different marker in the map.In the example below, we bound the text element to the Name field of the selectedMarker variable:Troubleshooting ​If you run into any issues, the most likely explanation is that something is not configured properly on the Google side of things.Double check that:in WeWeb you added the API key for the correct Google project,in Google, you added the relevant HTTP referrers for the WeWeb editor and published project,enabled the API key for the Maps Javascript API, andenabled the free trial in Google.If this is still not working for you, don't hesitate to reach out in the WeWeb Community where we'll do our best to help."
  },
  {
    "h1": "Google Tag Manager​",
    "url": "https://docs.weweb.io/plugins/extensions/gtm.html",
    "content": "Google Tag Manager ​Google Tag Manager is a platform that simplifies the management of tracking codes and tags on websites. It's helpful to collect data and integrate with analytics and marketing tools.With the Google Tag Manager plugin, you can:track page views of your web-app in a few clicks, andtrigger custom tracking events from no-code workflows.Add plugin to project ​To add Google Tag Manager to your WeWeb app, go to Plugins > Extensions:Then, you’ll be prompted to enter your Tag Manager Container IDs:You can enter one container ID per environment if you want to use different Google Tag Manager containers for you app while in the editor, on your staging app or on the production app.Only the production container ID is mandatory. If you don’t set IDs for the editor and for staging, they will use the production ID.To find your Google Tag Manager ID, search for it in the upper-right corner while on the Tag Manager page:Once saved, the Google Tag Manager plugin is now added to your project!Track pageviews ​Once you've configured the Google Tag Manager plugin, pageviews will be tracked by default, nothing to do on your side.TIPOnly the first pageview will be triggered in the editor, as the app is not triggering \"real\" page changes. But when published in staging or production, all page changes will trigger.Track custom events ​To track other user interactions, you can use the Push Event action in workflows:In the action, you’ll be able to add as many key/values pairs as you want, which are bindable (you can also bind the whole object).This object will be added in the Google Tag Manager’s dataLayer that you’ll be able to use as a trigger and variables in the Tag Manager instance:TIPThe dataLayer is an array which is added to the window objects inside your project. What Google Tag Manager does is to listen to any object added to this array (what WeWeb's plugin action does).You can learn more about the dataLayer:in Google's developer documentation, andthrough this Analytics mania tutorial"
  },
  {
    "h1": "Mapbox​",
    "url": "https://docs.weweb.io/plugins/extensions/mapbox.html",
    "content": "Mapbox ​Display map ​To display a Mapbox map on a WeWeb page, you'll need to:add the plugin to your projectdrag-and-drop the Mapbox element on a pagecopy/paste a Mapbox API token in the settings of the Mapbox element you dropped on your page1. Add the plugin ​From the Plugins > Extensions menu:2. Drag-and-drop the Mapbox element ​From the Add > Plugins menu, you can drag-and-drop the Mapbox element on the page of your choice:3. Copy/paste a Mapbox API token ​Click on the map you just dropped, go to its Settings tab, and paste your Mapbox API token:And voilà! A default map should appear if the token is valid.Style options ​This plugin is tailored for advanced usersMost of the options you can find in this plugin can be bound. But they require a specific data type that is specific to Mapbox' API.We strongly recommend following their tutorial on how to design a map using their studio: https://docs.mapbox.com/help/tutorials/create-a-map-with-data-visualization-component/Map style – This option lets you change the \"look and feel\" of the map. You can select Mapbox predefined styles here or create your own and bind it.Map projection – The type of projection you want to use for your map.Logo position – Where to place the Mapbox logo on your map.Default markers color – The color used to mark positions on the map (default is red).Disable popups – Choose On to disable the native Mapbox popup. Useful if you want full design freedom to display your own custom popups on marker click or mouse enter for example.Popup hide close button – Enable to hide the close button of the native Mapbox popup.Popup stays open on click – Enable to force users to click on the close button to close the popup.Popup close on move – The native Mapbox marker popup will close itself when the user's mouse moves away from a marker.Popup max width – Allows you to customize the max-width of the native Mapbox popupTIPIf you feel limited by the native Mapbox marker popup, you can design your own custom modal and decide when it is displayed with one of the Mapbox workflow triggers:You can also use the x/y position in the domEvent property to choose where the modal is displayed relative to a marker:Settings options ​API access token – Your Mapbox API key.Latitude, Longitude and Zoom – Determines the part of the map on Earth where that will be displayed to your users at first. More documentation available here.Scroll zoom – Enable to let users zoom on the map by scrolling over it.Track resize – Enable to let users resize the map by \"snapping\" it with two fingers (mobile or touchpad).Markers draggable – Enable to let users drag and drop markers on the map.Fixed markers bounds – Enable to prevent users from drag and dropping markers outside of a specific are (to be configured in the markers settings).Workflow triggers ​You can trigger workflows on the Mapbox element:For example, you could use the On marker click trigger to display a custom marker popup.Add markers ​Here, you can setup one or more markers using the Mapbox API:Content: the name that will appear on the markerLatitude / Longitude: the marker's position on the world mapColor: the marker default color (will override previous settings for this)Draggable: enable to let users drag and drop this marker (will override previous settings for this)TIPWhile you can add markers manually, the power of WeWeb comes when you bind the markers to a collection.In the example below, you can see we bound our markers to a list of items in an Airtable collection and mapped the fields of these items to the name and coordinates needed by the Mapbox plugin:Note that the plugin expects an array of objects, so a list of items. This is why we bound to the collection data and not the collection.Add sources and layers ​Advanced options to customize your map. The best way to use them is by using Mapbox studio to create them in nocode, and then export them and bind them in WeWeb.Mapbox tutorial available here: https://docs.mapbox.com/help/tutorials/create-a-map-with-data-visualization-component/Mapbox center variable ​When you add the Mapbox element on a page, a new Mapbox - center variable will be created.This variable includes the coordinates that correspond to the center of the map you defined in the Settings of the element:Mapbox instance variable ​When you add the Mapbox element on a page, a new Mapbox - instance variable will be created:This allows you to access the map instance as a variable.Access Mapbox library ​You can access the mapboxgl library with this code: wwLib.wwPlugins.mapbox.mapboxgl:"
  },
  {
    "h1": "NPM​",
    "url": "https://docs.weweb.io/plugins/extensions/npm.html",
    "content": "NPM ​Add plugin ​To start working with npm packages in your project, go to Plugins > Extensions:This plugin will allow you to load popular utility libraries from npm and utilize them directly in the editor.Plugin limitations ​Any type of npm package can be installed, as long as it:is available on unpkg.com, andis packed in a UMD file,adds an instance to the window, andcorrectly instructs unpkg about what file to serve.However, it's crucial to understand that not all loaded packages will be functional.For the loaded library to be usable, it must be registered in the window. This import method is unique to each library, even though most libraries utilize this method.After adding a library, you must specify the name of the instance it exposes. This allows weweb to establish a connection and incorporate it into the no-code interface.In the example provided, the xlsx (or SheetJS) library can be accessed through the XLSX instance (in uppercase):Most of the time, you'll find the instance name in the library documentation.E.g. parse a CSV ​Code snippets ​If you'd like to reproduce the exact same use case, here are the code snippets we used:users collection ​javascriptreturn [ { user: \"jane\", age: 28, active: true }, { user: \"barney\", age: 25, active: true }, { user: \"fred\", age: 40, active: false }, ];csv variable ​csvCountry,Population (Millions),Area (Square Kilometers) United States,331.4,9,525,067 Canada,37.8,9,984,670 Brazil,212.6,8,515,767 Australia,25.8,7,692,024 China,1443.7,9,596,961 India,1393.4,3,287,263 Russia,145.9,17,125,191 United Kingdom,67.1,242,495 Germany,83.1,357,022 France,67.1,551,695E.g. generate a QR code ​In this video, Ray Deck of StateChange uses WeWeb's NPM plugin to build a QR code generator:"
  },
  {
    "h1": "OpenAI​",
    "url": "https://docs.weweb.io/plugins/extensions/open-ai.html",
    "content": "OpenAI ​You can find the OpenAI plugin in Plugins > Extensions:With this plugin, you will be able to tap into all of OpenAI's products, including but not limited to:text completion,image generation, andchat completion, better known as chatGPT.In this article, we will explain how to setup the OpenAI plugin in WeWeb and give you a few real life examples to get you started.To fully leverage the WeWeb OpenAI plugin, make sure to take the time to learn more about how OpenAI's APIs work.Plugin setup ​When you add the OpenAI plugin to WeWeb, you will be invited to enter your OpenAI API key and, if you wish, you can add prompts at plugin level:You may wonder why we added prompts in the plugin configuration. The answer is simple: this ensures your prompts are secure.Indeed, you could make API calls to OpenAI via our REST API plugin but you really shouldn't.Why?Because the calls you make with the REST API plugin are visible in the inspector of the user's browser.This is completely normal by the way.When you work with public APIs and non-sensitive data, it's completely ok to make calls in the frontend. In fact, it's recommended to improve performances and user experience.However, when you make an API call that requires a secret API key or includes sensitive data you want to keep private, it's crucial that you make calls through a backend.In the case of OpenAI, there are 2 pieces of information you want to key private:your secret API key, andyour prompts.Secured prompts ​When you build a product on top of AI, the value of the product is in the work you put in designing the system and prompts.That's why it's important that you protect that intelligence by adding your prompts at plugin level.Let's compare an API call made with the REST API plugin vs an API call made using WeWeb's native integration with OpenAI.First, let's make a request to OpenAI with a standard frontend API call: In the example above, you can see:in the Network tab of the user's browser,you can find the API request,look at the payload of the request,see the prompt we sent to OpenAI, andthe private API key linked to our OpenAI account.Now, let's make a request to OpenAI using WeWeb's native integration.First, we'll want to define the prompts we want to keep private at plugin level: Then, we'll make the request using an OpenAI action in a Workflow: In the example above, you can see:in the Network tab of the user's browser,you can find the API request,look at the payload of the request,see the id of the prompt we configured at plugin level, but not its contentSo if we had put in a lot of work coming up with \"Propose a name for a {fill_in_the_blank}\" to make our product unique, we would be very happy we protected that prompt.Note that you can see the animal variable we included in our prompt and the value of that variable. That's completely fine since the user just filled out that information themselves. It's not confidential or proprietary information.Ok, now that we're clear on why we should keep our prompts secure, let's learn how to use OpenAI actions in Workflows.Text completion example ​First, let's have a look at the text completion product.How does it work?In the words of OpenAI: \"You input some text as a prompt, and the model will generate a text completion that attempts to match whatever context or pattern you gave it.\"You can ask a simple question like \"Write a tagline for an ice cream shop\" and it will return something like the answer in highlighted below:But to leverage the true power of OpenAI, you'll often want to spend some time writing the perfect prompt with detailed instructions on the how you want the answer to look.Let's look at this example:We go to the Open AI API playgroundWe choose the Complete mode to use text completionWe choose the text-davinci-003 model because it's the most recent at the time of writingWe set the Temperature to 0 on a scale from 0 to 2 because we want the AI to be mathematical, not creative at allWe set the Maximum lengthof the answer to 2000 characters because we don't want the answer to be restricted to the default 256We write a prompt that asks OpenAI to return a regular expression patterns for emails in a certain format that we can easily reuse in our app to validate user inputs in an email field, i.e. the regular expression itself and an explanation of how it worksWe click on SubmitOpen AI returns an answerTIPThe Temperaturescale in the playground is 0 to 1 but the API actually allows you to go up to 2.As you can see, a lot of thought went into the prompt:we said we wanted users to input email addresseswe asked OpenAI to return the regular expression pattern in a specific formatwe asked OpenAI to include a text to explain how the regex was builtSo how would it work in WeWeb?Well, you would take the prompt you engineered in the OpenAI playground and copy it in the plugin:To add a prompt, you'll need to click on Add item.For each prompt, you can add as many variables as you want.When you click on Add variable, a new variable will be added to your prompt content with the default {{var1}} value:You'll want to give it a more descriptive name so that, when you build your API request to OpenAI, you remember what value is expected.In our Return Regex prompt above, we had a variable named {{need}}.When we configure the API call to OpenAI in a Workflow, it's easy for us to replicated what we had in the OpenAI API playground:In the example above, you can see:we're making a request to OpenAI's Complete APIbased on the text-davinci-003 modelusing the Return Regex prompt we configured in the pluginbinding the {{need}} variable we set in the plugin to a variable on our pagewith a maximum token of 2000 to ensure we get a reply, anda temperature of 0 to ensure that the reply is not creativeTo learn more about how to work with these settings, please refer to the OpenAI API documentation.TIPOpenAI has many applications and subtleties. When first starting out, we recommend the following approach:engineer your prompts using the OpenAI playgroundonce you're happy with your prompt, configure it in the WeWeb OpenAI pluginthen, add a workflow on a button to test an OpenAI action with your prompt and preferred settingsfinally, build the other steps you need in the workflow and UI to create a great user experienceTrying to build the UI and API request at the same time is very challenging. Best ace your prompt in OpenAI first, then test in WeWeb, then design the user experience.Chat completion example ​Now let's look at an example with OpenAI's chat completion features 🙂Back in the OpenAI playground, we:changed the Mode to Chatgave the AI a personality and a few instructionssimulated a user's first questionsubmitted the question to get an answer from Open AIbased on the system's answer, we decided to change a few settings, we chose the latest Model available to us, in this case gpt-4increased the Temperature to 0.9 so the AI's answer would be more creativedecreased the Maximum length to 150 tokens so the answer wouldn't be too long (it's not nice to scroll when you need a screenshot for the user docs ^^)TIPDon't be afraid to iterate a few times in the OpenAI playground to adjust your settings before moving to WeWeb.Chat completion system configuration in WeWeb ​Once you're happy with your setup in the OpenAI playground, you can go back to the OpenAI plugin in WeWeb.Contrary to the Text completion use case, you won't need to add any prompts at plugin level since the end-users of the chat you build will be asking their own questions.However, you'll need to add the instructions you came up with to define the AI's System. In the example below, we copy / pasted the personality and instructions we want the chatGPT to follow:WARNINGWhen you build a product on top of AI, the value of the product is in the work you put in designing the system and prompts. It's important that you protect that intelligence by adding it at plugin level.Indeed, if you pass the system instructions directly in an API call in WeWeb, that intelligence will be visible to end-users in the Network tab of their browser inspector.However, if you setup secured prompts at plugin level, end-users will only be able to see that an id was called in the browser inspector. They won't have access to the content of the prompt itself.Chat completion workflow in WeWeb ​The first thing to understand when working with the OpenAI's chat completion API is that the API expects to receive a list of message and each message will contain several pieces of information.In developer terms, the chat completion API expects an array of objects:What you can see in the screenshot above is that:the first item on the list is always the personality and instructions we defined as the systemthe rest of the list alternatives between messages from the user and answers from the AI assistantThis is important because it tells us how we need to structure the input we send to chatGPT to get helpful results.In WeWeb, we'll create a workflow that does the following when a user asks a question:we update our list of messages with the user's questionwe send that list of messages to OpenAIwhen OpenAI answers, we update our list of messages with the AI's answerThree things to keep in mind:if we don't send the expected format (i.e. an array of objects), the API will return an error message, so we need to make sure we include the role and content of each messageif we don't send the entire message sequence, the AI will not have the entire context of the conversationif we send the entire message sequence but don't follow the sequential order of the conversation, the AI will not have the right contextLet's take a look at a simple example to make things clearer.Step 1 - Update a messages array variable with the user's input: ​Note that we are sending the information shown in the OpenAI documentation for a user message, i.e. {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"}Though you may have noticed that we don't include the first system message in our list of messages. This is because the messages variable will need to go back and forth in the frontend (i.e. the user's browser) every time a user asks a question to the AI.Instead, what we did is we defined the system in a secured prompt at plugin level and we'll call that system in step 2. That way, its content will not be visible in the user's navigator like the list of user and AI messages:Step 2 - Make a request to OpenAI's API: ​This screenshot shows us that:our second action in the workflowuses the chat completion action of the OpenAI pluginwith the gpt-4 modelwith the system we defined in WeWeb's OpenAI plugin secured promptsand sends it the messages variable we have in our project and updated in step 1Step 3 – Update the messages variable with the AI's answer ​TIPIn steps 1 and 3, make sure to insert the new user questions and AI answers at the end of the list of messages. This will enable the AI to have the full context of the conversation in the right order.That's it!You should be good to go 🙂To learn more about how to use OpenAI's Chat completion in WeWeb, we recommend reading OpenAI's API documentation and reverse-engineering WeWeb's TemplateGPT project:"
  },
  {
    "h1": "PWA plugin​",
    "url": "https://docs.weweb.io/plugins/extensions/pwa.html",
    "content": "PWA plugin ​The PWA plugin enhances your WeWeb projects by transforming them into fully-functional Progressive Web Applications.This plugin introduces advanced features such as:vibration,motion sensors,notifications,native share, andgeolocation capabilities.Pre-requisites ​Before using the PWA plugin, ensure you've enabled mobile app features in WeWeb. Refer to our mobile app features guide guide for instructions.Installation ​Navigate to Plugins > Extensions > PWA in your WeWeb project.Add the PWA plugin.No additional setup is required!Once installed, you can use PWA actions in your workflows. Each action is tagged with supported mobile platforms (Android and/or iOS).Add to Home Screen ​This action allows users to install your PWA on Android devices, making it accessible from the home screen like a native app.In the example below, we added a button and triggered a workflow that installs the app on click:Add a button that triggers a workflow on clickAdd the Add to Home Screen actionIf anyone clicks on the button now, they will be able to add the application to the home screen.How it works ​Websites meeting PWA criteria (manifest file, service worker) can offer installation. Learn how to enable PWA in a WeWeb app.The action prompts Android users to add the PWA to their device's home screen.The PWA opens in a standalone window without browser UI.WARNINGThe Add To Home Screen prompt only appears in the published/live version of your app, not in the editor environment.Geolocate ​The Geolocate action accesses the user's geographical location.Usage ​Triggers a browser permission prompt for location access.Accesses device location services (GPS, Wi-Fi, cellular networks).Use cases: ​Location-based services or contentCustomized user experiencesMapping and navigation featuresLocation tagging for posts or photosImplementation ​Add the Geolocate action to a workflow (e.g. on app load or page load or on click of a button)If we test the action, we will get a timestamp and the user’s current coordinates:Use a Change variable value action to store the result of the Geolocate action, which includes: a coords object: the device's geographical position, anda timestamp: the date and time of when the location was obtained.WARNINGWhen testing the Geolocate action, you will receive an error if location services are disabled in your browser:Share ​Enables users to share text and URLs using the device's native sharing mechanism.Functionality: ​Opens the device's built-in share menu.Users can choose from available sharing options (messaging apps, email, social media).Implementation: ​Add a Share button to your page.Create a workflow triggered by the button click.Include the Share action with the following fields: Title: Main headline for social media sharesText: Description under the titleURL: Web address to be sharedTIPThe Share action doesn't support direct file sharing, but you can share URLs of files.Vibrate ​Causes Android devices to vibrate based on a specified pattern.WARNINGThis action is only available for Android devices due to an iOS limitation. PWAs on iOS are limited to what Safari supports. They can only use Web APIs that Safari implements and Safari does no support the Vibration API.Use cases ​Notification systems (e.g. vibrate when user receives new message)Error management (e.g. vibrate if user login failed)Mobile gaming (e.g. vibrate when user attemps forbidden move)Implementation: ​Add the Vibrate action to a workflow (e.g. triggered by a realtime event like a database change or a user attempting a forbidden move in a chess game)Define a vibration pattern as an array of numbers: Odd-indexed elements (including the first) specify vibration periods in milliseconds.Even-indexed elements specify pause periods in milliseconds.Example: [200, 100, 300, 200]200ms vibration100ms pause300ms vibration200ms pauseShow Notification ​Presents alerts and updates to users.When will it work: ​app closed ❌app in use ✅app opened but screen locked ✅app opened in the background ✅Implementation: ​Add the Show notification action to your workflow.Configure the following fields: Title: Main headline of the notificationBody: Detailed contentIcon URL: URL of a small icon (optional)Image URL: URL of a larger image (optional)Tag: Identifier for grouping or replacing notificationsData: Additional JSON-formatted dataVibration Pattern: Array of numbers defining vibration behaviorTIPWe recommend experimenting with the data you want to include in your notifications.As an example, here's what a notification with a title, body, and icon URL looks like in Chrome's desktop version:Recommended dimensions for icon and image URLs: ​width around 300pxheight around 200px (this idea is to have a landscape format)Avoid images wider than 1500-2000pxThe image size should not exceed 1-2MBDevice Motion ​There are two actions for web-apps to access your phone's movement data:Request Motion Permission: Asks for the user's consent to access motion data, ensuring privacy and security.Listen Device Motion: If permission is granted, this action captures real-time data from the user's phone sensors (mainly accelerometer and gyroscope) to respond to the device's movements.TIPThese actions can be executed at any desired moment when motion data is required, whether during page load or upon a specific user interaction, such as a click.Use cases ​Step counterMobile gamingAugmented reality appsImplementation: ​For the Start button of the step counter app, we could trigger a workflow with those two actions:As an example, we might add a Change a variable action to update a stepCount variable based on motion data available in the From PWA section of variables.In the context of a fitness app, these properties can be used to create features such as step counting, distance estimation, and basic fitness tracking. While not as accurate as dedicated devices, they can add functional elements to your app. The possibilities of what you can do with device motion are endless!Learn more about device motion properties.Additional Device Information ​The PWA plugin also provides access to various device information:battery: This object provides information about the battery status of the device on which the PWA is running. It includes details such as the battery - level and whether the device is charging.deviceInfo: Provides general information about the device itself, such as the model, operating system, and other hardware details, including brand/model.network: Offers details about the network status of the device, such as whether the device is connected to the internet, the type of connection (Wi-Fi, cellular).pageVisibility: This variable shows if the PWA page is visible to the user. If it's true, the page is open and visible in the foreground. If it's false, the page is in the background or the device screen is off.WARNINGAll of these properties are read-only and cannot be changed.Conclusion ​The PWA plugin significantly enhances your WeWeb projects, bringing them closer to native app functionality. By leveraging these features, you can create more engaging and responsive web applications that take full advantage of mobile device capabilities."
  },
  {
    "h1": "Segment​",
    "url": "https://docs.weweb.io/plugins/extensions/segment.html",
    "content": "Segment ​Segment is platform that simplifies the management of tracking codes and tags on websites, enabling efficient data collection and integration with analytics and marketing tools.The Segment plugin in WeWeb allows for easy integration in any WeWeb project, and to trigger tracking events from no-code workflows.With the Segment plugin, you can:Track pageviews of your web app in a fgew clicks,Trigger custom events from no-code workflowsIdentify users from no-code workflowsAdd plugin to project ​To add Segment to your project, go to Plugins > Extensions:Then, you’ll be prompted to enter your project write key:You'll find your write key in your Segment project snippet. Indeed, you need to use a JavaScript source in Segment to use in a WeWeb app:Once saved, the Segment plugin is now added to your project!Use plugin in workflows ​Pageviews are tracked by default, nothing to do on your side.TIPOnly the first pageview will be triggered in the editor, as the app is not triggering « real » page changes. But when published in staging or production, all page changes will trigger.To track user interactions, you can use the Track action in workflows:The only required parameter for this action is the event name. You can add as many key/value pairs as you want, which are bindable (you can also bind the whole object).This object will be sent to Segment as the properties object of the event. You can test your events in the editor, and you’ll see them in the Segment debugger:To track user logins and signups, you can use the Identify action in workflows. The only required parameter for this action is the user id, but you can also add as many key/value pairs as you want, which are bindable (you can also bind the whole object).What we would recommend is to login the user using the Login action, and then identify the user using the Identify action, so that you can actually use the current user data to do your bindings:TIPOnce identified, the user will be identified on all pages, and all events will be sent with the user id. No need to use identify on every page. Just use it during the login/signup process.For the other events, such as alias or screen, the process is the same. You can refer to Segment's docs for more information on these events."
  },
  {
    "h1": "Sound​",
    "url": "https://docs.weweb.io/plugins/extensions/sound.html",
    "content": "Sound ​Add plugin ​To build audio features in your WeWeb app, add the Sound plugin from the Plugins > Extensions menu:Sound element template ​When you add the Sound plugin, you will have the option to also add a ready-made sound template element:While the sound template element is fully customizable, it comes with pre-built workflows and bindings that will get you up and running in no time.Access workflow actions ​Once added to a project, the Sound plugin gives you access to a number of no-code workflow actions to load, play, pause, stop audio files and more.Simply create a workflow, and search for \"sound\" to view all the actions available:Load sound ​WARNINGThis step is a pre-requisite for every other step. Before you can let users interact with a sound or unload a sound, you will first need to load it.To load a sound in a WeWeb app, you will need to:create a workflow with a \"Load sound\" actiongive the sound a unique IDprovide a URL where the audio file can be foundTIPMake sure you provide the URL to a file with a standard audio extension such as .mp3 or .wav. Otherwise, the sound may not be recognized as such.Sound variable ​Once you load a sound with a unique id, you will be able to access that sound's variable in the data explorer:That variable includes helpful information including:isPlaying – whether the sound is currently being played or not,totalTime– how long the sound lasts (in seconds),currentTime and currentTimePercent: – the position of where the sound is at the moment (in seconds or percentage)You can react to this information to build your own custom audio player.In the example below, you can see we bound a progress bar element to the currentTimePercent value of our audio file:Sound options ​When you load a sound, it will come with default options:To customize these values, you can either bind the Options to an array of objects or click on Add item to add a key value pair.In the example below, we set the loop value to true:As a result, the sound was loaded with the proper loop value and, if the user plays the sound, the audio file will be played on repeat.TIPIf you choose to bind the Options to an array of objects, use the following format:[{\"key\":\"volume\",\"value\":0.5}, {\"key\":\"loop\",\"value\":true}]The Current value should be an array of objects with a value for key and a value for value as shown in the example below:Sound metadata ​When you load a sound, you can add metadata. This can be anything you want.In the example below, we added three fields: a cover album image, a song title, and an artist name:As a result, we can bind that information to the audio player on our WeWeb page:TIPIf you choose to bind the Metadata, the Current value should be an array of objects with a value for key and a value for value as shown in the example below:Note, the example above uses the following sample code in Javascript mode but you can use the same snippet in Formula mode without the return at the beginning:javascriptreturn [ {\"key\":\"title\",\"value\":\"Unforgettable\"}, {\"key\":\"artist\",\"value\":\"Nat King Cole\"}, {\"key\":\"artwork\",\"value\":[ { src: \"https://dummyimage.com/192x192\", sizes: \"192x192\", type: \"image/png\", }, { src: \"https://dummyimage.com/256x256\", sizes: \"256x256\", type: \"image/png\", } ]} ]Unload sound ​To maintain a responsive and efficient user experience, trigger the Unload sound action when a sound is no longer relevant.For example, when transitioning between pages or when switching to a different section of your application.TIPUnloading sounds in your WeWeb project is crucial for optimizing performance and memory usage.By freeing up resources when sounds are no longer needed, you ensure smoother operation and prevent potential slowdowns or crashes, especially in complex applications or for users with limited device resources."
  },
  {
    "h1": "Stripe​",
    "url": "https://docs.weweb.io/plugins/extensions/stripe.html",
    "content": "Stripe ​Let's see how you can setup Stripe in WeWeb so that your web-app users can make payments.Configure the plugin ​To add the Stripe Plugin to your WeWeb project, go to the Plugins > Extensions menu:Once you have added the Stripe Extension, you will be invited to set it up with your production API keys:TIPIf you want to work with test data in Stripe, you can also add test API keys. Better be safe than sorry! 😅Add a payment form ​Once you have set up the Stripe plugin, you will have access to the payment form element.To display a Stripe payment form on your web app, you'll need to add a Form Container with a submit button:Then, you'll want to remove the input so you're only left with the button element and add the Stripe - Payment element inside the form container you added above:In the Stripe payment element's Settings, you'll need a client secret:Create client intent & client secret workflow ​To get a client secret, we first need to create a client intent. We do this by creating a workflow that triggers on page load.In the first step, we create a payment intent, decide which payment methods the client can use and which Stripe products they can purchase (the Price ID will come from your Stripe account):We will then test Action 1 because we need to bind its result in Action 2.In step two, we setup a Change variable value action to update a payment_intent_client_secret variable (type Query) with the value of client_secret in the result of the previous action:TIPThe query variable must be named payment_intent_client_secret in WeWeb because that's the name of the query string Stripe will pass when creating the client secret. If you choose a different name in WeWeb, the browser won't be able to recognize the query string provided by Stripe.Once our workflow triggered on page load is complete, we will go back to our Stripe - Payment element and bind the payment_intent_client_secret variable to the Client secret setting:Confirm payment workflow ​Finally, on the form container, we will trigger a workflow On submit to confirm the payment action and redirect the user to a checkout page when they submit the payment form:Fake payment ​In order to move forward with the tutorial, you will need to fake a payment intent with a fake card. Read more about simulating payments in the Stripe documentation.Once you've entered fake payment details, you can submit the form to trigger the workflow:You should be redirected to the checkout page.Add a checkout page ​On the checkout page, we'll create a workflow that triggers on page to retrieve the user's payment intent:Action 1: Retrieve the payment intent ​We will add the Retrieve payment intent action and bind this to the payment_intent_client_secret variable we created earlier.It will look something like this:If you've named your variable correctly and faked a payment with a fake Stripe card, you should be able to see the the payment_intent_client_secret query string in the URL, which is retrieved by WeWeb in the payment_intent_client_secret variable:Action 2: Store the payment intent ​After testing Action 1, we will create an Action 2 to store the payment intent in a variable of type Object.We will choose a Change variable value action and bind it to the result of the previous action in the workflow:Again, we need to test this action if we want to update the variable.Then, we could use the information from the variable to style the checkout page.For example:Before publishing ​When you publish your application, the Stripe - payment element will not be rendered on the page by default because it can only be rendered if a payment intent is found and, when the browser first loads the page, the client intent will not have been created yet.In order to ensure the Stripe payment element is rendered on the page, you'll need to bind it's Conditional rendering setting to the payment_intent_client_secret variable:That way, when the workflow is triggered on page load and the payment intent variable updated with the client secret, the Stripe payment element will be rendered on the page.Video Mini-Course ​If you want to dig deeper and learn how to develop a full Stripe payment system in WeWeb, you can watch our YouTube series on the topic:How to Implement Stripe Checkout in a WeWeb appHow to Implement Stripe Subscriptions in a WeWeb appHow to Implement Stripe Elements in a WeWeb app"
  },
  {
    "h1": "WeWeb Email​",
    "url": "https://docs.weweb.io/plugins/extensions/weweb-email.html",
    "content": "WeWeb Email ​Add plugin ​To start working with the WeWeb Email plugin, go to the Plugins > Extensions menu:Send email ​Once you've added the WeWeb Email plugin to your project, you will have access to the Send an email no-code workflow action:Plugin limits ​The WeWeb Email plugin was developed to allow you to add an email component to your app quickly and securely at the beginning of a project.This plugin will let you send an email through an action in a workflow.However, as your project grows, you will quickly feel limited because:you can't customize the sender,you can only send text, anda maximum of 10 emails/hour.As you scale your app, you will want to transition to a dedicated email integration via your backend. For example, you could work with Xano's Sendgrid extension or configure Supabase to send emails.No matter what backend and email service you choose, you will be able to use WeWeb workflows to trigger those emails.TIPThe WeWeb Team is currently exploring the possibility of developing native integrations with popular emailing tools like Sendgrid, Mailgun, and others.If it's something you'd be interested in, don't hesitate to let us know here which provider you would prioritize."
  },
  {
    "h1": "Intro to plugins​",
    "url": "https://docs.weweb.io/plugins/intro-to-plugins.html",
    "content": "Intro to plugins ​Plugins are native integrations developed by WeWeb, designed to help you extend your app's functionality by seamlessly connecting to third-party services or adding custom features.TIPWhile plugins are incredibly helpful, they are not mandatory. If a specific plugin for your desired service doesn't exist, you can still connect to it using REST APIs, GraphQL or more. This flexibility ensures that you can integrate with virtually any service, even if it doesn't have a dedicated plugin.They are available under 3 categories:Data sources are used to interact with data through third-party services like Xano, Supabase, a REST API, etc.Authentication are used to authenticate users in your app through third-party services like your company's bespoke token-based auth, OpenID, Xano Auth, etc.Extensions are used to add custom features to your app like maps, charts, payments, etc.How to add a Plugin ​To add a plugin, go to Plugins, select a plugin category and the plugin you want to add, then click on the Add button:Notice that, when the Plugins panel is open, you will find:the list of installed plugins (which you can click on to configure or remove),the list of all available plugins by category, and when applicable,a help text to learn more about the plugin currently selectedAvailable Plugins ​Here is a list of all the available plugins inside WeWeb.Data sources ​The data sources are the plugins that you can use to connect to third party services, and to fetch data from them. You can find them under the Data sources tab.Currently available data source plugins include:Supabase: to connect to a Supabase database. Documentation is available here.REST API: to connect to any REST API. Documentation is available here.Xano: to connect to a Xano database. Documentation is available here.Airtable: to connect to an Airtable base. Documentation is available here.Google Sheets: to connect to a Google Spreadsheet.SQL: to connect to a SQL database. Documentation is available hereJavaScript: to connect to APIs using JavaScript and the Axios library.GraphQL: to connect to a GraphQL API.SOAP: to connect to a SOAP API.RSS Feed: to connect to an RSS Feed.Algolia: to connect to an Algolia index. Documentation is available here.Strapi: to connect to a Strapi content management system.Ghost: to connect to a Ghost content management system.TIPYou can connect multiple data sources to the same WeWeb projectAuthentication ​The authentication plugins are the plugins that you can use to connect to third party services, and to authenticate users in your app. You can find them under the Authentication tab.Currently available authentication plugins include:Xano Auth: to use Xano as your authentication provider. Documentation is available here.WeWeb Auth: to use WeWeb's own authentication built on top of AWS Cognito. Documentation is available here.Supabase Auth: to use Supabase as your authentication provider. Documentation is available here.Auth0: to use Auth0 as your authentication provider. Documentation is available here.Token Based Auth: to connect to any API using a token based authentication system. Documentation is available here.OpenID: to use the OpenID protocol to connect to any OpenID provider.WARNINGYou can only have one authentication plugin per app.Extensions ​The extensions are the plugins that you can use to add custom features to your app. You can find them under the Extensions tab.Currently available extension plugins include:Date: to add date-related elements to your app (like a date picker, a date range picker, etc), and formulas to manipulate dates based on the DayJS library.Charts: to add charts to your app. Based on the ChartJS library. Documentation is available here.PWA: to enhance your web applications with Progressive Web App features like device motion sensors, notifications, geolocation, native sharing, and vibration capabilities. Documentation is available here.Stripe: to add Stripe payments to your app. Documentation is available here.Mapbox: to add a Mapbox map to your app. Documentation is available here.WeWeb Email: to send emails from your app using our own email service.CSV: to export data from your app to a CSV file.Google: to add Google-related elements to your app (Google Maps, reCAPTCHAs, etc). Documentation for Google Maps is available here.Youtube: to embed Youtube videos in your app.Calendly: to embed Calendly calendars in your app.Segment: to use Segment as your analytics provider in your app.Vimeo: to embed Vimeo videos in your app.Typeform: to embed Typeform forms in your app.Snipcart: to use Snipcart as your e-commerce provider in your app.Dailymotion: to embed Dailymotion videos in your app.Twitch: to embed Twitch videos in your app.Plugin configuration ​To learn how to configure a plugin, please refer to each plugins' documentation (linked in the list above) or to the modal that will appear on the right when you add a plugin:"
  },
  {
    "h1": "Account Settings​",
    "url": "https://docs.weweb.io/settings-billing-code-export/account-settings.html",
    "content": "Account Settings ​In this article, you'll learn:How to change you account settings (email and name)To find you account settings, click on the 3 dots next to your account name, then on Account settings:Once here, click on the Edit info button to open the edition popup:"
  },
  {
    "h1": "How to self-host on Cloudflare​",
    "url": "https://docs.weweb.io/settings-billing-code-export/cloudflare-self-hosting-guide.html",
    "content": "How to self-host on Cloudflare ​This guide will walk you through the steps required to self-host your WeWeb application on Cloudflare.Prerequisites ​A Cloudflare account (free)A Starter or Scale WeWeb project subscriptionLet’s start with Cloudflare first: ​On Cloudflare's dashboard, click on the Workers & Pages section.Make sure you are on the Overview tab. If you already have another Worker in this section, click on the Create button and then go to the Pages tab.Go to the second section on the page and click on \"Upload assets\".Give your project a name and then click on Create project.WeWeb ​Next, go to your project dashboard in WeWeb. Go to the Deployments tab.TIPYour project must have been published at least once before you can export the project files.Here, you will see Staging and Production environments:TIPIn this guide, we will export code from the production environment, but you can also export the staging version of your app if you are on the Scale plan. If you recently made changes on staging and you want to export the app with those changes, promote the staging version to production first.Click on the three dots on the right (⫶) and select Download project files. This will download a zip directory of the project files to your device. This zip archive includes the compiled project (a Vue.js application) with all the files necessary for hosting it on Cloudflare.Cloudflare ​Upload the zip archive you just downloaded from WeWeb into the Upload your project assets section. Make sure you select Upload zip before you upload.Click the \"Deploy site\" button after all files are successfully uploaded.Upon deploying, Cloudflare will provide you with some additional information and options:Cloudflare site URLOption to add a custom domainYou can ignore the other options for now.10, If you click on \"Continue to project\", you will be redirected to the Deployments tab of your applications’s Worker:Your application is now live and fully self-hosted on Cloudflare!Making changes to the self-hosted application ​Make changes in your app in WeWeb.Publish the application again.Export the code following the steps described earlier.Download new zip file for latest version.In the Overview of Workers & Pages, go to the Deployments tab and click on Create a new deployment.Select your deployment environmentUpload the new zip archive.Click on Save and deploy.After a successful deployment, your changes will be reflected in the self-hosted application.TIPAlways test your updated application thoroughly after deployment to ensure all changes are correctly reflected and functioning as expected.By following these steps, you can easily export your WeWeb project and self-host it on Cloudflare, as well as keep it updated with any changes you make in WeWeb."
  },
  {
    "h1": "WeWeb Public API​",
    "url": "https://docs.weweb.io/settings-billing-code-export/code-export-api.html",
    "content": "WeWeb Public API ​The WeWeb Public API enables customers to automate and streamline their deployment processes for WeWeb projects.This API is designed for organizations managing multiple WeWeb applications across various domains or server instances.Key benefits ​Automated deployments: integrate WeWeb projects into your CI/CD pipelines.Version control: programmatically manage different versions of your WeWeb applications.Multi-environment support: easily deploy to staging and production environments.Scalability: efficiently manage deployments across multiple domains or server instances.Customized workflows: tailor the deployment process to fit your organization's specific needs.The WeWeb Public API offers significant productivity gains for teams handling complex deployment scenarios.Instead of manually downloading the application code and/or then manually deploying it to a web server running on your infrastructure, you can trigger custom deployment scripts from within the WeWeb Editor.Create a fully automated DevOps environmentBy leveraging this API, you can create a fully automated DevOps environment to reduce manual tasks, minimize human error, and ensure consistent deployments across your infrastructure.This documentation provides detailed information on authentication, available endpoints, and typical usage patterns to help you integrate WeWeb deployments into your existing systems and workflows.WARNINGThe WeWeb Public API has a rate limit of 3 calls per seconds and will return 429 Too many requests error if the limit is hit.Access to WeWeb Public API ​Please contact the WeWeb team to get access to WeWeb Public API.Authentication ​WeWeb Public API authentication is done using an Authorization header in every requests.The value of this header should be Bearer <YOUR WORKSPACE PRIVATE KEY>.You workspace Private Key can be found under the Settings tab in your workspace.You can generate a new Private Key at any time but this will invalidate the old one.Example : headers: {\"Authorization\": \"Bearer WW-PRIVATE-XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\"}Available requests ​The WeWeb Public API allows you to make the following requests:Start deployment of a projectMethod: POSTURL: https://api.weweb.io/public/v1/workspaces/{{:workspaceId}}/projects/{{:projectId}}/deploy:workspaceId can be found in the URL of the workspace:projectId can be found in the URL of the projectData:env [REQUIRED] : accepts values production or staging and defines the target of the deployment. Deploying to production will also deploy to staging.commit [OPTIONAL] : String that will be used as the commit info.rawZip [OPTIONAL] : accepts values true or false and defines if the deployment generates a ZIP containing raw project files.builtZip [OPTIONAL] : accepts values true or false and defines if the deployment generates a ZIP containing built project files.githubEnabled [OPTIONAL] : accepts values true or false and defines if the deployment pushes raw project files to the configured Github repository.Returns:{ \"message\": \"Fetching data\", //Progress message \"status\": \"deploying\", //Status of the deployment. Can be : deploying / deployed / failed \"version\": 33, //Version of current publish \"createdAt\": \"2022-12-12T16:13:47.142Z\" //Date of creation }Check the deployment status of a projectMethod: GETURL: https://api.weweb.io/public/v1/workspaces/{{:workspaceId}}/projects/{{:projectId}}/deploy/last:workspaceId can be found in the URL of the workspace:projectId can be found in the URL of the projectData: no data.Returns:{ \"message\": \"Fetching data\", //Progress message \"status\": \"deploying\", //Status of the deployment. Can be : deploying / deployed / failed \"environment\": \"production\", //Target environment \"version\": 33, //Version of current publish \"logs\": \"deploy logs\", //Full logs of the deployment \"rawZip\": true, //rawZip option entered on deploy start \"builtZip\": true, //builtZip option entered on deploy start \"githubEnabled\": false, //githubEnabled option entered on deploy start \"createdAt\": \"2022-12-12T16:13:47.142Z\" //Date of creation }Download Raw project files ZIP (not built) by versionMethod: GETURL: https://api.weweb.io/public/v1/workspaces/{{:workspaceId}}/projects/{{:projectId}}/versions/{{:version}}/download/raw:workspaceId can be found in the URL of the workspace:projectId can be found in the URL of the project:version can be found in the Versions tab of the project or as a result of previous requests.Data: no data.Returns: a ZIP file containing the Raw project files.Download project files ZIP (built and ready for deployment) by versionMethod: GETURL: https://api.weweb.io/public/v1/workspaces/{{:workspaceId}}/projects/{{:projectId}}/versions/{{:version}}/download:workspaceId can be found in the URL of the workspace:projectId can be found in the URL of the project:version can be found in the Versions tab of the project or as a result of previous requests.Data: no data.Returns: a ZIP file containing the project files ready for deployment.Download “weweb-server.config.json“ by versionMethod: GETURL: https://api.weweb.io/public/v1/workspaces/{{:workspaceId}}/projects/{{:projectId}}/versions/{{:version}}/config:workspaceId can be found in the URL of the workspace:projectId can be found in the URL of the project:version can be found in the Versions tab of the project or as a result of previous requests.Data: no data.Returns: Returns a JSON containing all the data needed to configure the weweb-server.The result of this request should be saved in a weweb-server.config.json file that is at in the root folder of weweb-server. At the next start, weweb-server will look for this file and create a new version on it's database. This is only useful if your weweb-server cannot be reached on the internet by our servers.Activate a version in your weweb-serverThis request is done directly to your weweb-serverMethod: POSTURL: https://<YOUR WEWEB-SERVER URL>/public/v1/projects/{{:projectId}}/versions/{{:version}}/active:projectId can be found in the URL of the project:version can be found in the Versions tab of the project or as a result of previous requests.Data: env accepts values production or staging and defines the target of the activation.Returns:{ \"success\": true, //Success, can be `true` or `false` }Monitoring a publication ​Check the status field in the response to determine when the publication is complete. The value will be deployed when the publication is finished.Typical auto deploy ​A typical auto deploy script should be: 1. Start the publication of a project with \"builtZip\" set to true. 2. Store the version provided by the previous request 3. While the project is publishing, check the publication status of a project. The publication is done when the progress is 100 and status is \"published\". 6. Download project files ZIP by version using the version provided in the start publication step 7. Save the downloaded ZIP file 8. Extract the download zip file to your weweb-server storage at the right place (defined by FILES_PATH) 9. Activate the published version in you weweb-server using the version provided in the start publication step"
  },
  {
    "h1": "Export code & self-host​",
    "url": "https://docs.weweb.io/settings-billing-code-export/hosting-and-code-export.html",
    "content": "Export code & self-host ​In this article, you'll learn:How to export a projectHow to self-host a projectTIPCode export and self-hosting is available on all paid plans with a yearly commitment.Export a project ​Once the export project feature has been added to your workspace, go to any published project's Settings > Deployments tab.Click on the version of the app for which you'd like to export the code:What if the download button is disabled?Publish your project at least once to make it clickable.Once downloaded, you'll find a zip file containing all your project's files (HTML, CSS and JS) ready to host anywhere you want.Code export example ​You can download an example project here with both raw and built files.Self-host a project ​You can self-host WeWeb projects anywhere you like!Simply download the static files of your app as described above (i.e. the HTML, CSS and JS files of your WeWeb frontend), fire up a server and host the static files of your frontend there.As an example, we've documented how you might self-host a WeWeb project on Cloudflare.Frequently Asked Questions ​I have a Starter plan, will the self-host option still be limited to 50,000 monthly app visits and 200 GB of bandwidth?No. The exported code will run on your infrastructure, so none of the project plan limits apply.How many times can I export my code?You can export your code as many times as you want, for as long as you have an active subscription.Where can I self-host the exported application from WeWeb?You can host the app on cloud hosting platforms like Amazon Web Services, Google Cloud Platform, Microsoft Azure, Cloudflare or Digital Ocean, as well as on managed hosting services platforms like Netlify.Or you can self-host on your on-premise infrastructure—basically anything that can run a web server; an internet connection is not mandatory.Will my backend still work after I export the code and self-host the app?Yes. WeWeb is a frontend-only tool. Your backend remains separate and is not affected by exporting or self-hosting your WeWeb project.When you self-host the exported app, the frontend will continue to make API calls to your backend, wherever it's hosted, just as it did before exporting.How do I know which plugins have dependencies on WeWeb and which ones don't and can be fully self-hosted?There are two self-hosting scenarios to consider:A- Exporting your code and hosting it elsewhere (Recommended):Some plugins require communication with WeWeb microservices (Airtable, Google, Notion, OpenAI, SmartSuite, SQL, Stripe, SOAP)Direct connections to backends (e.g., Supabase, Xano, standard REST/GraphQL APIs) work independently of WeWeb.B- Using the WeWeb server as a service (Deprecated):The plugins listed above may not function properly in this scenario.WeWeb no longer supports this option.We don't recommend using this method for new projects.MicroservicesWhat causes the plugins to not work in these scenarios is due to how WeWeb uses microservices.WeWeb is a front-end app builder that runs in users' browsers. Some backend services (e.g., Xano, Supabase, Rest API) are designed to be accessed directly from browsers, while others (Airtable, Open AI, etc.) are meant for server-to-server communication and require more security.To make it easier for users to integrate with services such as OpenAI or Airtable (which aren't typically accessed directly from browsers), WeWeb created microservices.A microservice is a small, specialized server component that handles specific tasks like securely connecting to external services.These act as intermediaries, allowing WeWeb users to securely connect to these services without exposing sensitive information like API keys in the frontend.We have two separate servers:WeWeb-Plugins: This microservice acts as a proxy for plugins that need to keep API keys secure (like Airtable and OpenAI).WeWeb-Preview (or WeWeb-Server): This server runs your app and handles plugin requests in production.WARNINGIn Scenario B (using the deprecated WeWeb-Server), if you host the WeWeb-Server yourself, you won’t have access to WeWeb-Plugins. As a result, plugins like Airtable and OpenAI won’t work because your server can’t securely send requests to these services.For projects that use plugins that rely on microservices, such as WeWeb Auth, how does this affect data storage and processing locations?Plugins using WeWeb microservices, like WeWeb Auth, store and process data in the US (using AWS Cognito). This has an effect on EU data residency compliance as data leaves the EU.What files are included in the code export?When you export code from WeWeb, you have two options:Project files:This is a Vue.js application ready for deployment.The app has been compiled and optimized for production use.It includes all necessary components and dependencies.Can be immediately deployed to a web server or hosting platform.Raw project files:These are static HTML/CSS/JS files.They represent the basic structure and content of your project.Useful if you want to run your build process or perform code analysis.Can be modified or integrated into custom development workflows.They do not contain Vue.js components or framework-specific code.Raw files that need a build step and built files that are ready to host immediately.Can I make edits to my exported code outside WeWeb?While it's technically possible to edit the exported code from WeWeb, it's not easy or recommended.The code is structured by a machine for a machine and is not organized like a human developer would organize it.Editing these files safely requires in-depth knowledge of WeWeb's internal logic. This approach isn't feasible if you're planning to build a project in WeWeb and then maintain it independently outside the platform.Can I host my application in an air-gapped environment?Yes, WeWeb applications can be hosted in networks with no internet access. You can export the code and host it in your network alongside your own backend.Can I still use WeWeb's CDN when self-hosting?No. Files uploaded to WeWeb's CDN before self-hosting will not be preserved when you self-host.For self-hosting scenarios, it's best to set up file uploads to your own storage solution from the beginning to ensure continuity when you transition to self-hosting.Files that are part of your app's structure (like images embedded in the design) will be included in the export.Can I export my WeWeb project if it's not published?No, you need to publish your project at least once to enable the export feature.Can I export only part of my WeWeb project?No, the export includes the entire project.Can I import my exported code back into WeWeb?No, this feature is currently not available.Does WeWeb provide server requirements for self-hosting?With WeWeb, you can self-host your project in any standard web server.How does WeWeb handle custom domains for self-hosted projects?The setup of a custom domain is handled through your hosting provider, not WeWeb.Can I host my application on a root domain and do white label hosting?Yes, all of that is possible when you self-host.Can I still use WeWeb's UI components library in a self-hosted project?Yes, WeWeb's UI components will be included in the exported files.What's WeWeb's approach to version control for exported projects?WeWeb itself doesn't provide version control for exported projects. However, once you have exported your project, you can implement version control yourself using systems like Git.Does WeWeb provide tools for monitoring self-hosted projects?No. You'll need to use third-party solutions for that.Is it possible to add multiple subdomains to a self-hosted project?Yes. You can deploy to multiple domains if you self-host."
  },
  {
    "h1": "Backups​",
    "url": "https://docs.weweb.io/settings-billing-code-export/project-settings/backups.html",
    "content": "Backups ​In the Backups tab of a project, you can see all the different versions of the Editor that you can potentially rollback to.Backups tab ​From your workspace dashboard, you can access a project's backups by going to the project's Settings > Backups:In the example above, you can see:we have several commits of the project over two different daysthere are many commits are automatic, andthere is one manual commit with a custom messagesome commits reference a version in their name (v1) and (v2)We can:hide automatic commits,search for a specific commit,preview a specific version of the Editor, androllback to a specific version of the Editor.Automatic commits ​WeWeb generates automatic commits of your project Editor:once a day if you're on a Starter plan,once an hour if you're on a Scale or Enterprise plan, andevery time you publish your app in staging or in production.TIPThe commits that are linked to a publication will display the publication version in their name.In the example below, in the Deployments tab, you can see we published a v3 of our app in staging. As a result, an automatic commit of the Editor is available in the Backups tab (with the (v3) reference in its name):Manual commits ​When you're inside a project, you can create a manual commit of the Editor with a custom message to describe the update by going to the Commit button inside the Editor:"
  },
  {
    "h1": "Add a custom domain​",
    "url": "https://docs.weweb.io/settings-billing-code-export/project-settings/custom-domain.html",
    "content": "Add a custom domain ​When you publish a WeWeb app, we provide a default subdomain on the weweb-preview.io domain, served over SSL. For instance, yourapp.weweb-preview.io.If you want to customize this and use your own domain name, you can do this in the Domains section of the project Settings tab.First, you'll need to go to your Project Settings, click on Domains, then on Connect an existing domain name:1. Choose a subdomain ​Here, you'll have to type the subdomain and domain name you want to use:For example, type in www.mydomain.com if you want to host your website on the www subdomain or app.mydomain.com if you want to publish your app on the app subdomain.WARNINGWeWeb doesn’t support naked domain like mydomain.com for the moment. Be sure to use a subdomain. The most common one is www but you could use app or dashboard or any other subdomain that you see fit.For example, WeWeb serves apps on the support, academy and marketplace subdomains of weweb.io.TIPWhen you purchase a domain name with a registar, you don't need to purchase an SSL certificate. WeWeb will provide one for you and update it automatically on a yearly basis as long as you've added the CNAME record in the DNS (see below).2. Update your DNS records ​Once you've told WeWeb on what subdomain you want to host your app, you will be provided with information to create two DNS records, both CNAME records:the first will tell the DNS where to find the SSL certificate of your app (so it uses https)the second will tell the DNS where to find your appTIPThinking of the DNS (which stands for Domain Name System) as \"the phonebook of the Internet\" can be helpful because it reminds us the DNS needs to know at what address (IP or URL) it can find information related to our websites.To update the DNS with these new records, you'll need to find the appropriate section in your domain registar (e.g. Cloudflare, GoDaddy, etc.)Each registar will have its own way of referring to what WeWeb calls Name and Value. For example, Cloudflare refers to Name and Content while Namecheap refers to Host and Value.In the end, no matter what your registar calls these fields, the two CNAME records in your DNS should look something like this:In the example above, you can see we chose to redirect our app users to the www subdomain. If we had chosen to publish our app on app.joycekettering.rocks, you would see app here instead of www.TIPSome registars will refer to the TTL value in seconds like WeWeb (1800) and others in minutes (30) while others don't give you the option to customize it and simply set it to Auto by default.All three approaches are fine and will not affect the end-result.3. Wait for DNS propagation ​Once you've added the CNAME records to the DNS, you'll have to wait.WARNINGDepending on your registar, it can take up to 48 hours for the new CNAME records to take affect. You can check the progress on the DNS checker websiteOnce DNS records are fully propagated, you should be able to access your app when you type its address with the subdomain (e.g. www.yourdomain.com) and the Value found in DNS fields in WeWeb should appear in green with a success hint saying Your DNS is setup correctly:4. Redirect root domain (optional) ​If you chose to publish your WeWeb app on the www subdomain, you will most likely want to setup a redirection from your root domain to that subdomain so that users who type in yourdomain.com are redirected to the www.yourdomain.com.To do this, you will need to create an alias record on the DNS. You can do this:in your domain registar or, if your domain registar doesn't support root domain redirection,through a third-party Delivery Network System like Cloudflare.For option 1, we recommend you refer to your domain registar's documentation to check if they have the ability to provide naked domain redirects for https. Many don't because their redirect server can’t provide SSL service.For such cases, we recommend using CloudFlare to handle your DNS settings and setup a permanent 301 redirection from your root domain to the subdomain of your app (e.g. www or app).At the time of writing, Cloudflare allows you to do this on a free plan. We have detailed the process in the Namecheap section. While the process to update nameservers will vary from one registar to another, the logic will be the same.TIPIn most cases, if you published your WeWeb app to a subdomain other than www (e.g. app or academy), it's because you already have a website using the www subdomain. If that's the case, think twice before redirecting your root domain to another subdomain.Users who type in a root domain name usually expect to land on the www subdomain. Sending them to one of your apps and not your main website could be very confusing.Cloudflare ​DNS records ​To create the two required CNAME records in Cloudflare:on the Website tab of your dashboard, select the project you want to configureselect DNS > Records in the side menuclick on Add recordcreate two CNAME records using the values provided in WeWebWARNINGMake sure the Proxy status is disabled and says DNS only on both records.It can take up to 48 hours for the new CNAME records to take affect. You can check the progress on the DNS checker websiteOnce DNS records are fully propagated, your website should be live on your domain.Root domain redirection ​If you chose to publish your WeWeb app on the www subdomain, you will most likely want to setup a redirection from your root domain (e.g. yourdomain.com) to that subdomain (i.e. www.yourdomain.com).There are two steps to do this in Cloudflare while still supporting the https SSL certificate:create an alias for the root domain, andcreate a page rule to redirect traffic on the root domain to the https page on the subdomainAlias record ​To create a root domain alias in Cloudflare, add a new CNAME record with the Proxy status enabled that makes the root domain an alias of your www subdomain:WARNINGFor this record, make sure the Proxy status is Proxied.Page rule ​To create a root domain redirection page rule in Cloudflare:make sure you're in the right projectgo to Rules > Page Rulestype in the root domain with a /* wildcard at the end to include all the pages on the domain (e.g. yourdomain.com/*)choose the Forwarding URL setting with a 301 - Permanent redirect to ensure the redirection is permanenttype in the URL where users should be redirected. This time, make sure it: starts with https:// at the beginning and the subdomain you want to redirect to (usually https://www.), andends with /$1 so the redirection URL is dynamic (i.e. so that if someone types in yourdomain.com/dashboard, they are redirected to the dashboard page, not just the homepage of your app)don't forget to save and deploy the page ruleOnce you save the page rule, it should look something like this (make sure the Action option is enabled):TIPIn most cases, if you published your WeWeb app to a subdomain other than www (e.g. app or academy), it's because you already have a website using the www subdomain. If that's the case, think twice before redirecting your root domain to another subdomain.Users who type in a root domain name usually expect to land on the www subdomain. Sending them to one of your apps and not your main website could be very confusing.Namecheap ​DNS Records ​To add the two required CNAME records in Namecheap go to Domain List > Manage:In the Advanced DNS menu, click on Add new record and copy/paste the information from your WeWeb project. It should look something like this:Both records should be of Type CNAMEReplace Host by the Name value in WeWebReplace Value by the Data value in WeWebYou can leave the TTL value as AutomaticOnce you've saved the changes, it can take up to 48 hours for the new CNAME records to take affect. You can check the progress on the DNS checker website. Once DNS records are fully propagated, your website should be live on your domain.Root domain redirection ​If you chose to publish your WeWeb app on the www subdomain, you will most likely want to setup a redirection from your root domain (e.g. yourdomain.com) to that subdomain (i.e. www.domain.com).TIPIn most cases, if you published your WeWeb app to a subdomain other than www (e.g. app or academy), it's because you already have a website using the www subdomain. If that's the case, think twice before redirecting your root domain to another subdomain.Users who type in a root domain name usually expect to land on the www subdomain. Sending them to one of your apps and not your main website could be very confusing.At the time of writing, Namecheap does not support naked domain redirects for https because their redirect server can’t provide SSL service. You can, however, use Cloudflare on a free plan to handle your DNS settings and setup a permanent 301 redirection from your root domain to the www subdomain.In your Cloudflare account, when you add a site, you are invited to:type in the domain name of the website, andchoose a plan.Assuming your domain name was not purchased on or transferred to Cloudflare, you will then be invited to replace the default nameservers of your domain registar (in this case Namecheap) with Cloudflare nameservers:In Namecheap, you can do this by going to your Domain list and clicking on Manage, then choosing the Custom DNS option in the Nameservers section of the page:WARNINGOnce you've updated the nameservers in your domain registar, you can click on the Check nameservers button in Cloudflare to speed up the process but updating the nameservers can take a few hours regardless:Be patient. Cloudflare will send you an email and update the project dashboard once its done:Once this process is complete, you should be able to see your DNS records in Cloudflare.However, you'll still want to:ensure the two CNAME records provided by WeWeb are properly setup in Cloudflarecreate a new CNAME record to alias the root domaincreate a page rule to redirect users from your root domain to the www subdomainPlease refer to our step-by-step Cloudflare guide to ensure your DNS records are setup properly and create a redirection page rule.GoDaddy ​In your GoDaddy dashboard, go to My Products where you will find your list of domain names.Click on DNS for the domain you want to add to WeWeb:On the DNS management page, click on Add:Add 2 records like the following images:Both records should be of Type CNAMEReplace Host by the Name value displayed in WeWebReplace Points to by the Data value displayed in WeWebOVH ​On your dashboard, go to Domain names, then click on the domain you want to link to WeWeb:👉 Click on DNS Zone:👉 Click on Add an entry to add two entries like the following images:Both records should be of Type CNAMEReplace Sub-domain by the Name value displayed in WeWebReplace Target to by the Data value displayed in WeWebGoogle ​Go to My domains in your Google domains dashboard, then click Manage next to the domain you want to add to WeWeb:Click on DNS and scroll to Custom resource records:Add 2 records like the following image:Both records should be of Type CNAMEReplace Name (@) by the Name value displayed in WeWebReplace Data (Domain name) to by the Data value displayed in WeWebGandi ​Go to Domain in your Gandi dashboard, and click on the domain you want to connect to WeWeb:Click on DNS Records > Add:Add 2 records like the following images:Both records should be of Type CNAMEReplace Name by the Name value displayed in WeWebReplace Hostname to by the Data value displayed in WeWeb"
  },
  {
    "h1": "Deployments​",
    "url": "https://docs.weweb.io/settings-billing-code-export/project-settings/deployments.html",
    "content": "Deployments ​In the Deployments tab, you will be able to:publish your app,preview a previous version of the Editor,rollback to a previous version of the Editor.Editor ​This is where you can see all the automatic and manual backups of your project's Editor:Let's take a look at all the information and functionalities we have on this screen.1. Pending commits ​In the example above, there are \"7 pending commits\". This means that the Editor was backed-up 7 times without the project being published.2. Automatic commits ​WeWeb generates automatic backups of your project Editor:every 24 hours if you're on a Starter plan,every hour if you're on a Scale or Enterprise plan, andevery time you publish your app in staging or in production.3. Manual commits ​You can create a manual commit of the Editor with a custom message to describe the update by going to the Commit button inside the Editor:4. Publish ​When you click on the Publish to staging or Publish to production button, WeWeb will publish your app in the current version of the Editor.Afterwards, there will be \"No pending commits\":5. Preview ​If you want to rollback to a previous version of the Editor, you can click on Preview to open the Editor in a read-only mode.6. Rollback editor ​Once you are confident you have identified the version of the Editor you want to restore, you can click on Rollback editor.Staging ​If you're on a Scale or Enterprise plan, this is where you can see the different versions of the application published on the staging environment.In the example below, you can see:we published version 3 of our app,on the staging environment, andhave the option to promote it to production.Production ​This is where you can see the different versions of the application published in production.If you're on a Scale or Enterprise plan, you will have the option to rollback to a previous version of the app in production:TIPIf you're on a yearly plan, you will be able to download project files:Learn more about exporting and self-hosting an app built in WeWeb."
  },
  {
    "h1": "Project settings​",
    "url": "https://docs.weweb.io/settings-billing-code-export/project-settings/project-settings.html",
    "content": "Project settings ​To access a project's settings, go to your WeWeb dashboard and click on the Settings button next to the project name:In a project's settings, you will find 6 tabs:DeploymentsDomainBackupsSelf-hostingPlansSettingsIn addition, you will be able to open the project in safe mode.Deployments ​In the Deployments tab, you will be able to:publish your app,preview a previous version of the Editor,rollback to a previous version of the Editor.Learn more about WeWeb DeploymentsDomain ​In the Domain tab, you will be able to connect a custom domain to your WeWeb app.Learn how to add a custom domain to your projectBackups ​In the Backups tab of a project, you can see all the different versions of the Editor that you can potentially rollback to.Learn more about WeWeb BackupsSelf-Hosting ​See documentation on self-hosting here.Plans ​The Plans tab is where you can upgrade or downgrade your pricing plan according to your projects' needs.For example, if you're ready to publish and want to move away from the Free plan.Settings ​In the Settings tab, you can:Change the project nameSetup a webhook that will get POSTed to when the app is pushed to productionDelete the project (beware, this will be permanent and we won't be able to recover your project)Safe mode ​If your app crashes or behaves strangely when you open a project in the Editor, we recommend opening the project in safe mode.To open a project in safe mode, you'll:need to be on the Projects tab of your WeWeb workspace,click on the Settings of the project you want to debug,click on the three dots icon next to the Open Editor button, andchoose if you want to debug with workflows and/or formulas disabledThis will allow you to test your project:with all workflows disabled, orwith all workflows and formulas disabled.This can help you identify what you need to debug in your app."
  },
  {
    "h1": "Referral FAQ​",
    "url": "https://docs.weweb.io/settings-billing-code-export/referral-program/referral-faq.html",
    "content": "Referral FAQ ​How do I refer my friends to WeWeb? ​Just share your unique referral link, which you can find in your Referral Dashboard:All your friends will need to do is click on that link, and they'll be guided through the sign-up process.What is the referral link? ​The referral link is an easy way to share WeWeb with others. Rewarding your friends for trying WeWeb and you for making a successful referral.How much do I get paid by participating in the WeWeb Referral Program? ​WeWeb current promotion pays a 10% referral to you and 10% discount incentive to your potential referral.WeWeb Agency plan holders receive a 20% referral and 10% discount incentive to any self-serve plans available via the billing portal. (Note: Enterprise plans do not include discounts).WeWeb pays the referral % as long as the new customer is subscribed to a WeWeb paid plan with a maximum payout time frame of 12 months (Note: Agency plan holders do not have a 12 month limitation on payout timeframes).When calculating the amount receivable by you, we deduct our Stripe fees of 4%. As an example, if you refer us a customer who subscribes to a monthly scale plan, you will be eligible to 10% or 20% of $179 x (1 - 4%) = 10% or 20% of $171,84.What is considered a successful referral? ​Standard ReferralA referral is successful when:A user new to WeWeb signs up using your unique referral link, and...Successfully pays a minimum of one month’s subscription.Both referrer and referee are not the same entity or person.How will I know when I've successfully referred someone? ​You can track the status of your referrals directly from your Referral dashboard.My referral forgot to use my referral link. Is there a way to track it back to my account? ​We’re unable to track referrals back to your account if they did not use your referral link at the time they signed up.When and how will I get paid? ​You will be eligible for payment once your referral has been a paid WeWeb customer with a maturity date of 30 days and a minimum payout of $100.Once you’re eligible for your first payment, you can request for payment on your referral dashboard.Some users have no subscriptions - what does that mean? ​If a user doesn’t have any subscriptions, it just means they are a free account. This information is still useful because free accounts have the potential to convert into paid subscriptions."
  },
  {
    "h1": "WeWeb Referral Program Agreement​",
    "url": "https://docs.weweb.io/settings-billing-code-export/referral-program/referral-legal-terms.html",
    "content": "WeWeb Referral Program Agreement ​This Agreement (\"Agreement\") is made and entered into by and between WeWeb Inc. (\"Company\") and the Referral Partner (\"Referrer\") using the name and email address associated with their registration on the Company's no-code Platform (\"Platform\").The Company and the Referrer will be collectively referred to as the \"Parties.\"Whereas, the Referrer is interested in referring potential sales leads to the Company, and the Company intends to remunerate the Referrer for specific sales leads acknowledged by the Company and lead to new customer subscriptions to the Platform, all in accordance with the stipulations of this Agreement.Consequently, taking into account the terms and conditions outlined herein, the Parties hereto agree as follows.Relationship ​The Referrer shall not be considered an agent or legal representative of the Company for any reason, nor possess any authority to represent, bind, or make commitments on the Company's behalf.The Referrer is not empowered to make any promises or determinations on behalf of the Company concerning product quantities, delivery schedules, software modifications, compatibility, software aptness, or its suitability for specific tasks. Furthermore, the Referrer does not have the jurisdiction to alter any warranties associated with the Company's products.Under no circumstances shall the Referrer portray itself in a manner suggesting it acts as an agent or extension of the Company. Should the Company determine any of the Referrer's representations or business practices to be misleading or deceptive, the Referrer must promptly amend or cease such practices upon receiving a notification from the Company.Lead Referral and Acceptance ​The Referrer hereby acknowledges that, for a Lead to be recognized as a Commissionable Lead (\"Commissionable Lead\"), the subsequent conditions must be satisfied:The Referrer has shared their unique referral link, accessible through the Platform's dashboard, to a prospective customer.The prospective customer has subsequently established an account on the Platform, utilizing the Referrer's referral link, which includes the unique referral code.The prospective customer has procured a subscription via the Platform's dashboard.The Company has conducted a review and validated the Lead as eligible for commission (specifically, the Lead has not been declined for reasons delineated in the forthcoming Exclusions section or for any other pertinent reasons).Exclusions ​The Referrer acknowledges and agrees that no commission will be accrued by the Referrer for the referral of a Lead:That was an existing customer of the Company at the time of the referral orWith whom the Company was already involved in preliminary or advanced discussions leading to the sale of a licenseThe Referrer acknowledges that it shall be solely responsible for and shall bear all costs associated with the Referrer's development of any Leads for referral to the Company.Mutual Obligations Regarding Lead Development ​Each Party will cooperate with the other to develop and execute a strategy to best serve the needs of the Commissionable Lead, including how the Parties will work separately or together, if at all, regarding the Lead.Each Party will, upon request of the other Party, provide the other with non-confidential information it has regarding a Lead to assist the other Party in (i) verifying the eligibility of the Lead as commissionable and/or (ii) successfully soliciting the Lead to purchase the Company's products. This can be relayed via email, Slack or by phone. It does not apply if the referral has already completed an order using the Platform's dashboard.Each Party will, upon request of the other Party, in its reasonable discretion, provide the other Party with information regarding its services and/or products. Such information shall include sales and marketing materials and informal training. Any training provided under this Section shall be conducted at mutually agreed times and places and shall be conducted in accordance with the training Party's discretion.Commissions ​Subject to the terms and conditions of this Agreement, the Referrer will accrue commission for each Commissionable Lead referred to the Company.Commission Accruals ​For all users - 10% of the monthly or yearly contract value over the first year, after deduction of the company’s payment system fees of 4%.For users who have at least one agency partner seat in one of the workspaces they own - 20% of the monthly or yearly contract value for the customer referred to the Company, as long as the customer has a valid, paid subscription to the Platform, and after deduction of the company’s payment system fees of 4%.The accrued commission is displayed in the Referrers Dashboard on the Platform.Commission Payouts ​Commissions under this Section shall be processed within 15 business days from the moment the Referrer makes a payout request.The payment of commissions will be made in U.S. Dollars to the Referrer's bank account on record.Commissions are paid in United States dollars and are subject to all applicable governmental regulations and rulings, including the withholding of any taxes required by law.The Referrer is solely responsible for payment of any and all taxes imposed or incurred in connection with any commissions described above.The Referrer agrees to complete and provide any and all tax documentation reasonably requested by the Company to comply with any tax reporting obligations of any jurisdiction.Term, Termination, and References ​This Agreement is subject to and shall be read in conjunction with the Company's Terms Of Use and the Privacy Policy.By entering into this Agreement, the Referrer acknowledges and agrees that they have read, understood, and accepted the terms and conditions set out in both the Terms Of Use and the Privacy Policy.In the event of any inconsistency or conflict between this Agreement and the Terms Of Use or the Privacy Policy, the terms of this Agreement shall prevail.This Agreement is accepted and becomes valid when the Referrer clicks the \"Retrieve pending payout\" button on the Platform.This Agreement shall automatically terminate in the event that the Referrer downgrades their account to a Free plan or deletes their account from the Platform.The Company may terminate this Agreement upon written notice to the other at any time, for any reason or no reason.The Company may, from time to time, issue amendments to this Agreement and notify the Referrers of such fact by email or a message in the UI of the Platform."
  },
  {
    "h1": "weweb-server & WeWeb Server API (DEPRECATED)​",
    "url": "https://docs.weweb.io/settings-billing-code-export/weweb-server-api-(deprecated).html",
    "content": "weweb-server & WeWeb Server API (DEPRECATED) ​TIP Self-hosting doesn't need to be this complicated 💡You can now self-host and/or programmatically publish WeWeb projects without using the WeWeb Server and related API.Learn how to:programmatically publish a WeWeb project, andself-host a WeWeb app anywhere you like (e.g. Cloudflare, Digital Ocean, Netlify, etc.).If you wish to continue using the WeWeb Server and related API, read on.weweb-server ​In the past, to self-host a WeWeb app with private pages, you had to host it using the weweb-server.On June 26th, 2024, we released an update to change the way we handle private pages. As a result, you no longer need to use the weweb-server to self-host your WeWeb apps, even if those apps use authentication.WARNINGFor now, if you're not yet ready to change how you self-host your existing WeWeb apps, you can still host the WeWeb auth server as described below.Please note, however, that the weweb-server will be removed in the future. Of course, we will let you know in advance when that happens.If you're using auth in your app (be it WeWeb auth, Xano, Auth0 or Supabase) and have been using WeWeb for a while, you might already be hosting the WeWeb auth server, which checks for authentication on the backend.Here's a schema of the previous self-hosting architecture on a WeWeb app:If you wish to continue self-hosting this way for now, please watch this 5 min video showing you how to self-host with the weweb-server:The WeWeb auth server is available hereWeWeb Server API ​For now, WeWeb continues to provide an API to interact with your weweb-server.Principle ​weweb-server will be the entry point of you self-hosted WeWeb project : it will manage Authentication, pages accesses and file serve for one or multiple of your WeWeb projects.weweb-server needs to be connected to a Postgres Database that you will also have to host. We advise you to add a CDN in front of this server to keep some files in cache.weweb-server needs some storage to retreive your projects' files. This storage can be local, distant or an AWS S3 bucket.Each time you publish a new version of one of your projects, you will need to update the project's files and configure the server's DB info using WeWeb's Dashboard (The configure button can be found in the project's Dashboard > Self-Hosting > Configure WeWeb Server)Note : weweb-server needs to be accessible from our servers so that we can send some configuration data to it each time you publish a project.Database ​You need to create a new Postgres Database that will be used by this server to store some non sensible data about your projects' pages (private accesses, user groups and a list of all pages). You will need to set some environment variables in weweb-server for it to be able to connect to the Database.Storage ​You will need some storage to put your projects' files on it.This storage can be :Local to weweb-server (add a folder in the server)Distant (in some http url)AWS S3 Bucket (the bucket doesn't need to be dedicated to this storage)The storage location is configured using environment variables.Environment variables ​Main variables : ​Varible nameRequiredDefaultValuesDescriptionNODE_ENVYes-productionMust be set to productionFILES_PATHYes--Path of a frontend project's files in your storage. More informationPUBLIC_KEYYes--Can be found in WeWeb Dashboard > Workspace > Self-HostingPRIVATE_KEYYes--Can be found in WeWeb Dashboard > Workspace > Self-HostingPORTNo80-Port where weweb-server should runSERVER_PATHNo--Sub path for your server url. Not required if your server url is an IP or a domain name. More informationWW_LOG_LEVELNotracefatal, error, warn, info, debug, traceLogs weweb-server should displayHIDE_VERSIONNo-false, trueHide server version from API calls and logs. Warning : This will prevent you to use the Dashboard interface with your server, and force you to use weweb-server API.FILES_PATH : ​For local storage, FILES_PATH should start with ./ else distant storage will be used. You can use two variables in the path that can be found in the name of the ZIP of the project ::projectId:filesVersionEx: ./projects/:projectId/:filesVersion will fetch the frontend project's files localy. FILES_PATH should end without a / .SERVER_PATH : ​If you setup something like https://my-domain.com/servers/weweb-server/ as WeWeb Server URL in your Dashboard, you should set SERVER_PATH to the value /servers/weweb-server. SERVER_PATH should end without a / .Database configuration : ​Varible nameRequiredDefault valueDescriptionDB_HOSTNAMEYes-Database hostnameDB_PORTNo5432Database portDB_NAMEYes-Database nameDB_USERNAMEYes-User name to connect to the DatabaseDB_PASSWORDYes-User password to connect to the DatabaseDB_SCHEMANopublicSchema to connect to the DatabaseDB_SSLNofalseUse SSL connection to databaseAWS S3 configuration (not required if a different storage is used) : ​Varible nameRequiredAWS_ACCESS_KEY_IDYesAWS_SECRET_ACCESS_KEYYesBUCKETREGIONYesBUCKETNAMEYesPublish a new version of a project ​Publish your project on WeWeb Dashboard and wait for it to finishGo to your project's Dashboard > Self-Hosting and download the project's ZIP archiveUnzip the archive in your storage. We advise you to use subfolders for each projects and each versions of your projects to prevent downtime.Go to your project's Dashboard > Self-Hosting and click on Configure WeWeb ServerThe new version of your project is now live !"
  },
  {
    "h1": "The Components Tab​",
    "url": "https://docs.weweb.io/settings-billing-code-export/workspace-settings/components-tab.html",
    "content": "The Components Tab ​The components tab is useful to find all the VueJS elements, sections or plugins that you imported in your workspace.Here, you can:Find the elements you importedFind the sections you importedFind the plugins you importedSearch them by their nameImport a new one from GitHub"
  },
  {
    "h1": "The Design System Tab​",
    "url": "https://docs.weweb.io/settings-billing-code-export/workspace-settings/design-system-tab.html",
    "content": "The Design System Tab ​The design system tab lets you see all the design systems linked to your workspace's projects.Here, you can:Search for a specific design system by its nameCreate a new design system"
  },
  {
    "h1": "The Members Tabs​",
    "url": "https://docs.weweb.io/settings-billing-code-export/workspace-settings/members-tab.html",
    "content": "The Members Tabs ​In your workspace, the Members tab allows you to:upgrade or downgrade your workspace plan, andinvite team members and up to 10 free guests to collaborate in your workspace.Members vs guests ​You can invite:team members, andup to 10 free guestsPeople who accept your invitation will get access to all the workspace:projects,components, anddesign systems.TIPWhen inviting agency or freelancer guests, make sure to use the email address they used to subscribe to the WeWeb agency partner plan. The invitation will not go through otherwise.Member roles ​The workspace Owner is the only one who can purchase a project plan and delete the workspace.Team members with the Admin role can manage members, edit the name of a project or workspace, and delete projects.Team members who are a Member can access and edit all projects in the workspace.Invite members & guests ​To invite people, click on the Invite members or Invite guests button:You will be invited to fill out the popup with the new user(s) name(s) and email(s) to send them an email invitation to join your workspace:Troubleshooting ​A few things to keep in mind:1- Guests will not receive an invitation if the invite was sent to an email address without a WeWeb agency partner program2- If you close the popup before clicking the Invite button, the invitation(s) will not go through.3- To join your workspace, new members and guests should validate the invitation by clicking the link they receive by email.When someone has received but not activated their invitation, you'll see a Pending label next to their name on the right. You can resend or revoke the invitation by clicking on the three dots on the left of their name:"
  },
  {
    "h1": "The Projects Tab​",
    "url": "https://docs.weweb.io/settings-billing-code-export/workspace-settings/projects-tab.html",
    "content": "The Projects Tab ​The projects tab is the first one you'll see when opening a workspace.It's composed of all the apps (aka projects) that are part of this specific workspace.Here, you can:Search for a specific project by its nameCreate or duplicate a new project"
  },
  {
    "h1": "Frequently Asked Questions​",
    "url": "https://docs.weweb.io/start-here/frequently-asked-questions.html",
    "content": "Frequently Asked Questions ​In this article, we aim to answer questions we get most often. If there's anything we haven't covered that you'd like answered, don't hesitate to start a conversation in the community.Backend ​Can WeWeb build my backend? ​Yes. Thanks to our native integration with Supabase, you can now manage your backend from WeWeb.Does WeWeb work with other no-code backend tools? ​Absolutely. We built WeWeb with the idea that it would seamlessly integrate with other popular and up and coming no-code tools. We regularly add new native integrations with other tools.Don't hesitate to upvote or suggest new integrations.Scaling & Performance ​What are WeWeb's limits? ​WeWeb allows you to design pixel-perfect UIs and add complex frontend logic. You can program visually while we write clean standard code under the hood. Therefore, anything you can do in a regular programming language (PHP, Javascript, etc.) you can do in WeWeb.While we provide many features out of the box to help you build faster, you can also add custom code and import your own Vue.js components.What if I need more capacity outside my plan? ​We've structured our plans to be optimized for the products we see most often. However, should you need more capacity outside of any plan, whether it be file storage, projects, team seats or custom development, you can contact sales.Data ownership, code export, and self-hosting ​Who owns my data? ​You own your data. This also include any data that your users might upload unless your agreement with them specifies otherwise.Can I export my app and host it on-premise? ​Yes! You can export and self-host the code of projects on a yearly subscription plan.Can I see the code that my WeWeb frontend is being hosted on? ​Yes, you can see the code generated in your console and export the code of projects on a yearly subscription plan. However, you won’t be able to access the code of your project in your editor and live edit it.How and where is WeWeb hosted? ​All our infrastructure runs on AWS, in Northern Virginia. Every project built with WeWeb is deployed on AWS Cloudfront (CDN).Can I import my HTML & CSS to WeWeb? ​You can add custom code at project, page, and element level in WeWeb. You can also import custom Vue.js components in your projects, directly from your Github account. However, you will not be able to import a full web-app into WeWeb from code or other no-code tools.Can I migrate my frontend from another FaaS (Frontend as a Service) provider? ​We currently do not have a way to import or migrate a frontend from another provider. This is largely because the infrastructure and format can drastically differ.API ​Can I make an external API request in WeWeb? ​Yes. You can access and process an external API endpoint with WeWeb. You'll need to add the REST API plugin and either create a data collection (to get data) or a workflow (to interact with that data).Marketplace ​Will the Marketplace have templates that I can use to start my frontend with? ​Yes, we are very excited to begin releasing templates for our users to use for their projects. We have many useful and exciting templates on our roadmap. We are also planning to open the Marketplace to our users so that they can build their own templates and offer them to other users.Can I develop an extension or template and sell it on the WeWeb Marketplace? ​Very soon! A handful of users are alpha testing the Marketplace and have started developing and selling extensions and templates to other users.Pricing ​How much will WeWeb cost and how do I upgrade? ​Pricing depends on which plan you choose. For detailed information on the cost of each plan and what is included, please visit https://weweb.io/pricing. In order to upgrade, please visit the Billing page in your WeWeb dashboard and select \"Upgrade\"What is the Basic & Advanced Roles & Permissions? ​The Basic Roles & Permissions means that every authenticated user will have access to the same pages and app functionalities. The Advanced Roles & Permissions means that you can have different user groups with different permissions, so you could have an Admin role separate from Premium roles for example.Account ​Can I put a hold on or pause my account? ​If you need to put a hold on things by canceling your subscription and wish to come back later, WeWeb can preserve your data for up to 90 days from the end of your subscription. You must contact support to do so. After you cancel, you will not be able to access your workspace. When you are ready to come back, you must contact support again and re-initiate payment on your subscription to access your workspace. After the 90 day grace period your data and workspace could be lost and you may have to start over from scratch.Can I get a refund on my paid plan? ​WeWeb does not allow refunds of any kind on its monthly paid plans. You can choose to cancel or downgrade your Workspace and/or Project subscriptions at any time.To downgrade a Workspace plan: ​Select your workspaceGo to the Members tab of your workspaceClick on downgrade to message us your request. We will process it promptly.To downgrade a Project plan: ​Go to the Plans tab of the projectClick on downgrade to message us your request. We will process it promptly.Compliance ​Can I satisfy GDPR Compliance while using WeWeb as my frontend? ​Yes. WeWeb and its underlying infrastructure provider (AWS) provide the necessary tools and safeguards to support GDPR compliance.However, it is crucial to recognize that a significant portion of the responsibility lies with the application itself. By adhering to the key GDPR requirements and fulfilling their respective obligations, application builders can create robust and privacy-conscious solutions using a tool like WeWeb.Can I satisfy HIPAA Compliance while using WeWeb as my frontend? ​Yes. If you use a HIPAA-compliant backend and call it through our REST API plugin, in dynamic mode, your data will not transit through our product, making the whole project HIPAA compliant.Will my data transit through your infrastructure? ​It depends on the Data Source and Collection Mode you choose.When using data source plugins in dynamic mode, the data never goes through our servers, except if you explicitly choose to make a server-side request or in the case of the Airtable plugin. This is because of the way Airtable handles API keys and manages authorizations.If you use data source plugins in static mode, then we will pre-render static pages with your data and deploy them on AWS cloudfront CDN. In that configuration your data will be hosted on our infrastructure.SEO ​How does WeWeb compare to other tools for SEO? ​It depends on the tool! Historically, static website builders like Webflow and builders with server-side rendering (SSR) like WordPress had an SEO advantage over tools like WeWeb, Bubble, and others that generate dynamic content in JavaScript.This happens because when search engine bots first visit a JavaScript application, they initially see only the base HTML file before any JavaScript runs. In dynamic applications like WeWeb, this base file is nearly empty since all content is added later by JavaScript running in the browser. By contrast, static/SSR sites deliver complete HTML with all content already included.However, in recent years, search engines have significantly evolved to better handle JavaScript content, as more websites are built with modern JS frameworks like React or Vue. While the initial indexing might take a few extra days compared to static sites, search engine bots now effectively crawl and index JavaScript-based content during subsequent visits.Here are Google’s thoughts on the topic:Is WeWeb suitable for large marketplaces? ​Yes. While dynamic JavaScript applications have some SEO tradeoffs, many major marketplaces successfully use similar JavaScript-based architectures. The key is understanding that search indexing may take longer initially, but this is rarely a significant barrier for marketplace success which often depends more on:Product/service qualityUser experienceMarketing strategyNetwork effectsDirect trafficWhat can I do to help my WeWeb pages rank well in search engines? ​There are many things you can do on your WeWeb apps that will improve its Lighthouse scores and, most importantly, the user’s experience (both of which influence SEO rankings).Follow SEO best practices when building:Add titles & metadata to all your pagesAdd alt text on all your imagesUse headings for titlesUse elements with the correct HTML tags (e.g. buttons, select, etc.)Don’t load too much data on the page:Compress imagesKeep your pages short and simpleAvoid superfluous nested containersAdd backend filters on big sets of dataFetch collections only when you need themUse multi-page sections to avoid reloading data the user has already loadedMinimize unecessary custom scriptsAgencies ​Does WeWeb work with Agencies? ​Absolutely! We have a plan specifically tailored towards dev shops, freelancers and agencies. WeWeb partners are referenced here.Can I collaborate with others on a project in WeWeb? ​Yes. Development can work better if a team is involved. Depending on which package you're subscribed to, you can grant access to other teammates to your instance and work simultaneously on a project together.Custom Development ​Can I create a custom plan with WeWeb? ​Yes. This can be done by contacting us and inquiring about our custom enterprise setup.Can I hire a WeWeb expert to help develop my custom frontend? ​Yes. WeWeb partners are referenced here."
  },
  {
    "h1": "Welcome​",
    "url": "https://docs.weweb.io/start-here/welcome.html",
    "content": "Welcome ​WeWeb is a no-code web application builder with a smart AI agent at its core, allowing you to create using natural language while retaining full control through its powerful visual editor. Designed for users of all skill levels, it streamlines the development of production-grade web applications with unmatched speed, ease, and efficiencyWeWeb gives you the perfect trilogy of:Design freedom: build gorgeous interfaces with pixel-perfect controlDevelopment flexibility: connect any backend and create workflows code-freeDeployment freedom: host with WeWeb or self-host anywhereNew to WeWeb? ​🤷 I'm a complete beginner and want to learn about WeWeb and decoupled web-app development.🔌 I'm comfortable with the design side of things. Teach me how to connect a backend.⚡ I know what I'm doing. Teach me how to add business logic to my WeWeb app.🧰 I want to be inspired. Show me how to build things from A to Z.Are you a Developer? ​We have a dedicated developer documentation for you 🙂"
  },
  {
    "h1": "Broadcast messages with Supabase realtime​",
    "url": "https://docs.weweb.io/websockets/supabase-realtime/broadcast-message.html",
    "content": "Broadcast messages with Supabase realtime ​Pre-requisites ​Before users of your WeWeb app can send and receive Supabase realtime broadcast messages, they need to subscribe to a realtime broadcast channel.Once that's done, they can start sending & receiving realtime broadcast messages.Broadcast a message ​To allow users to send messages in a channel, use the Broadcast a message action:In the example above, you can see:We triggered the Broadcast a message action.To send a message to a channel we named room1.We said these messages should be called a chat event.We configured the payload of the event to be an object with the user's name and the text from a chat input.Note that the Event name can be whatever you like. It's important you remember it if you want to filter on specific events later, when you start listening and reacting to events.WARNINGThe Channel name should match a channel that the user already subscribed to.When the Broadcast a message action is successful, the workflow Logs will simply inform you that the message was sent:The action sends the realtime event to the channel but that's it.Receiving (and displaying) messages is a separate matter.Receive broadcast events ​If we want users in the channel to receive messages from other users, we need to create a page or app workflow that is triggered when there's a new realtime broadcast event in a channel.WARNINGWorkflows that listen to realtime events must be executed at page or app level because you are essentially saying: when this app or this specific page is open in a browser, I want the browser to listen for events so it can react to it.In the example below, we setup a workflow on a page with a chatroom:The workflow is triggered when there's a new broadcast event in the room1 channel.To help us debug things, we used the Logs action and bound it to the entire workflow Event object.Then we updated a variable with the payload of the workflow Event.TIPNote that, the preview of the Event object and event payload in the workflow editor displays placeholder information.When you test your setup in preview mode, the payload of the broadcast event you receive here will match the Payload value you defined when you created the Broadcast a message action before:Display broadcast events ​Broadcast events are ephemereal by design (see Supabase docs on the topic).To display these events in your WeWeb app, you'll want to update a variable every time there's a new event and bind that variable to an item on your page. That way, your UI can react dynamically to the event it receives.For example, in the case of a live collaboration tool that tracks cursor positions, you might have a cursors array variable with a seperate objet for every active user. Each object would include the user's cursor position. On your page, you could use that variable to move cursor icons around the page based on each user's position.Realtime debugger ​In Supabase, you can open the Realtime page to check if messages go through ok:"
  },
  {
    "h1": "React to realtime database changes​",
    "url": "https://docs.weweb.io/websockets/supabase-realtime/database-changes.html",
    "content": "React to realtime database changes ​Pre-requisites ​Before users of your WeWeb app can listen and react to Supabase realtime database changes, there are two pre-requisites:In Supabase, enable realtime on the table you want to monitor.In a WeWeb workflow, subscribe to a realtime channel where message events can come and go.Please refer to the related documentation if you haven't done so already.Once that's done, you can think of reacting to database changes.Listen for database changes ​If we want users in the channel to receive database change events, we need to create a page or app workflow that is triggered when there's a new realtime database change event in a channel.WARNINGWorkflows that listen to realtime events must be executed at page or app level because you are essentially saying: when this app or this specific page is open in a browser, I want the browser to listen for events so it can react to it.In the example below, we setup a workflow on a page that updates a notification counter:The workflow listens for realtime Database changes.It is triggered every time there's an INSERT event in the releases channel we subscribed to previously.Every time there's such a new event, we update a variable in our app.WARNINGNote that users will only receive events of channels they have subscribed to. If the user has not subscribed to the releases channel, the workflow will not be triggered."
  },
  {
    "h1": "Intro to Supabase realtime​",
    "url": "https://docs.weweb.io/websockets/supabase-realtime/intro-to-supabase-realtime.html",
    "content": "Intro to Supabase realtime ​What is realtime? ​Realtime is a feature that allows your app to show live updates instantly, without making incessant API calls.For example, in a chat window with lots of messages, it wouldn't be efficient to keep checking for new updates through traditional API requests every few seconds.✅ Common use cases for Realtime: chat applications, collaborative tools, and live notifications.❌ When not to use Realtime: low interaction applications, high data volume, and complex transactional systems.Supabase realtime features ​Supabase provides three categories of realtime functionalities:Broadcast: Send ephemeral messages from client to clients with low latency. For example, to track users' cursors in a collaborative tool.Presence: Track and synchronize shared state between clients. For example, to show how many users are currently online.Postgres Changes: Listen to Postgres database changes and send them to authorized clients. For example, to notify users of a new comment in one of their projects.You can learn more about these concepts in Supabase's user docs.How realtime works in theory? ​Before you dive into setting up realtime in a WeWeb project, it can be helpful to get a little bit of an overview of how realtime works.The general idea is the following:A realtime channel allows a client (the user's browser) and server (Supabase) to send and receive realtime events.Those events can be ephemereal (Broadcast) or permanent (Database changes).If users want to receive or send events in a channel, they first need to subscribe to that channel (via a WeWeb workflow action).Once they've subscribed to a channel, users can broadcast messages to that channel (via a WeWeb workflow action).They can also listen to events sent by other users in that channel (via a WeWeb workflow triggered on page or app load).Support chat example ​Taking the example of a support chat, here's how you could build it in WeWeb.When a user clicks on the support icon of your website, you would trigger:the Subscribe to channel action so they join the chat channel.the Presence state action so they can see how many support team members are online.the Broadcast a message action to send a message in the chat.You would also have an app workflow that:listens for messages from other users in the chat channel.updates a variable with those messages.You'd then use that variable to display those messages on the page.That's the theory.Learn more about how Supabase realtime works in practice:Subscribe to and unsubscribe from a channelSend and receive messagesSend and receive presence information"
  },
  {
    "h1": "Presence state in Supabase realtime​",
    "url": "https://docs.weweb.io/websockets/supabase-realtime/presence-state.html",
    "content": "Presence state in Supabase realtime ​What is presence? ​When working with realtime, it's often useful to receive and display information about online users. Enter \"presence\".Presence is what allows you to see who is present in a realtime channel.If you’re building a collaborative tool, for instance, presence allows you to see who is actively editing or viewing a document:If you are building a message board or a game, it allows users to see who is available to join a game or who is actively participating.Ultimately, the choice of using presence depends on your specific use case.Presence in Supabase ​To get information about presence in a Supabase channel, you will need to listen for Supabase presence events via a page or app workflow:TIPDepending on your use case, you may choose to listen to only specific type of presence events:syncleavejoinIn the example above, you can see:We are listening to all presence events in the room1 channel.We used the Log action to log a presence message in case we need to debug things.We use branches to update a number variable called supabaseOnlineUsers: If Supabase sends a join event, we add 1 to our active user count.If Supabase sends a leave event, we remove 1 from our active user count.On our UI, we can easily bind the supabaseOnlineUsers value to a text element to display the number of active users:Debugging ​When working with event listeners, we highly recommend getting into the habit of adding a Log action that's bound to the Event you receive from Supabase:This is helpful because it allows you to see the event as it comes in.In the example above, despite only one user joining the channel, the workflow was triggered twice. That's because, when a user joins a channel, Supabase triggers two presence events: first a join event, followed by a sync event.If we didn't see that information in the logs, we might have been confused and counted two users instead of one."
  },
  {
    "h1": "Subscribe & unsubscribe to a Supabase channel​",
    "url": "https://docs.weweb.io/websockets/supabase-realtime/subscribe-channel.html",
    "content": "Subscribe & unsubscribe to a Supabase channel ​Why subscribing matters ​If you want users of your app to be able to listen and react to events in a realtime channel, you first need to make them subscribe to the channel.✈️ Realtime events are like flying objects ☄️You can picture a user subscribing to a realtime channel as someone who is entering a room where a bunch of objects (events) are flying around.If the user is in the room, they can see and intercept these objects. If the user is outside the room (unsubscribed), they can't see or react to anything.Use cases ​A few use cases:When user clicks on help icon, they subscribe to the chat channel where instant messages come and go.When user signs up to the app, they subscribe to the releases channel where new events are created every time a new product update is inserted in the database.When user opens a tab, they subscribe to the cursor channel where new events are created with their mouse position every time their mouse moves.Two types of channels ​There are two types of Supabase realtime channels users can subscribe to:Broadcast: Send ephemeral messages from client to clients with low latency. For example, to track users' cursors in a collaborative tool.Postgres Changes: Listen to Postgres database changes and send them to authorized clients. For example, to notify users of a new comment in one of their projects.Subscribe to broadcast ​There are use cases where you don't need to store realtime events in a database. For example, live collaboration tools or online games that track every active user's cursor position.For users to send and receive realtime cursor positions, they first need to subscribe to a realtime Broadcast channel:The Channel name can be anything you want. Here we named it canvas. It's the name we will need to reference later when we want to send and receive messages in this channel.The Type is Broadcast because we are working with ephemereal events that don't need to be stored in our database.We chose to subscribe to only the cursor events because we only want to listen to this specific event type but we could leave the input empty or type in * to subscribe to all the events that go through this channel. What you choose will depend on your use case.The Listen self and Listen presence can be toggled on or off depending on your preferences and use case.Learn more about these options here in the Supabase user docs.Next steps ​Once we have subscribed to a Broadcast channel, we can send, receive and react to realtime events from that channel.Subscribe to db changes ​WARNINGUsers can only subscribe to a channel that listens to database changes if you have enabled realtime on the table that you want to monitor:In many cases, you want users to be able to receive and react to realtime changes in a database. For example, when someone at your company adds a record in the releases table of your database, you want to let users know there's a new product update.For users to send and receive realtime database events, they first need to subscribe to a Database changes channel:In the example above, you can see the user is subscribing to:All eventsin the releases tablethat can be found in the public schema of my Supabase dbThe Channel name can be anything you want. Here we named it releases. It's the name we will need to reference later when we want to send and receive events in this channel.TIPWe chose to subscribe to All events but we could have decided to subscribe only to INSERT events for example. What you choose will depend on your use case.We could also use the Filter input to refine the subscription further. Learn more about filtering for specific changes here.The Listen presence can be toggled on or off depending on your preferences and use case.Next steps ​Once we have subscribed to a Database changes channel, we can receive and react to realtime events from that channel."
  },
  {
    "h1": "Get channel history​",
    "url": "https://docs.weweb.io/websockets/xano-realtime/history.html",
    "content": "Get channel history ​The Realtime | Request history action allows you to access past conversations or data exchanges that occurred in the channel before the current user joined or connected.It's useful for providing context in chat applications, showing recent updates in collaborative tools, or displaying a backlog of events in real-time systems.Pre-requisite ​In order to get history, we first need to enable Message History in the settings of our Xano Realtime channel settings:Xano can retrieve up to 1,000 of the most recent messages per channel when accessing Message History. For our demo example, you can select any number of messages available on the list.Overview ​Now we want our users to see past messages from other users once they join our chatroom. To achieve this, we will:add a Request history actioncreate a workflow to listen for the history event typeprocess history data to extract messagesmerge historical messages with current messagesupdate UI to display combined message historyRequest history action ​In your Realtime | Open channel action, set Get history on join to On. This will enable new users to see past messages when they join:Add the Realtime | Request history action after your Open channel action, provide the channel name, and test the action:We can see the Request History action succeeded, but where exactly is the history data?The Request history action doesn't immediately give you the message history. Instead, it asks Xano to prepare the history. Once ready, Xano sends this history through a separate history event, which we need to listen for to receive and use the historical messages.Listen for history events ​To ensure we can access our requested history, we can create a new page or app workflow that listens for the history event:WARNINGWorkflows that listen to realtime events must be executed at page or app level because you are essentially saying: when this app or this specific page is open in a browser, I want the browser to listen for events so it can react to it.This workflow will listen to history events from the selected Xano channel.We can store information from this event in a WeWeb variable and display it in our UI.In the example below, we created a history array variable and saved the history part of the event we received from Xano:We can then use our WeWeb variable to display history data in our UI in whichever way we like.TIPNote that the history array sent by Xano contains a lot of information that you may or may not need, depending on your use case: Feel free to tweak what you save to the WeWeb variable to adjust to your needs."
  },
  {
    "h1": "Intro to Xano realtime​",
    "url": "https://docs.weweb.io/websockets/xano-realtime/intro-to-xano-realtime.html",
    "content": "Intro to Xano realtime ​What is realtime? ​Realtime is a feature that allows your app to show live updates instantly, without making incessant API calls.For example, in a chat window with lots of messages, it wouldn't be efficient to keep checking for new updates through traditional API requests every few seconds.Xano Realtime is powered by Websockets, which is a technology that keeps a constant connection open, so updates flow continuously between the client (i.e. the user’s browser) and server (in this case Xano) without delays.✅ Some common use cases for Realtime: chat applications, collaborative tools, and live notification systems.❌ When not to use Realtime: low interaction applications, high data volume, and complex transactional systems.Pre-requisites ​To start using Xano realtime in a WeWeb project, there are a few pre-requisites:Enable realtime in your Xano instance.Configure the Xano data source plugin in WeWeb.Create a realtime channel in Xano.Enable realtime in Xano ​Go to your Xano instance.Access your workspace Dashboard.Click on the three dots in the upper right corner.Select Realtime Settings.Enable Realtime status.Enable realtime in WeWeb ​Assuming you have already added the Xano data source plugin to your WeWeb project and enabled realtime in your Xano instance, you will be able to connect the realtime server of your Xano instance to your WeWeb project.To connect your WeWeb project to Xano's realtime server, you will need to add its connection hash to the Xano data source plugin configuration.Copy the realtime Connection Hash from Xano's Realtime Settings menu, and paste it in WeWeb, in the configuration of your Xano data source plugin:And voilà! Your WeWeb frontend and Xano realtime server are now connected 😀Now we can create realtime channels in Xano that our WeWeb frontend can interact with.Configure channels in Xano ​You can think of a channel as a dedicated room where specific real-time interactions or conversations happen.Let’s go back to the Xano's Realtime Settings to create a public channel. We'll name it room1:Nested channels ​Note that, in the Channel target settings, you can enable nested channels:If you enable nested channels, a /* path will automatically be added to your main channel name after you save it:This allows you to dynamically create and organize sub-channels under the main channel.For example, in a chat app, you could have chat/*, allowing for chat/sports, chat/tech, etc.Learn more about leveraging nested channels in Xano.Permissions ​Each channel needs to have permissions defined to ensure that they remain secure and behave in the way that you expect.For the purposes of this tutorial, we’ll keep it simple and open with the following permissions: Anonymous Clients: Allow unauthenticated users to connectPresence: Show active users in the channel (useful for checking online users)Client Public Messaging: Let all users send and receive messagesTIPTo build secure apps, we highly recommend that you learn more about Xano's realtime channel permissions.To do so, please refer to Xano's user documentation on the topic. The section with common use case permissions examples is particularly helpul to get started.When you're ready, click on Save to create the channel.Our channel is now live and running. Awesome! But how can we use WeWeb to interact with it?We'll leverage WeWeb workflows.Leverage WeWeb workflows ​To work with Xano realtime in WeWeb, you can leverage:5 workflow actions to trigger a realtime event.8 workflow triggers to listen for realtime events.Xano realtime actions ​WeWeb’s Xano Realtime integration comes with 5 workflow actions to help us:Event triggers ​In order to update your UI based on activity in the channel, such as user joins, leaves, connection status changes and new messages, you need to listen for realtime events.You can do this by listening for events at page or app level in WeWeb.WeWeb’s Xano Realtime integration comes with 8 workflow triggers to help listen to various realtime events:When one of these workflows \"hears\" an event, you can access the event's payload from the workflow to get the relevant data:In the example above, you can see the Event object received from Xano when use the On realtime - history trigger to listen to such events.Here is a list of realtime event types:connection status: Tells you the status of the connection when you connect to a channel or when you get disconnected involuntarilyerror: Indicates an issue with the connection or interaction.event: Handles dynamic Realtime data.message: Notifies you of new messages.presence full: Provides a one-time list of all users connected to the channel when you join. It will not return the full list again if other users join. You will need to use the Get presence action to retrieve the latest list of active users.presence update: Alerts you when users join or leave.history: Receives history if it was requested using the Request history actionSupport chat example ​Support chat exampleTaking the example of a support chat, here's how you could leverage these actions and triggers.At app level, setup a workflow that triggers On realtime - message.When a user clicks on the support icon of your website trigger a workflow with: The Open channel action so they join the chat channel.The Get presence action so they can see that several support team members are online.The Request history action so they can see their chat history in the chat modal.When a user clicks on the \"Send\" button of the chat: trigger the Send message action.The support team members who are in the channel will receive the message instantly.Next steps ​That's the theory.Learn more about how this works:Open and close a channelSend and receive messagesSend and receive presence informationSend and receive history information"
  },
  {
    "h1": "Send & receive messages (Xano realtime)​",
    "url": "https://docs.weweb.io/websockets/xano-realtime/message.html",
    "content": "Send & receive messages (Xano realtime) ​Pre-requisites ​Before users of your WeWeb app can send and receive Xano realtime messages, you need to:Enable and connect Xano realtime to your WeWeb project (as explained here).Open a channel where messages will flow (as explained here).Once that's done, you can think of sending & receiving messages.Send messages ​To send messages to a realtime channel, we need to use the Send message action.In the example below, we created a workflow that sends a message to Everyone in the room1 channel when a user clicks on the \"Send\" button of a support chat:TIPNotice how you can customize the message event. In the example above, we sent an object with information about the user in addition to the chat input variable.The only thing the Send message action does is send information to the channel.If you test the action and get an error, it means the user is not subscribed to the channel:Otherwise, Xano will return a simple success message:That's because receiving (and displaying) messages is a separate matter.Receive messages ​To receive realtime messages from other users, we need to create a page or app workflow that is triggered when there's a new realtime message event in a channel.WARNINGWorkflows that listen to realtime events must be executed at page or app level because you are essentially saying: when this app or this specific page is open in a browser, I want the browser to listen for events so it can react to it.In the example below, we setup a workflow on a page with a chatroom:The workflow is triggered when there's a new message event in the room1 channel.To help us debug things, we used the Logs action and bound it to the entire workflow Event object.Then we updated a variable with the payload of the workflow Event.TIPNote that, the preview of the Event object and event payload in the workflow editor displays placeholder information.When you test your setup in preview mode, the payload of the message event you receive here will match the Payload value you defined when you created the Send a message action before:Display message events ​To display message events in your WeWeb app, you can update a WeWeb variable every time there's a new event and bind that variable to an item (or list of items) on your page.That way, your UI can react dynamically to the event it receives.Live collaboration example ​For example, in the case of a live collaboration tool that tracks every user's cursor position, you might have a cursors array variable with a seperate objet for every active user.Each object would include the user's cursor position.On your page, you could use that variable to move cursor icons around the page based on each user's position.In the example above, you can see the page is open in three different clients (user browser tabs) and client A can see the cursor position of clients B and C."
  },
  {
    "h1": "Open and close a Xano channel​",
    "url": "https://docs.weweb.io/websockets/xano-realtime/open-close-channel.html",
    "content": "Open and close a Xano channel ​Pre-requisites ​To leverage Xano realtime actions in WeWeb, you first need to enable and connect Xano realtime.If you haven't already, please do so here.Why open a channel matters ​If you want users of your app to be able to listen and react to events in a realtime channel, you first need to make them open the channel.✈️ Realtime events are like flying objects ☄️You can picture a user opening a realtime channel as someone who is entering a room where a bunch of objects (events) are flying around.If the user is in the room (channel opened), they can see and intercept these objects. If the user is outside the room (channel closed), they can't see or react to anything.Open channel ​The Xano Realtime | Open channel action allows you to establish a connection to a Xano channel.WARNINGTriggering this action is a pre-requisite to leverage Xano realtime. It is a required step to send & receive updates in the channel and communicate with others connected to it.In the example below, you can see we created a workflow that opens a channel called room1:Configuration options ​When you setup an Open channel action, you have the option to enable or disable three Xano realtime features:Listen to Presence: This feature keeps track of who enters and leaves the channel, helping you see who is currently active or when someone has left.Get History on Join: When you join a chatroom, this option lets you view previous messages from other users. To leverage this option, you first need to enable Message History in the settings of your channel in Xano:Queue Offline Actions: When a user performs an action, such as sending a message while disconnected, these actions are saved and automatically sent when they reconnect, ensuring nothing is missed.Three things to keep in mind ​1. You can name the channel anything you like.Just remember that, later on, when you start sending events to that channel and listening to events from that channel, you'll need to reference the same channel name.2. You need to decide when this workflow is triggered.Examples include, but are not limited to:On click, to subscribe to a chat channel when a user clicks on a support icon.On page load, to subscribe to a mousemove channel that updates cursor positions in a live collaboration tool.On app load, to subscribe to an update channel that notifies users of new product updates.3. The Open channel action does one thing and one thing only: it opens a two way road between the client (the user's browser tab) and the Xano realtime channel.Sending and receiving events are a seperate topic.Next steps ​Once we have established a connection between WeWeb and a Xano channel, we can:Send a message to that channelListen and react to realtime events from that channel.Close channel ​The Close channel action ends an active realtime channel connection, halting all communications and data exchanges through that channel.TIPClosing realtime channels is a web development best practice to efficiently manage resources and enhance security by ensuring no unnecessary connections remain open.Taking the example of a support chat, you could trigger the Close channel action when the user clicks on a button to close the chat window:WARNINGXano does not issue a disconnected event when you close a channel voluntarily. Instead, disconnected events are triggered only if the connection is unexpectedly lost.In the example above, we have a \"Leave room\" button on our page. When the user clicks on it, we trigger a workflow that closes the channel and updates a text variable we named myStatus with the value \"disconnected\"."
  },
  {
    "h1": "Presence information​",
    "url": "https://docs.weweb.io/websockets/xano-realtime/presence.html",
    "content": "Presence information ​What is presence? ​When working with realtime, it's often useful to receive and display information about online users. Enter \"presence\".Presence is what allows you to see who is present in a realtime channel.If you’re building a collaborative tool, for instance, presence allows you to see who is actively editing or viewing a document:If you are building a message board or a game, it allows users to see who is available to join a game or who is actively participating.Ultimately, the choice of using presence depends on your specific use case.Pre-requisites ​Before users of your WeWeb app can see who is connected in realtime, you need to:Enable and connect Xano realtime to your WeWeb project (as explained here).Open a channel in WeWeb with Listen to presence enabled (as explained here).Once that's done, you can think of working with realtime presence information.Presence workflow actions ​To work with presence in WeWeb, you have access to:The Get presence workflow action.The Presence full workflow trigger.The Presence update workflow trigger.WARNINGYou will only be able to access a channel's presence information if you enabled the option when opening said channel:The Get presence action and Presence full trigger both return the same presence array: a list of currently connected users or clients to a particular channel.The Presence update trigger returns an object with information about the event, including but not limited to:The user's action, i.e. if they joined or left the channel.The user's socketId."
  },
  {
    "h1": "Generating Custom Coded Components​",
    "url": "https://docs.weweb.io/weweb-ai/generating-custom-coded-components.html",
    "content": "Generating Custom Coded Components ​WeWeb's AI allows you to generate fully customized components with code, giving you deeper flexibility than standard elements while maintaining the visual editing experience. With custom coded components, you can implement specific libraries, create unique interactions, and extend WeWeb's capabilities to match your exact requirements.Features ​AI-Powered Generation: Create complex components by describing what you need in natural languageExternal Library Support: Incorporate libraries not natively available in WeWeb (e.g., Highcharts, specific UI frameworks)Complete Customization: Control every aspect of your component through editable propertiesInteractive Elements: Add custom triggers, actions, and exposed variablesComponent Forking: Clone and modify existing components to extend their functionalityUsing AI to Generate Components ​The easiest way to create a custom component is by describing what you need to the AI:Open the AI chat panelDescribe the component you want to create, including: Desired functionalityRequired librariesProperties you want to controlInteractions you needAI will generate the component and add it to your available components. To place the generated component onto your page, drag it onto the page directly from the chat interface:Or, alternatively, drag it from the Coded components menu of the Add panel.Example Prompts ​Here are examples of effective prompts for creating custom components:Create a line chart component using Highcharts that shows customer satisfaction data over time. Include properties for line color, chart title, and animation speed.Create a skeleton loader component with properties for base color, wave color, animation speed, and shape (rectangle or circle). Make sure it has a background fill to cover content beneath it.Understanding Component Architecture ​Custom coded components in WeWeb have four key elements that can be fully customized:1. Properties ​Properties allow you to control your component's appearance and behavior directly from the WeWeb editor:Settings Properties: Control functional aspects (data sources, behavior)Style Properties: Adjust visual aspects (colors, sizes, animations)When generating a component, specify the properties you want to control:Create a custom progress bar with properties for: - Progress value (0-100) - Bar color - Background color - Border radius - Animation speed2. Workflow Triggers ​Triggers allow your component to initiate workflows when specific events occur:User Interactions: Clicks, hovers, selectionsData Changes: Value updates, selectionsState Changes: Loading states, error conditionsExample of requesting specific triggers:Create a custom image carousel with workflow triggers for: - On image change - On image click - When carousel reaches the end3. Component Actions ​Actions let you execute functionality in the component from other elements on your page via workflows. An action could be something such as:Workflow Execution: Trigger workflows of the componentState Changes: Updating internal states of the componentData Manipulation: Modify data displayed inside the componentExample of requesting specific actions:Create a custom map component with actions for: - Center on specific coordinates - Change zoom level - Toggle point of interest visibility4. Exposed Variables ​Variables expose component data to be used elsewhere in your app:Selected Values: Currently selected itemsComponent States: Loading states, current positionsProcessed Data: Calculated resultsExample of requesting specific variables:Create a date range picker that exposes variables for: - Selected start date - Selected end date - Number of days in selectionForking Components ​Forking allows you to create a clone of an existing component, which you can then modify the functionality of while maintaining the core behavior.When to Fork Components ​Fork a component when you need to:Add features not available in the original componentModify the core behavior of a componentCreate specialized versions of standard componentsHow to Fork a Component ​There are two ways to fork components:With the component selected on the page, via the settings in the top right of the editorFrom the settings of the component in the Coded components menu of the Add panelExample Fork Scenario ​Enhanced Reorder ListImagine you are using the native Reorder List component and you want to apply a custom border color to the dragged item. This is not possible via the native component, however, you could fork the Reorder List and ask AI to add this ability.Here is a short demo:"
  },
  {
    "h1": "WeWeb AI (Beta)​",
    "url": "https://docs.weweb.io/weweb-ai/intro-to-weweb-ai.html",
    "content": "WeWeb AI (Beta) ​WeWeb AI is an intelligent assistant that helps you create every aspect of your web application through natural conversation. Simply describe what you want to build, and watch as the AI transforms your words into functional components, workflows, and systems.WARNINGWeWeb AI is currently in beta. While it significantly accelerates development, you may encounter occasional limitations or behaviors that need refinement. Our team is actively working to improve the AI's capabilities, enhance its understanding of complex requirements, and expand its feature set. We recommend testing AI-generated elements thoroughly and welcome your feedback to help us enhance the platform.Design & layouts ​WeWeb AI understands your design intentions. Describe the page or component you envision, and the AI will generate responsive layouts that adapt to all screen sizes. Want a hero section with a headline, image, and call-to-action? Or perhaps a pricing grid with tiered options? Just ask. The AI creates these designs while maintaining your brand's visual identity through consistent colors, typography, and spacing.Workflows & logic ​Building application logic becomes a conversation. Tell WeWeb AI what you want your application to do, and it will create the necessary workflows. From simple data updates to complex multi-step processes, the AI understands logical relationships and user interactions. Need a workflow that validates form submissions, sends confirmation emails, and updates your database? The AI can set this up through natural language prompts.Backend & data ​Database configuration and API integration no longer require technical expertise. WeWeb AI helps you structure your data models, set up authentication systems, and create API endpoints through simple conversation. Describe your data relationships and user permissions, and the AI will configure the appropriate backend systems. Whether you need user management, content administration, or complex data queries, the AI understands and implements these requirements.Formulas & calculations ​Complex calculations and data transformations become straightforward. WeWeb AI can generate formulas for various scenarios, from basic arithmetic to sophisticated data manipulation. Need to calculate user metrics, format data, or implement business logic? The AI creates these formulas while ensuring accuracy and performance.Custom component generation ​WeWeb AI takes component creation to the next level by generating custom-coded components with the library of your choice.The AI understands the unique capabilities and best practices of different libraries, creating components that leverage their specific features. This means you can get the power of custom-coded components with the ease of no-code development."
  },
  {
    "h1": "Passing Context to AI​",
    "url": "https://docs.weweb.io/weweb-ai/passing-context-to-ai.html",
    "content": "Passing Context to AI ​WeWeb AI can analyze and understand the data of your entire project, but providing specific context helps it focus on particular elements and deliver more precise responses. Whether you need help with formulas, workflows, or recreating designs, passing the right context makes AI interactions more efficient and productive.Adding Context to Your Prompts ​You can enhance your AI prompts by providing specific context from various sources in your project:Frontend Context Types ​The AI can accept various types of context from your project:Context TypeIndicator In ChatDescriptionVariablesData variables and collectionsImagesVisual referencesElementsUI elements from your projectFormulasFormula from your projectWorkflowsWorkflow from your projectComponentsCoded Component from your projectUsing Variables And Project Data ​Click the plus icon (\"+\") in the chat input areaThe context binding menu will appear, displaying all available data in your projectSelect the specific data points you want to include as contextYour selected items will appear in the context panel within the chatWhen you send your prompt, the AI will focus specifically on the data you've provided, helping it generate more targeted and relevant responses.Adding Images as Context ​Images provide powerful visual context for the AI. There are two ways to add images:Method 1: File Upload ​Click the image icon in the chat input areaSelect the file you want to upload from your computerThe selected image will appear in the chatMethod 2: Copy and Paste ​Copy an image from any source (screenshot, file explorer, browser, etc.)Click in the chat input areaPaste the image using keyboard shortcut (Ctrl+V or Cmd+V) or right-click and select PasteThe pasted image will appear in the chatAny subsequent prompts will include your image(s) as contextThis feature is especially valuable when:Recreating designs from visual referencesAsking for UI improvements based on existing layoutsTroubleshooting visual issues in your applicationAdding Elements as Context ​There are two ways to pass elements as context:Click on the element on the page, orClick on the element in the layout treeThis direct element selection is especially helpful when:Asking for styling of particular elementsAttempting to create logic for specific elementsAutomatic Context From Workflows And Formulas ​When you have a formula window or workflow open:The contents of the open formula window or workflow are automatically passed as context to the AIAny prompts you make while these are open will include them as contextFormulaWorkflowThis automatic context passing makes it easier to get help with complex formulas or workflows without having to manually explain what you're working on.Adding Custom Components As Context ​Like elements, there are two ways to pass in custom components as context:Click on the component on the page, orClick on the component in the layout treeWhenever you pass in a custom component like this, the element will also be passed in like so:The reason for this is that there may be cases where the AI needs to only modify the current selected properties or styling of the component, and not need to edit the actual code of the component in order to acheive the desired outcome. Because of this, the element is provided to the AI to help provide all needed context.Passing in a custom component better allows the AI to:Update the properties being passed into the componentEdit the source code of the component if it is deemed the functionality needs to be extendedBackend Context Types ​You can also pass backend-related context to the AI to get more specific guidance on data operations:Context TypeVisual IndicatorDescriptionTablesDatabase tables from your backendFunctionsFunctions from your backendAPIsAPIs (Edge Functions) from your backendSecret KeysAuthentication keys and tokens from your backendWARNINGFor now, the AI is only be able to interact with your backend if you are using Supabase via the native Supabase plugins in the editor. To learn more about how to integrate Supabase in your project, you can refer to the dedicated documentationAdding context from your backend all happens from the backend panel: Passing Tables As Context ​Click the Tables tab in the backend panelSelect the table you want to pass as contextThe selected table will appear as context in the chatPassing Functions As Context ​Click the Functions tab in the backend panelSelect the function you want to pass as contextThe selected function will appear as context in the chatPassing APIs As Context ​Click the API tab in the backend panelSelect the API you want to pass as contextThe selected API will appear as context in the chatPassing Secrets As Context ​Click the Secrets tab in the backend panelSelect the secret you want to pass as contextThe selected secret will appear as context in the chatBest Practices ​To get the most out of context-enhanced AI interactions:Combine context types: For complex questions, provide both data and visual contextClear unneeded context: Remove context items that are no longer relevant by clicking the \"×\" next to themStart simple: Begin with minimal context and add more if the AI needs additional informationExample Use Cases ​Formula Assistance ​Open the formula editor, then ask the AI:\"Please modify this formula to also check if the user is logged in?\"The AI will have context of your current formula and make the appropriate changes.Design Recreation ​Upload an image of a design, then prompt:\"Please recreate this design for me\"The AI will analyze the image and recreate the design on the current page.Data Manipulation ​Select a data collection as context, then ask:\"I want to create status cards bound to this collection and only show items where status is 'active'\"The AI will create a card to show the data and automatically bind the repeating of the card to the filtered collection.Workflow Optimization ​With a workflow open, prompt:\"I want to add the selected item's data to the user's cart\"The AI will analyze your workflow and available variables, and then implement the needed logic."
  },
  {
    "h1": "Change language​",
    "url": "https://docs.weweb.io/workflows/actions/change-language.html",
    "content": "Change language ​The Change language action switches the display language of your application or specific pages. In WeWeb, you can add languages at either the app level (affecting the entire application) or page level.How it works: ​When you add a new language, all text content becomes translatable between your default language and added languages:There are two ways to change languages in WeWeb:Using the Language dropdown elementUsing the Change language action in a workflowYou can trigger the action through workflows, such as on a button click or when a specific condition is met. When the action is executed, the content on the page updates to the selected language, provided the necessary translations have been set up."
  },
  {
    "h1": "Change theme​",
    "url": "https://docs.weweb.io/workflows/actions/change-theme.html",
    "content": "Change theme ​Change theme action ​The Change theme action is helpful to allow users to switch between light mode and dark mode on your WeWeb app:TIPThe theme variable is in the context of the user's browser. This means that the value is stored in the user's browser.If user A switches to dark mode on browser A and login to the app later in browser B, they will view the app in browser B in light mode. But if they login again in browser A, they will view the app in dark mode.Leveraging library colors ​When you create a color in a WeWeb library, you have the option to attach the color to a Light theme or a Dark theme:Using this option makes it easier to build and maintain beautiful themes because you can bind to a color from the library instead of handling color options in a separate variable:Theme at app level ​At app level, you can choose:a default theme for your appbackground options and hierarchy (e.g. Color > Gradient > Image)a default color backgroundTo apply themes at app level, go to More > Settings"
  },
  {
    "h1": "Change variable value​",
    "url": "https://docs.weweb.io/workflows/actions/change-variable-value.html",
    "content": "Change variable value ​The Change variable value action updates a variable's value. When triggered, it sets a new value for your specified variable, which can affect:UI elements that reference the variableWorkflow logic and conditionsData processing operationsApplication stateOther variables that depend on this valueAPI calls that use the variableCalculations and computed values"
  },
  {
    "h1": "Copy to clipboard​",
    "url": "https://docs.weweb.io/workflows/actions/copy-to-clipboard.html",
    "content": "Copy to clipboard ​Allow users to copy text from your web-app to their clipboard so they can paste it elsewhere.In the example below, when a user clicks on the element, the value \"This is my new value\" will be copied to their clipboard:As a result, they will be able to paste that value after clicking on the element.Of course, you can bind the value of this action to a variable to make it dynamic.In the example below, we bound the value of the action to an input variable:"
  },
  {
    "h1": "Create URL from Base64​",
    "url": "https://docs.weweb.io/workflows/actions/create-url-from-base64.html",
    "content": "Create URL from Base64 ​If your backend returns a file in Base64, you can use the Create URL from Base64 action to transform this file into an object URL that you can more easily work with.You can then use that object URL to reference that file in your app, allowing users to download it or preview it on the page of your app for example.Input ​In the example below, our backend returns an image in Base64 but the info looks like this and is unreadable as is:Output ​We can use the Create URL from Base64 action in a workflow to transform the Base64 into a object URL:The result from this action is an object URL:We can use this object URL to reference the file in our app so that users can download it or see it on the page.Example ​In the example below, we bound the object URL to an image element to display the image in our app:"
  },
  {
    "h1": "Custom JavaScript​",
    "url": "https://docs.weweb.io/workflows/actions/custom-javascript.html",
    "content": "Custom JavaScript ​The Custom JavaScript action allows you to write and execute custom JavaScript code within your workflow. This gives you the flexibility to handle complex logic, data transformations, and custom functionality.TIPWeWeb is a visual development platform - you don't need JavaScript knowledge to create powerful applications. However, WeWeb still gives you the flexibility to add custom code if you want to extend your application's capabilities.Capabilities ​Write any pure JavaScript code you needManipulate any variables and execute any workflows in your applicationSet up initialization scripts for external librariesPerform complex calculations and data transformationsAccess variables and action results in workflowsReturn values for use in subsequent actionsHow to use ​Add the Custom JavaScript action to your workflowWrite your JavaScript code in the editorUse any variables from your projectReturn any values you want to use in subsequent actions"
  },
  {
    "h1": "Download CSV​",
    "url": "https://docs.weweb.io/workflows/actions/download-csv.html",
    "content": "Download CSV ​Add plugin ​In the Plugins > Extensions section, you can add the CSV plugin:Download CSV action ​When you add this to your WeWeb project, you will unlock access to the Download data as CSV action in workflows.WARNINGThe Data field in the Download data as CSV action expects an array of items, even if there's only one item in the list.In the example above, we used a split formula to separate rows and bind the Data to an array."
  },
  {
    "h1": "Download file from URL​",
    "url": "https://docs.weweb.io/workflows/actions/download-file-from-url.html",
    "content": "Download file from URL ​The Download file from URL action allows you to trigger file downloads without opening a new tab.You can pass two parameters:the URL of the file to download (required)the name of the file to download (optional)File URL (required) ​This is a required field and implies that you know where the file is hosted.In the example below, we bound to the file URL returned by our backend:TIPNotice in the example above that we bound to the url field, not the vault field of the image object. This is because the vault value is a relative path that is missing the domain where the file is hosted.To check that you are binding to the correct URL, paste the URL in a new tab in your browser. You should be able to see the file as we do here:File name (optional) ​Here you can bind the name of the file that will be downloaded on your user's computer:This field is optional. If you leave it empty, a random name will be generated (e.g. 50700faa-3ba6-4f97-8bc8-a9476711f694.jpeg)WARNINGYou can leave the File name field empty but if you do add a file name, it must include the file extension (e.g. .pdf, .png, .jpg, etc)"
  },
  {
    "h1": "Encode file as Base64​",
    "url": "https://docs.weweb.io/workflows/actions/encode-file-as-base64.html",
    "content": "Encode file as Base64 ​What is it for ​The Encode file as Base64 allows you to:take a file that was uploaded by a user, and,encode in the Data URL or Base64 format.Depending on your use case you will choose one output type or another.The Encode file as Base64 is very useful if you want to upload files directly to your backend without going through WeWeb's CDN, and without resorting to custom code.How it works ​In the example below, we created a workflow on a file upload element:added the Encode file as Base64 action,decided what file we wanted to encode by selecting the component variable of our file upload element,chose to receive the encoded file in Data URL, andtested the action to see the result of the actionThen we made a couple of requests to our backend to upload the file there and create a new record in one of our database tables.TIPThe requests you make in your workflow and the format you choose for the output of the Encode file as Base64 action will depend on what you need to do with the file afterwards or where you want to send it.In the example below, we show you how to use it to upload a file directly to Xano:"
  },
  {
    "h1": "Execute component action​",
    "url": "https://docs.weweb.io/workflows/actions/execute-component-action.html",
    "content": "Execute component action ​In WeWeb, components can have actions that allow you to control their behavior. These actions are available for:Components you create directly in WeWebBuilt-in WeWeb elements (like the video element)Custom imported Vue.js componentsComponents created with the editor ​Components are designed to be self-contained with their own variables and workflows. By default, component workflows are encapsulated and only accessible from within the component to maintain clean separation of concerns and prevent unwanted external interference.To make a workflow available as an action that can be triggered from outside the component, select the component workflow and enable Allow execution from outside. This allows the workflow to be triggered from anywhere using the Execute component action action.Built-in elements ​Some WeWeb elements come with pre-configured actions. For example, the default WeWeb video element comes with 3 actions that help you control video playback:In the example below, we used the component actions configured in the default WeWeb video element to build our own custom controls:Coded components: adding actions ​In WeWeb, you can import custom Vue.js components with your own config file. If you need inspiration, our components are open source.Learn more about developing custom components with Aurélie and Q:"
  },
  {
    "h1": "Execute workflow​",
    "url": "https://docs.weweb.io/workflows/actions/execute-workflow.html",
    "content": "Execute workflow ​The Execute workflow action allows you to trigger another workflow from within your current workflow. This is useful for:Reusing global workflows across different parts of your applicationBreaking down complex workflows into smaller, manageable piecesKeeping your workflows organized and maintainableBy breaking down complex logic into reusable global workflows, you can build powerful, scalable features that can be easily reused across your application.How to Use ​Let's say you want to trigger a global workflow from a button's local workflow:Go to the Actions tabGive your global workflow a namePass parameters if needed (optional)For example, to create a global workflow that logs a message to the console:Add a Log actionAccess the Events tab to retrieve your defined workflow parametersIn your button workflow, add the Execute workflow action and select the workflow you want to execute. You'll then be prompted to provide any required parameters.When the button is clicked, it will execute the global workflow:TIPUse Execute workflow whenever you find yourself repeating the same series of actions in different places, or when a workflow becomes too complex to manage."
  },
  {
    "h1": "Fetch collection​",
    "url": "https://docs.weweb.io/workflows/actions/fetch-collection.html",
    "content": "Fetch collection ​The Fetch collection action allows you to manually trigger data fetching for any collection in WeWeb. While collections can fetch data automatically when a page loads, there are times when you need more control over when and how data is refreshed.When you add a Fetch collection action to a workflow, you select which collection to fetch. Upon triggering, the action makes a fresh request to your data source (like REST API, Supabase, or Xano) and updates your collection with the latest data.A common use case ​A modal display scenario is a perfect example - rather than loading all possible data when your page loads, you might want to fetch specific collection data only when a user opens a modal. This improves initial page performance while ensuring data is fresh when needed."
  },
  {
    "h1": "Fetch collections in parallel​",
    "url": "https://docs.weweb.io/workflows/actions/fetch-collections-in-parallel.html",
    "content": "Fetch collections in parallel ​The Fetch collections in parallel action allows you to trigger multiple collection fetches simultaneously in WeWeb. Unlike the basic Fetch collection action which handles one collection at a time, this action lets you select multiple collections that should be fetched concurrently. When triggered, it makes fresh requests to your data sources in parallel and updates all selected collections with their latest data.Imagine you're building a dashboard page that needs to show:A list of recent ordersCurrent inventory levelsCustomer reviewsSales statisticsWithout parallel fetching, the requests works sequentially, like this:Get ordersOnce orders retrieved, THEN get inventoryOnce inventory retrieved, THEN get reviewsOnce reviews retrieved, THEN get salesTotal: If each retrieval took 1 second, then it would take 4 seconds to load everything.With parallel fetching, these requests would happen simultaneously:Get ordersGet inventoryGet reviewsGet salesTotal: If each retrieval took 1 second, then it would only take 1 second to load everything as all the requests would happen at the same time.So instead of waiting for each piece of data one after another (which takes longer), parallel fetching gets all the data at once. This is akin to Promise.all() in JavaScript.TIPWhile parallel fetching can significantly improve performance, actual loading times depend on various factors such as your backend server capacity, API rate limits, network conditions, and the complexity of your data queries. Monitor your application's performance to ensure optimal results."
  },
  {
    "h1": "Log​",
    "url": "https://docs.weweb.io/workflows/actions/log.html",
    "content": "Log ​The Log action is a debugging and monitoring tool that outputs messages to the Logs tabConfiguration ​Name: you can give your log action a name for better organization in your workflow. This is optional but helpful when managing multiple log actions.Type ​The log type determines how your message appears in the console:Info: for standard log messagesVerbose: for detailed debugging informationWarning: for potential issues that need attentionError: for critical problems and errorsMessage: enter the text you want to output to the console. This is required and can be a static message or a dynamic value from your workflow.Data to display: optionally include additional data alongside your message. This could be variable values, API responses, or any other data you need to monitor. The data can be input as JSON or JavaScript expressions.Common applications ​When building, you might use logs to track API responses, verify calculations, or monitor user interactions. For example, placing a Log action after a button click can confirm the click was registered and show what data was captured.When debugging complex workflows, logs help verify that actions are executing in the expected order and that variables contain the correct values at each step. They're particularly useful for tracking data transformations and catching potential issues before they cause problems.In error scenarios, log actions can capture and display detailed error information, making it easier to identify and fix issues in your application."
  },
  {
    "h1": "Print PDF​",
    "url": "https://docs.weweb.io/workflows/actions/print-pdf.html",
    "content": "Print PDF ​The Print PDF action allows you to open the browser's print dialog, enabling users to print the current page or save it as a PDF. This action integrates with your browser's native printing capabilities.How it works ​When triggered, this action opens your browser's print dialog, where users can:Preview the page layoutChoose printer settingsSave as PDFSelect specific pages to printAdjust margins and scalingConfiguration ​Since this action uses the browser's built-in print functionality, no additional configuration is required. Simply add it to your workflow and it will open the print dialog when triggered.Common applications ​This action is particularly useful for generating printable reports, creating PDF versions of documents, or allowing users to save receipts and confirmations. It's commonly used in:Report generation interfacesInvoice printing systemsDocument management toolsReceipt generation after purchasesExporting data views for offline use"
  },
  {
    "h1": "Reset variable value​",
    "url": "https://docs.weweb.io/workflows/actions/reset-variable-value.html",
    "content": "Reset variable value ​The Reset variable value action allows you to reset a variable back to its default value. This action is useful when you need to clear or restore a variable to its starting state.Use cases ​Form handling: reset form fields after submissionCounter reset: return counters or incrementors back to their starting valueState management: clear temporary states or flags after they're no longer neededFilter reset: clear applied filters back to their default valuesNavigation: reset page-specific variables when leaving a pageHow to use ​Select the Reset variable value actionChoose the variable you want to resetThe variable will return to its default value when the action is triggeredTIPUse this action in combination with other workflow actions to create clean state management in your application. For example, after processing a form submission, you can reset all form variables to create a fresh start for the next entry.WARNINGYou shouldn’t trigger workflows on submit buttons. For your users to benefit from automatic form field validation, you should trigger submit workflows on the form container. Unless you are 100% sure of what you’re doing and want to bypass this behavior."
  },
  {
    "h1": "Return a value​",
    "url": "https://docs.weweb.io/workflows/actions/return-a-value.html",
    "content": "Return a value ​The Return a value action passes data forward in your workflow - it is much like a variable, however it is only momentarily stored for the run of the workflow. The returned value can then be accessed via the 'result' field of the workflow action.How it works ​Add a Return a value action to your workflowSet the value you want to returnIn subsequent actions, access the returned value via the 'result' field of the workflow action:While this is a dedicated action for returning values, other actions like Custom JavaScript can also make data available via its respective 'result' field through their return statements.TIPThis action provides a clean way to pass processed data back when used in reusable workflows that are executed within other workflows. It's also useful for storing intermediate results that you need to use in later steps of your workflow, making your data flow clearer and more organized."
  },
  {
    "h1": "Stop click propagation​",
    "url": "https://docs.weweb.io/workflows/actions/stop-click-propagation.html",
    "content": "Stop click propagation ​What is event bubbling? ​Imagine you have a button inside a clickable card. When you click the button, by default in JavaScript, the click event \"bubbles up\" - meaning it triggers the button's click event, then the card's click event too. This bubbling is a core JavaScript behavior, like a ripple in water that spreads outward affecting larger and larger areas.The problem ​This natural JavaScript bubbling behavior can cause unintended effects. For example:You click a \"Delete\" button inside a clickable cardThe button click deletes an itemBut then the click also bubbles up to the card, which might navigate to a different pageNow you have unwanted navigation happening after your delete actionThe solution ​The Stop propagation action stops this default JavaScript event bubbling. It tells the event \"stop right here, don't spread any further.\" So in our example:User clicks the Delete buttonDelete action happensStop propagation prevents the click from reaching the cardNo unwanted navigation occursTIPThis action executes both:Event.stopPropagation(): stops the event from bubbling upEvent.preventDefault(): prevents the default browser behaviorSet this action as the first action in your workflow for best results."
  },
  {
    "h1": "PostgreSQL functions​",
    "url": "https://docs.weweb.io/workflows/actions/supabase/call-postgres-function.html",
    "content": "PostgreSQL functions ​PostgreSQL or database functions are built-in database tools that handle data tasks directly inside your database. Think of them like automatic helpers that can:Add up all your monthly salesFix customer names that were entered with typosCreate reports showing which products sold best last weekAnd much more!For example, when a customer clicks \"View Sales Report\" on your web app, it could call a PostgreSQL function named get_monthly_sales that instantly calculates and returns total sales for each month, instead of having to write complex code in your frontend to do these calculations.TIPSupabase is built on PostgreSQL, a database system which uses SQL. SQL is a language for interacting with databases to get, delete, and update data using queries. A query is a command that tells the database what action to perform. In SQL, you can retrieve data from a table using the SELECT statement.if you run:sqlSELECT CustomerName, City FROM Customers;This query will:Retrieve the CustomerName and City columns from the Customers table.It will return a list of all customer names and their corresponding cities stored in the table.Beyond basic queries ​Let's imagine you’re building an app that helps track user activity by calculating important metrics based on three connected tables:logins: tracks when users log in.posts: tracks posts created by users.comments: tracks comments written by users.While you could use SELECT with multiple table joins to gather this information, it creates lengthy, complex queries that need to be repeated everywhere you need these metrics. Using a database function instead lets you write the logic once and reuse it by simply calling get_user_activity_stats(). This makes your code cleaner and easier to maintain, since any changes only need to be made in one place.Like having a reusable report template, database functions give you:Single source of truth for your query logicConsistent data calculations and formattingSimpler code maintenanceThis is what our function would look like:sqlCREATE OR REPLACE FUNCTION get_user_activity_stats(user_id INT) RETURNS TABLE(logins INT, posts INT, comments INT) AS $$ BEGIN RETURN QUERY SELECT (SELECT COUNT(*) FROM logins WHERE user_id = user_id AND login_date >= NOW() - INTERVAL '30 days') AS logins, (SELECT COUNT(*) FROM posts WHERE user_id = user_id AND post_date >= NOW() - INTERVAL '30 days') AS posts, (SELECT COUNT(*) FROM comments WHERE user_id = user_id AND comment_date >= NOW() - INTERVAL '30 days') AS comments; END; $$ LANGUAGE plpgsqIf the code above seems a bit intimidating, don't fret, let's go through it line by line:First linesqlCREATE OR REPLACE FUNCTION get_user_activity_stats(user_id INT)This line creates a new function named get_user_activity_stats that needs a user ID number to work.Second LinesqlRETURNS TABLE(logins INT, posts INT, comments INT) AS $$This tells us what information we'll get back: a table with three numbers - count of logins, posts, and comments.Start blocksqlBEGIN RETURN QUERYBEGIN tells the database \"start following these instructions\".RETURN QUERY is like saying \"collect and bring back this information.\"Main Partsql(SELECT COUNT(*) FROM logins WHERE user_id = user_id AND login_date >= NOW() - INTERVAL '30 days') AS logins,This counts how many times the user logged in during the last 30 dayssql(SELECT COUNT(*) FROM posts WHERE user_id = user_id AND post_date >= NOW() - INTERVAL '30 days') AS posts,This counts how many posts they made in the last 30 dayssql(SELECT COUNT(*) FROM comments WHERE user_id = user_id AND comment_date >= NOW() - INTERVAL '30 days') AS comments;This counts their comments from the last 30 daysEnd PartsqlEND; $$ LANGUAGE plpgsql;This just tells the database we're done writing our function.If you call the function with user_id = 123, an example output could be:loginspostscomments15723If we tried to achieve the same for three users using only SELECT statements, our code would look like this:sql-- Stats for User 123 SELECT (SELECT COUNT(*) FROM logins WHERE user_id = 123 AND login_date >= NOW() - INTERVAL '30 days') AS logins, (SELECT COUNT(*) FROM posts WHERE user_id = 123 AND post_date >= NOW() - INTERVAL '30 days') AS posts, (SELECT COUNT(*) FROM comments WHERE user_id = 123 AND comment_date >= NOW() - INTERVAL '30 days') AS comments; -- Stats for User 456 SELECT (SELECT COUNT(*) FROM logins WHERE user_id = 456 AND login_date >= NOW() - INTERVAL '30 days') AS logins, (SELECT COUNT(*) FROM posts WHERE user_id = 456 AND post_date >= NOW() - INTERVAL '30 days') AS posts, (SELECT COUNT(*) FROM comments WHERE user_id = 456 AND comment_date >= NOW() - INTERVAL '30 days') AS comments; -- Stats for User 789 SELECT (SELECT COUNT(*) FROM logins WHERE user_id = 789 AND login_date >= NOW() - INTERVAL '30 days') AS logins, (SELECT COUNT(*) FROM posts WHERE user_id = 789 AND post_date >= NOW() - INTERVAL '30 days') AS posts, (SELECT COUNT(*) FROM comments WHERE user_id = 789 AND comment_date >= NOW() - INTERVAL '30 days') AS comments;We are repeating SELECT many times. This approach is prone to errors and hard to maintain, hence the usefulness of database functions.Learn more about how to create database functions hereTIPThe example above (consolidating complex queries) is popular because it's a common pain point, but database functions are really a Swiss Army knife for database operations. They're particularly valuable when you need consistent behavior across different applications or users accessing the same database.A couple of additional use cases include but are not limited to:Automating business logic: automatically assigning tickets when a new issue is created.Trigger-based functions for event handling: when a user likes a post, update the likes_count in a summary table.Call a Postgres function ​The Call a Postgres function action in WeWeb, available after installing the Supabase plugin, lets you execute database functions directly from your application.Consider a customer service ticket management app with these connected tables:tickets: basic ticket info.ticket_status_history: how many times the ticket was reopened.ticket_comments: how many comments are waiting for a response.agents: how many tickets the agent is handling.departments: SLA rules for the ticket.We could create a function to return ticket stats. For example, you might want to know:The total number of tickets in the systemHow many tickets are currently open vs closedThe number of high-priority tickets that need attentionThe average time it takes to resolve ticketsOnce you are done writing the code for the function, you can add the Call a Postgres function action to call that function.To verify your Postgres function execution, use the Logs tab to inspect the returned values:WARNINGIf Row-Level Security (RLS) is enabled, your function might not return data unless you explicitly allow it.PostgreSQL functions vs. Edge Functions ​It's easy to mix up database functions with Edge Functions. Database functions operate directly within your database, working on your data at its source. On the other hand, edge functions run on distributed servers located closer to users, managing tasks such as authentication, data transformations, and integrations with external services like payment processors.Here is a comparison table:FeaturePostgreSQL Functions 🛢️Edge Functions 🌍Where it runsInside the databaseOn distributed servers (Supabase Edge)Best forData calculations, triggers, background tasksExternal APIs, authentication, webhooksPerformanceFaster for database-heavy tasksSlower for database queriesScalabilityScales with database resourcesScales with web traffic, limited by compute/concurrency"
  },
  {
    "h1": "Insert​",
    "url": "https://docs.weweb.io/workflows/actions/supabase/database-insert.html",
    "content": "Insert ​Insert is a SQL operation that adds new records to a database table. When you insert data, you create one or more new rows containing values for specified columns. Each insert operation can add a single record or multiple records at once, similar to adding new rows to a spreadsheet. All new records must follow the table's rules for required fields and data types.If you have installed the Supabase data source plugin, you will have access to the Supabase Database | Insert action in workflows:In the example above, we are inserting one row in the cars table.WARNINGBy default Supabase tables have RLS (Row-Level Security) enabled. Before you insert a record in a Supabase table, make sure that table has the correct INSERT policies.If the table requires a user to be authenticated to insert a record, make sure you are logged in as a user of your app when you test your workflow in WeWeb.If you try to create a record without the proper authorization, Supabase will return an error.Learn more about implementing Supabase RLS policies.Single insert ​With the Supabase insert action, you can create a Single record or Multiple records at once.When creating a single new record in Supabase, all the table fields will be listed by default:TIPFields with a placeholder that starts with Default: will be filled out automatically by Supabase if left empty.You can choose to select only the fields that you need upon creation of the record:Multiple (bulk) insert ​To insert multiple records at once, you have two options.Bind the Rows with a list of itemsIn the example above, we are creating two records with the same values for both the make and model fields.Click on Add item and bind each Row to an objectTIPWhen binding Rows, the Current value should be a list of items (i.e. an array of objects).When binding a single item, i.e. a Row, the Current value should be a single object with key value pairs.Return inserted rows ​By default, when you successfully insert a new record, Supabase will simply return a success message.Depending on your use case, you may want Supabase to include the row(s) just created in its response.To achieve this, you will need to enable the Return inserted rows option when configuring the insert action in WeWeb:WARNINGIf you enable this option, make sure you are testing the workflow with a user that has the rights to SELECT data from this table.Otherwise, you will get an error because you are trying to read data without being authorized to do so.Learn more about implementing Supabase RLS policies.Using explain ​EXPLAIN is a PostgreSQL command that can help you understand and optimize how your queries are performing.This is an advanced backend feature that we recommend learning through the user documentation of Supabase and its underlying technology PostgreSQL."
  },
  {
    "h1": "Select​",
    "url": "https://docs.weweb.io/workflows/actions/supabase/database-select.html",
    "content": "Select ​Supabase is built on PostgreSQL, a database system which uses SQL. SQL is a language for interacting with databases to get, delete, and update data using queries. A query is a command that tells the database what action to perform. In SQL, you can retrieve data from a table using the SELECT statement.if you run:sqlSELECT CustomerName, City FROM Customers;This query will:Retrieve the CustomerName and City columns from the Customers table.It will return a list of all customer names and their corresponding cities stored in the table.Adding the Supabase plugin provides several actions for performing various operations, including:Fetching data with Select ​The Database | Select workflow action allows us to get data from our tables. While this is similar to fetching data at the collection level, Database | Select gives us advanced options, namely:Count the results: get the total number of matching rowsOrder the results: sort data by chosen fieldsLimit the number of rows: return only a specific number of itemsLimit the query to a range: return rows within a range (useful for pagination)Retrieve one row: get exactly one matching recordRetrieve zero or one row: get one record if it exists, nothing if it doesn'tRetrieve as CSV: export data in CSV formatUsing explain: see how the database executes your query (for debugging)In the example below, we are using the Database | Select action in Advanced mode to retrieve data from the properties and property_images tables:Filters ​To fetch filtered data from Supabase, you can click on Add filter and configure the filter(s) of your choice:In the example above, we have a simple filter to fetch only the properties where the value in the price column is equal to 45000.Apply if is a toggle switch that controls whether your filter condition is active or not:When On: the filter (in this case \"price = 450000\") will be applied to your queryWhen Off: the filter is ignored, even though it's set upLearn more about Supabase filters in their user documentation.Count results ​By default, when you select this option, Supabase will return an object with:The number of items returned (the count), andThe list of items (the data)You can choose to return only the count of items without the list of items switching Return count only to On.Count algorithms ​By default, WeWeb will request the Exact count of items to Supabase, but you can ask Supabase to returned the Planned or Estimated count instead.Exact: counts everything precisely but slowerPlanned: uses pre-calculated numbers, faster but might be offEstimated: uses Exact for small data, Planned for large dataTIPCounting is important in database queries to determine how many records exist in a given context. This is commonly needed in flows like:Search results: displaying \"Found 237 results\" after a search query.Analytics & dashboards: calculating total users, sales, or other metrics.Conditional logic: deciding whether to show \"No items found\" or load more data.Since counting all rows (Exact) can slow down large queries, optimized methods (Planned or Estimated) help improve performance while providing approximate counts.If you are unsure which count algorithm to choose, Supabase recommends starting with Exact and explore other options when performance becomes an issue.Learn more about Supabase count algorithms.Order the results ​With this option, you can order the items in ascending or descending order:In the example above, the properties are ordered by price, in ascending order. As a result, properties with the lowest price are listed first.Order by referenced table value ​You can order items based on the value of a related field.For example, in our properties table, we could have a main_image field that references the property_images table.In the Fields step of our select configuration, we used the Advanced mode to fetch the related image_url and display_order values of each property record. Now, we can order our properties based on the display_order of its main image:TIPNulls first is an ordering option in SQL that determines where NULL values should appear when sorting results.For example, if you're ordering properties by price and some properties have no price (NULL):With NULLS FIRST: NULL, $450000, $650000With NULLS LAST: $450000, $650000, NULLWARNINGYou can only sort by data from linked tables using Database | Select if you've first specified those linked fields in Advanced mode.For example, to sort properties by their main image display order, you must first specify property_images:main_image(image_url, display_order) or main_image:main_image(image_url, display_order) in Advanced mode before you can use display_order as a sorting field.Limit number of rows ​With this option, you can limit the number of rows returned by Supabase. In the example below, you can see Supabase only returns 5 items as requested (from index 0 to 4):This can be very helpful when setting up custom pagination. You can bind the limit to a variable that is updated when a user clicks on a load more button for example.TIPYou can also limit the number of rows returned in a field referencing another table.Learn more about adding a limit on a referenced table.Limit range ​With this option, you can ask Supabase to return a range of items with a start index and end index, for example from 0 to 2:This can be very helpful when setting up custom pagination. You can bind the limit to a variable that is updated when a user clicks on a paginator element for example.Retrieve one row ​Returns first row of the query.Retrieve as CSV ​A CSV is basically just a spreadsheet file - like Excel, but simpler. Getting your Supabase data as a CSV is useful because:You can open it in Excel or Google Sheets to:Look through your data easilyMake charts and reportsShare data with team members who don't use technical toolsIt's like getting a snapshot of your data that you can:Save for your recordsEmail to othersUse in other softwarePrint or presentThe data retrieved from Supabase as a CSV uses ,, to separate rows.You can download this data in a nicely formatted CSV file byAdding the CSV plugin to your WeWeb project,Testing your Supabase action first to get a result you can use in the following Download data as CSV actionBinding the Supabase action result from the Events tab with a split formula to the Data field of the Download data as CSV action.Explain ​EXPLAIN is a PostgreSQL command that can help you understand and optimize how your queries are performing.This is an advanced backend feature that we recommend learning through the user documentation of Supabase and its underlying technology PostgreSQL."
  },
  {
    "h1": "Update​",
    "url": "https://docs.weweb.io/workflows/actions/supabase/database-update.html",
    "content": "Update ​Update is a SQL operation that modifies existing records in a database table. When you update data, you can change the values stored in one or more columns for records that match specific conditions. Think of it like editing cells in a spreadsheet - you're changing existing values rather than adding or removing rows.In the example below, we are using the Update row workflow that comes by default with WeWeb's data grid element and added a Supabase Update action:In our Update action, we:selected the vehicles table, andmapped the id of the record we want to update in Supabase to the id of the record we edited in the data grid:Then we bound the mileage field in our Supabase table to the data grid event to send the value in the mileage column of our data grid:And that's it!If you switch to Preview mode, you will be update your Supabase table from your WeWeb Data Grid:TIPThe way we mapped the values of the record to the Supabase fields we want to update is very specific to the Update row workflow of the data grid element, but you get the idea: you need to tell Supabase what record it should update and where it can find the new values.In the case of the data grid element, this information can be found in the Event of the Update row workflow."
  },
  {
    "h1": "Edge Functions​",
    "url": "https://docs.weweb.io/workflows/actions/supabase/invoke-edge-function.html",
    "content": "Edge Functions ​Edge Functions are mini-apps that run specific tasks when triggered by events in your app.For example:Send a welcome email when a customer signs up.Process Stripe payments and update database access levels during subscription purchases.They run on Supabase's servers, \"on the edge,\" close to your users, ensuring speed, reliability, and security. Key benefits include:Secure sensitive data: Store API keys and credentials safely on the server, away from the frontend.Connect to external services: Centralize and simplify interactions with third-party tools like Stripe (payments), SendGrid (emails), OpenAI (AI), or Twilio (SMS) and more, while improving performance and reliability.Handle heavy tasks: Offload resource-intensive work like image processing, data transformation, PDF generation, or batch operations.Automate workflows: Trigger actions based on user activity (e.g., welcome emails), database changes (e.g., low stock alerts), or scheduled tasks (e.g., daily reports).Pre-requisites ​To use Edge Functions in WeWeb, you'll need to create them on your local machine first, then upload them to Supabase. After that, you can invoke them in your WeWeb workflows using the Invoke Edge function action.TIPYou need to create Edge Functions locally because Supabase doesn't provide a web editor for function development. Local development also lets you test your functions and fix any issues before uploading them to Supabase's servers.Before starting, ensure you have:The latest version of the Supabase CLI to create and upload functions from your computer.Docker Desktop for a secure, isolated environment.A text editor like Visual Studio Code for writing and editing functions.TIPDocker Desktop replicates Supabase's server environment locally. Edge Functions must run in the exact same conditions locally as they will on Supabase's servers. Without this isolation, your computer's specific setup could make functions work locally but fail when deployed.Process overview ​Assuming you have all of the above, the process to invoke a Supabase Edge Function in your WeWeb app will go as follows:Create a project folder on your computer where you run Supabase locally.Create the function and edit it.Deploy the function to your Supabase project.Invoke the Supabase function in your WeWeb app.Let's go through this step by step.Setup Your Workspace ​Create a folder (e.g., my_project) and open it in Visual Studio Code:Open the terminal (command window) in VS Code:Set up Supabase locally ​Type supabase init in the terminal.This creates a new Supabase workspace in your folder.Say yes when VS Code asks to set up some helpful tools (for Deno, which runs code).This creates a bunch of new files in the my_project folder. Some files are for VS Code, and others are for the local Supabase setup.TIPDeno is a tool that runs JavaScript code outside of browsers, enabling edge functions to work. It acts as an interpreter, helping functions communicate with servers.Create a function ​Next, to create an Edge function in your project, run the command supabase functions new your-function-name.This creates a new file where you'll write your function.The index.ts file comes with an Edge function boilerplate that you can use as a starting point to write your own functions.TIPSupabase Edge functions are written in TypeScript. This is what the .ts file extension stands for.Learn more about how to write Supabase Edge functions.Test and deploy ​Open Docker Desktop. Run supabase start to test your function locally.WARNINGEnsure Docker Desktop is running. Otherwise, you'll encounter errors like:In the terminal, run supabase functions deploy your-function-name to deploy the function and then enter your Supabase project ID (found in project settings).Check Supabase dashboard to confirm upload, and that's it!Invoke the function ​In WeWeb, you can call Supabase Edge functions by:Selecting the Invoke an Edge function action in a workflow.Entering the function name (e.g., your-name-function).Configuring the request:Method: Choose the appropriate HTTP method (e.g., POST, GET).Authorization headers: Include a valid token to authenticate the request.Body (for POST): Include a JSON object (e.g., { \"name\": \"Joyce\" }).When tested, the response will match the format defined in the Supabase Edge function, such as:TIPAuthorization headers ensure only authorized clients (e.g., your WeWeb app) can access the Supabase Edge Function. They include tokens (e.g., JWT or API keys) to authenticate requests, which is essential for sensitive operations like database access or payments.TIPUse POST for sending data or performing actions that modify data (e.g., creating a record, processing a payment).Use GET for retrieving data or performing read-only operations (e.g., fetching a list of items).Use PUT or PATCH for updating data, and DELETE for removing data.CORS ​CORS (Cross-Origin Resource Sharing) is a safety feature that checks if your app is allowed to request data from different places. You might see CORS errors when connecting to Supabase edge functions.To resolve CORS issues, simply add this object to your edge function:typescript// At the top of your edge function file (index.ts): const corsHeaders = { 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Headers': 'authorization, content-type' } //Inside your edge function's response handler (where you return data to the frontend), modify your response to include these CORS headers: // This is where you modify the response to include CORS headers return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } })TIPCORS headers are set by the server (Edge Function), not the frontend. Use 'Access-Control-Allow-Origin': '*' to allow all domains or specify your app's domain (e.g., https://yourapp.com) for better security. These headers act as a basic security pass, allowing your app to communicate with the Edge Function.TIPTo optimize Edge Functions, consider breaking down tasks into smaller functions.Example: Instead of trying to process an entire video with one edge function, you could haveFunction 1 to extract video framesFunction 2 to analyze visual contentFunction 3 to transcribe audio"
  },
  {
    "h1": "Supabase storage​",
    "url": "https://docs.weweb.io/workflows/actions/supabase/storage-upload-file.html",
    "content": "Supabase storage ​Storage is a Supabase feature that lets you manage and store files in your application, similar to a file system in the cloud. It allows you to upload, organize, and serve files like images, documents, and videos, with built-in security controls to manage who can access them.If you have installed the Supabase data source plugin, you can allow users of your WeWeb app to upload files to Supabase with the Storage | Upload a file action in workflows.In the first two sections of this article, we will go through a couple of Supabase pre-requisites. If you're confident things are setup correctly in your Supabase project, skip ahead to the third section.Supabase bucket ​A bucket is a container for files within Supabase Storage, similar to a folder on your computer. Each bucket can be configured as public (accessible to everyone) or private (restricted access), and can have its own set of permissions and policies controlling who can upload, download, or modify files within it.Before attempting to setup file upload in your WeWeb app, make sure everything is setup correctly in your Supabase project.In the example above, we:Go to the Storage section of SupabaseCreate a new storage bucketName it your-bucketDecide that everyone can see the files added to this bucketDecide that there will be no restrictions on file size or formatSave our new bucketPrivate or public? ​Create a public bucket if you want everyone to be able to view the files that are stored in that bucket. For example, product images that are meant to be seen and shared easily.Create a private bucket if you want to be able to restrict who sees the files in a bucket. For example, purchase orders or invoices that are meant to be seen by authorized personel.Supabase policies ​If you want users of your WeWeb app to upload files to a Supabase bucket, you will need to create a Supabase policy to that effect:In the example above, we are saying that users need to be authenticated to INSERT or UPDATE a record in the your-bucket bucket.TIPThis is just one approach possible. You need to decide what conditions a user needs to meet to have the right to insert or update files in a bucket and right policies accordingly.Learn more about Supabase policies.WARNINGPublic buckets allow everyone to read (i.e. SELECT) data from the bucket. You will still need to do create INSERT, UPDATE, and DELETE policies if you want users to be able to add, update, or delete files in a public bucket.Now for the upload workflows in WeWeb.Upload elements ​To enable file uploads in your WeWeb app, you can work with the Upload file element or the Drag & Drop files element:In the element settings, you can decide if users should be allowed to upload one or more files:TIPUpload elements may come with a pre-built workflow that uploads files to WeWeb's CDN and allows you to send file URLs to the backend of your choice.Since you want to upload files directly to Supabase, feel free to remove pre-built workflows to start from scratch:Test data ​Before creating the upload to Supabase workflow, we recommend going to preview mode and uploading one or more files so that you have test data to work with when binding data in your workflow:Single file upload ​On the file upload element, create a workflow that triggers the Storage | Upload a file action On change:You will be invited to define what bucket the file should be sent to, the name of the file, and the file object itself.From bucket ​This is where you will input the name of the Supabase bucket where the file should be stored. In our case, we called it your-bucket.Path ​This is the name of the uploaded file with its extension:File ​This is the file object itself (notice how the Current value is an object with a lot of information about the file that was uploaded):That's it! If you test your workflow and go back to your Supabase bucket, you should see the file in storage.If you run into errors, make sure to go back to our section on Supabase RLS policies above.TIPWhen dealing with multiple inputs on the same page, renaming the file upload element in your layout can help you bind data more easily.Multiple file upload ​To allow multiple file uploads, ensure you have selected Multiple in the upload element settings:Loop through files ​Then, on the file upload element, create a workflow On change that loops through the value component variable:TIPBy default, when you're using the Drag & Drop files element, it will be called Input File Drop - multiple - value like in our example above but, if you are using a different element or renamed the element in the layout, it will have a different name.For example here, the fact that we renamed the element Uploaded pictures in our layout is reflected in the name of the component variable:What's important is that you select the component variable that refers to the value of the files uploaded. In the case of the multiple file upload, that variable should be an array.Test workflow ​Before adding the Supabase Storage | Upload a file action, we recommend uploading a couple of files in preview mode and testing your workflow:WARNINGThis step is very important. If you skip it, it will be much harder for you to bind data in the next step.Upload action ​Once you have uploaded a couple of files in preview mode and tested your workflow, you can add a Supabase Storage | Upload a file action.From bucket ​This is where you will input the name of the Supabase bucket where the file should be stored. In our case, we called it your-bucket.Path ​This is the name of the uploaded file with its extension:Here, because the user uploaded multiple files, we have to bind to the name inside the current item of the loop action of our workflow.File ​This is the file object itself (notice how the Current value is an object with a lot of information about the file that was uploaded):Here, because the user uploaded multiple files, we have to the current item of the loop action of our workflow.That's it! If you test your workflow and go back to your Supabase bucket, you should see the file in storage.If you run into errors, make sure to go back to our section on Supabase RLS policies above."
  },
  {
    "h1": "Time delay​",
    "url": "https://docs.weweb.io/workflows/actions/time-delay.html",
    "content": "Time delay ​The Time delay action pauses your workflow execution for a specified duration before continuing to the next action.Required field:Time (ms): The duration to pause in millisecondsIf you set the time to 1000, the workflow will pause for 1 second before proceeding to the next action.Use time delays when you need to introduce intentional pauses in your workflow, such as showing loading states, handling animations, or ensuring sequential timing of actions."
  },
  {
    "h1": "Update collection​",
    "url": "https://docs.weweb.io/workflows/actions/update-collection.html",
    "content": "Update collection ​The Update collection action optimizes UI updates after back-end data modifications by eliminating the traditional pattern of making an API request followed by a fetch collection action to refresh the UI.WARNINGAt present, Update collection will only work if your collection is a list. It will not work if your collection is an object. For example, if your API returns an object like so { id: 1, name: \"item1\" } or any other format that isn't an array/list of items, the action may not behave as expected. Make sure your data is always structured as a list of items.The problem it solves ​Previously in WeWeb, when modifying data through an API request (like deleting a user or updating a record), you had to follow a two-step process:Make an API request to modify back-end dataFetch the entire collection again to update the UIThis approach had some drawbacks:Required two server requestsCreated unnecessary network trafficIncreased server loadUltimately, these meant potentially unnecessary load times for the user of your app.The solution ​The Update collection action enables immediate UI updates by directly modifying the collection after a successful API request, eliminating the need to re-fetch the collection. This means you can:Immediately update your collectionUpdate your UI instantlyUse just a single API request to update your back-end dataUse cases ​Immediate user feedbackTemporary data viewsPerformance optimizationEnhanced user experienceClient-side data manipulationWARNINGThis action only changes what you see on the screen temporarily. These changes will be lost if you refresh the page. To permanently save your changes to your database, you must always use this action together with an API request.Update types ​Replace All ​The Replace All update type overwrites the entire content of a collection with new data. In the example below, we are setting the collection to have a text value of \"No collection\" and using the Log action to display it in the editor's Logs tab. This will show you the updated content of the collection after it's been replaced:Update ​Updates specific records in a collection while preserving the rest of the collection data.Configuration ​Position TypeBy index: Update by position (0 = first record)By id: Update by unique identifierMergeON: Updates only specified fields, keeps othersOFF: Replaces entire record with new dataDataAccepts an object: {\"fieldName\": \"newValue\"}Defines what to update in the recordExample with Merge ON: ​When modifying records with Merge ON, you can update specific fields while preserving other data:Collection : charactersPosition: 1 (second record)Merge: ONData: {\"status\": \"Dead\"}Example with Merge OFF: ​With Merge OFF, the provided data completely replaces the existing record:Collection: charactersPosition: 1 (second record)Merge: OFFData: {\"status\": \"Dead\"}Insert ​The Insert type adds a new record to your collection at a specified position (index), allowing you to temporarily add data while preserving existing records.TIPThe Data property for all update types except Delete must match what's in your collection:For simple values (text, numbers):Use the same type of value (example: for a collection of texts, provide a text value).For objects:With Merge ON: Provide just the fields you want to updateWith Merge OFF: Provide all fields since everything will be replacedDelete ​The Delete type removes a single record from your collection based on position or ID, leaving all other records unchanged.Refresh filters and sort ​Refresh Filters and Refresh Sort control whether collection settings are reapplied after updating data.FiltersON: items that no longer match your filters are automatically removed from the collection after your updateOFF: items stay in the collection view until manual refresh, even if they no longer match filtersSortON: items automatically move to their new positions when sorting values changeOFF: items maintain their current positions regardless of value changes"
  },
  {
    "h1": "Upload file (via WeWeb's CDN)​",
    "url": "https://docs.weweb.io/workflows/actions/upload-file.html",
    "content": "Upload file (via WeWeb's CDN) ​WARNINGThe Upload file action in WeWeb workflows allows you to upload a file to WeWeb's CDN.You can then use the URL from the file in the CDN to display it on a page or reference that URL in your database.If you want to bypass WeWeb's CDN and upload a file directly to your backend, you will need to:use the Encode file as Base64 workflow action,then make a request to send the encoded file to your backend.Learn more about the Encode file as Base64 actionELEMENT DEPRECATEDThe file upload elements referenced in the documentation below have now been deprecated and combined into a single, comprehensive file upload element. You can learn more about it here.File upload elements ​In WeWeb, you can work with two file upload element:one where the user browses through their folders to select a file, andone where the user can drag-and-drop their files on the pageYou will find both in the Add menu if you look for \"file\" or upload\" in the global search bar:File upload workflow ​In the example below, our users fill out a form and upload a resume to apply to a job.When they submit the form:we upload the user's file to WeWeb's CDNwe make an API request to create a record in our backendthen close the application popup1. Upload the user's file to WeWeb's CDN ​In the screenshot above, you can see that:we selected the Upload file action,decided what file(s) we wanted to upload by selecting the component variable of our file upload element, andtested the action to upload the file and generate the URL of where it is hosted on WeWeb's CDN.WARNINGBefore moving to the next step, make sure to click on Test action. This will generate the URL of where the file can be found. We will need this URL when we create the job application record in our backend in step 2.TIPIf you copy the URL generated by the Upload file action and paste it in a web browser, you’ll be able to see the image and where it is hosted.2. We map form inputs to our database ​In the case of the file upload, we bind the resume field in our database to the URL value returned by the first action of our workflow.Note that, because we are sending a URL to our backend, we need to make sure that the resume field type in our database is a string.TIPTo view and use the result from a previous action in a workflow, make sure to Test action first. The result from the previous action will be empty otherwise and you won't be able to bind it.Multiple file upload ​You can choose to upload multiple files at once in the file upload elements' specific settings:When you enable multiple file upload, the upload action will return an array of items (i.e. a list of URLs) instead of a single item (i.e. a single URL).Keep that in mind as you build your workflow and send the result of the upload action to your database.Delete uploaded files ​To delete files that your users uploaded to the WeWeb CDN via your WeWeb app, go to the Auth menu, and open the File Storage panel:TIPTo manage images and files you uploaded to your WeWeb project, go to the Moremenu, and open the Images or Files panel.Learn more about managing project files.Upload progress ​Each file upload element comes with a progress variable:By default, the value is 0. It increases as the files are uploaded. When the upload is complete, the value is 100.You can use this variable to display a loader or progress bar when files are being uploaded:TIPDisplaying a loader or progress bar when a file is being uploaded is a UX best practice because it helps the user understand something is happening.File size ​When you upload a file through an upload element, the result from the File upload action will include the file size:In the example above, you can see we use this information to tell the user how big the file they uploaded is.We could also use it to check that the user isn't trying to upload files that are too big and display a warning when they do.Bypass WeWeb's CDN ​The Upload file action uploads your files to WeWeb's CDN.If you want to upload files directly to your backend without going through WeWeb's CDN, you will need to:use the Encode file as Base64 workflow action instead,then make a request to send the encoded file to your backend.Learn how to upload files directly to your backend."
  },
  {
    "h1": "Xano request action​",
    "url": "https://docs.weweb.io/workflows/actions/xano-request.html",
    "content": "Xano request action ​When you add the Xano data source plugin to a WeWeb project, it unlocks the Xano Request action in workflows.Request action ​The Xano Request action in workflows allows you to make requests to the endpoints of the Xano instance you configured in WeWeb's Xano data source plugin:In the example above, you can see that we are configuring a call to:the POST poems endpoint,in the library API group of our Xano instance.This endpoint includes 3 inputs – poem, title, and author – which I bound to input variables from my WeWeb project.As a result, the values I send to Xano will vary based on the values in my WeWeb variables.Streaming ​A streaming response in Xano is a method of data transfer where information is sent and processed in chunks, rather than all at once. In the context of APIs, it means sending parts of the response to the client as they become available, instead of waiting for the entire response to be ready before sending anything.✅ Common use cases include:AI chatbots.Large datasets.Real-time updates.Long-running operations.Improve perceived performance.❌ When not to use streaming:small responses.Client limitations.Simple CRUD operations.Atomic operations (when the entire operation needs to succeed or fail as a unit, streaming partial results might not be appropriate).Pre-requisites ​To work with a streaming response from Xano in WeWeb, you will first need to create a streaming API endpoint in Xano.To set up your streaming API endpoint in Xano, we strongly recommend that you watch their video on “Streaming API Responses with Xano“:Request settings in WeWeb ​To receive a streaming response from Xano in WeWeb, you'll need to trigger a standard Xano Request action in a WeWeb workflow and ensure two things:The option Stream response is enabled.You created (and selected) a WeWeb array variable where you can store the streaming response.When we test the action, we can see our stream variable being updated line by line:This is because, in Xano, our variable was an array of lines. When we looped through the variable, each item was a line:If we wanted to stream the response character by character, we would need to change the function stack of our Xano endpoint so each item is a character.In the example below, instead of having an array variable in Xano formatted as a raw JSON, we have a strong variable and applied a split function to return the text as an array of character:Here's what it would look like in action:"
  },
  {
    "h1": "Branching​",
    "url": "https://docs.weweb.io/workflows/branching.html",
    "content": "Branching ​Branching allows you to create conditional logic flows in your workflows. At their core, these actions evaluate a condition you define - a value or formula that returns either true or false. The condition can compare values, check variables, or use any valid dynamic expression from your application. There are two types of branching:True/False splitMulti-option splitTrue/False split ​Splits the workflow into two paths based on a condition:If condition is true, executes the \"True\" branchIf condition is false, executes the \"False\" branchMulti-option split ​The Multi-option split action lets you create multiple conditional paths in your workflow. Each path can handle different scenarios with their own set of actions.Configuration ​Default branch: optional fallback if no conditions matchBranches: add multiple conditions and their corresponding actionsExample: error handling ​Here's how you can use it to handle different error types by changing a variable based on the condition:plaintext├── When: invalid email │ └── Then: Set specific error message ├── When: duplicate entry │ └── Then: Set duplicate error message └── Default Case: └── Set generic error messageTIPMulti-option split is incredibly flexible - you can add as many branches as your logic requires. Use the zoom controls located at the bottom of the editor to manage visibility when building complex workflows with multiple branches. This makes it perfect for creating sophisticated decision trees and handling multiple scenarios in your application."
  },
  {
    "h1": "Debugging workflows​",
    "url": "https://docs.weweb.io/workflows/debugging.html",
    "content": "Debugging workflows ​Debugging is an inherent part of app building.When you start working with workflows, there's a good chance you'll run into errors at times.In this article, we'll show you how to find out why a Workflow is failing, review common errors and go through a few real-life examples.The Workflow Debugger ​If you're experiencing issues with a Workflow, the easiest way to find out why it's not working is to test the entire Workflow.In the example below, we see that the issue comes from the first action – which is highlighted in red – and if we look into the API's response, we can see the issue is that the user tried to login with invalid credentials:If you're working with a more complex Workflow, you can test an individual Action instead of the entire Workflow.In the example below, we test the first action and see the same API response informing us that the user tried to login with invalid credentials:Status Codes ​When you test your Workflow, the Debugger will display a status code for every API request you make.It would be impossible to go through all the status codes you may encounter but let's review the ones you'll encounter most often.200 Success ​When your API request was processed as expected, you'll get a 200 success message.For example, when you successfully created a new record in your database:401 Unauthorized ​When the server will not process your request because it lacks valid authentication credentials.For example, when you try to create a new record in a table that's protected by an auth system without providing valid auth credentials:The solution: check the credentials you are using to authenticate and try again.403 Forbidden ​When the server understood the request but refuses to fulfill it.For example, when a normal user tries to perform an action that is reserved to users with an admin role.The solution: make sure you are testing the Workflow with a user who has the right to perform the action.422 Invalid value ​When the server doesn't like the data type you're sendingIn the example below, you can see the Mileage value we send on the left is a string (\"7864\") and returns an error whereas the value we send on the right is an integer (506) and returns a success message:The solution: make sure you are sending the data in a format that is expected by your database.In the example above, we mistakenly used a Short answer input on our first tried and finally got a success message when we changed the input type to Number.429 Too many requests ​Something that can happen often when you are using third-party APIs is that you can run into API rate limits.When that happens, you will see a 429 status error message.This has nothing to do with a mistake you made but everything to do with rate limits imposed by the API you're using.When that happens, you might want to read your API provider's documentation to check if there's something you can optimize on your side or if you can upgrade your plan with them to set higher limits.TIPIf you are working with an Airtable Collection in Dynamic Mode, you will probably run into this at least once so it's a good error code to keep in mind.Network error ​Some REST APIs, like the Rick & Morty API or Google Maps, accept client-side requests, i.e. requests from your users browsers.But many REST APIs, like Twitter, only accept server-side requests.By default, being a frontend builder, WeWeb's REST API plugin makes client-side requests.In the example below, you can see Twitter returns a Network error when we use the default configuration of a REST API request:This is known as a CORS issue. You can fix it by enabling the Proxy the request to bypass CORS issues option:WARNINGWhen you enable the Proxy the request to bypass CORS issues option, WeWeb will proxy the request to bypass CORS errors but the information will still be visible in the client.This option is not meant to keep private tokens private. You should never use private API keys in REST API calls made through the client.Debugging Checklist ​Ok, now that we've gone through a few examples of errors you can run into when working with workflows (and/or making API calls), let's recap the questions that will help you uncover mistakes and fix errors.Am I hitting API rate limits?Did I bind the correct variable to each key?Do my form input types match the field types in my database?Does the API request I am making require authentication headers?Does the API I am working with accept client-side requests or do I need to enable the server-side option?Do I have the correct trigger on the correct element? (e.g. \"on submit\" if I'm using a \"Form Container\")Did I use the correct API endpoint URL?Did I use the correct API request method? (e.g. POST, GET, DELETE)Do the names of my keys in WeWeb match the names of my keys in my backend? (bearing in mind these are case sensitive)"
  },
  {
    "h1": "Intro to workflows​",
    "url": "https://docs.weweb.io/workflows/intro-to-workflows.html",
    "content": "Intro to workflows ​Workflows are the engine of your WeWeb application, allowing you to create dynamic, interactive experiences without writing code. Think of workflows as a series of actions that happen in response to something - when a user clicks a button, types in a search bar, or when a page loads.Every workflow starts with a trigger - an event that sets things in motion. When that trigger occurs, WeWeb executes a sequence of actions you've defined. A comprehensive list of triggers can be found here.In the example below, when a user logs in, we redirect them to a different page based on their role:Inside workflows you can:Test the full workflowSet up a separate workflow if the default runs into an errorChoose the event that triggers the workflow (e.g. On click, On mouse enter, etc.)Add an action to the workflowTest an individual actionClick on the three vertical dots to copy/duplicate/delete an actionZoom in and out of the workflowEdit the settings of an actionClose the workflow view to return to the editorGlobal vs local workflows ​In WeWeb, you can create workflows in two ways:Global workflows located in the Actions tab that you can reuse across your applicationLocal workflows that are tied to a specific trigger or elementTIPWhile you can create local workflows for any trigger (app load, page load, button clicks, etc.), we recommend using global workflows whenever you find yourself repeating the same series of actions in different places, or when a workflow becomes too complex to manage. Make sure your workflows are maintainable and easy to understand.Learn more about how to create and reuse global workflowsFilter on current page ​To see if a global workflow is used on a page, you can toggle the All pages switch:In the example above, you can see we are currently on the Home page and only the Calculate shipping cost workflow is being used on that page.Page workflows ​Page workflows are specifically tied to individual pages and only execute when a user visits that particular page.To create page workflows, go to page settings > Trigger page workflowsApp workflows ​App workflows run across your entire website. If you create an app workflow that triggers when a page loads, it will run every time any page in your website loads. For example, if your website has a home page, about page, and contact page, the same workflow will run when someone visits any of these pages.To add a workflow at app level, go to More > Trigger app workflows.This will open a panel where you can create a new workflow:When you trigger a new workflow at app level, you can can choose to build the workflow from scratch or execute a global workflow.In the example below, on page scroll, throughout our app, we execute a global workflow to change the navbar color:TIPAlways give your workflows clear, descriptive names. This makes debugging easier and helps team collaboration.✅ Good: \"Validate User Input\", \"Send Welcome Email\" ❌ Bad: \"New Workflow\", \"Workflow 1\"You can use any naming format – just be consistent throughout your project.Recurring tasks ​WeWeb is a frontend builder. It follows that WeWeb's workflows allow you to build frontend logic, to display popup alerts, send an email when a user clicks on a button, or filter data for example.If you are looking to program recurring tasks, i.e. CronJobs, to perform regular scheduled actions, then this should be created in the logic of your backend - not your frontend."
  },
  {
    "h1": "Loops​",
    "url": "https://docs.weweb.io/workflows/loops.html",
    "content": "Loops ​A loop is a way to repeat an action multiple times without having to write it out each time. Instead of doing the same thing over and over manually, loops automate the repetition for you.WeWeb offers two types of loops for handling repetitive actions in your workflows: Iterator (for loop) and While.Iterator (for loop) ​An Iterator is like a helper that repeats an action for each item in a list. You pass a list of data and it automatically performs the same action on each item, one after another, until it has processed every item in your list.Example: ​Imagine building a travel planning app. A user types in three cities they want to visit: \"Paris\", \"London\" and \"Tokyo\"To show these cities on a map, you need their exact coordinates. A city name alone isn't enough - maps need numbers like (48.8566, 2.3522) for Paris. So your Iterator would:Take \"Paris\" firstAsk a geocoding API \"what are the coordinates for Paris?\"Put a pin on the map at those coordinatesMove on to \"London\" and do the same thingFinally handle \"Tokyo\"In the example above, you can see that:We loop through a list of city namesBased on the current item we are looping through which can be accessed through the Events tab, we make a dynamic API call to OpenCage to get the coordinates of the cityWe update a selectedCityMarkers variable that we will then bind to our map element to display markers on the selected citiesWithout an Iterator, you'd need to do this manually for each city. The Iterator automates this repetitive process, handling each city in your list one after another.In the video below, we demonstrate how to configure an Iterator to get coordinates for multiple cities using an API call in more detail:TIPThe video demo shows getting city coordinates, but you can apply this same pattern to any scenario where you need to process a list of items one by one.Accessing loop information ​Inside an Iterator loop, you can access information about the current iteration through the Events tab. Click on the Events tab in your formula editor to see these loop-specific values:Action.loop.index: The position of the current item in the list (starting at 0)Action.loop.item: The current item being processedAction.loop.items: The entire list of items being processedTIPYou will only be able to see the available loop information after the loop has ran at least once. After binding your list of data to the loop, you can either test your loop action or test the entire workflow to then be able to access the loop information.While ​A While loop continues running an action as long as a specified condition is true. Unlike an Iterator that processes a list, a While loop checks a condition before each iteration and continues running until that condition becomes false.Example: ​Imagine you're building a game where a player needs to reach a certain score to advance. Here's how a While loop would work:Set a condition (like \"score < 100\")Check the conditionIf true, run the actions inside the loopCheck the condition againContinue this cycle until the condition becomes falseTo set up a While loop:Add a While loop action to your workflowSet the condition to check (must be a boolean true/false)Add the actions you want to repeat inside the loopWARNINGAlways ensure your condition will eventually become false, or your loop will run indefinitely. If your loop never ends, it could freeze your page or cause poor performance.Loop Control ​Loop control actions allow you to change how a loop executes, giving you more precise control over your workflow. There are three main ways to control loop execution: Break loop, Continue loop, and Pass through condition.Break loop ​A Break loop action stops the loop immediately when its condition is met. This action only works inside Iterator or While loops and will skip any remaining iterations, continuing with the next action after the loop.In the example below, we loop through a list of cities [\"Paris\", \"London\", \"Tokyo\"]. Our Break loop condition is set to Action.loop.item = \"London\". The workflow logs \"Paris\", then \"London\", but when it reaches \"London\" the break condition becomes true and the loop stops. Since the loop ends at \"London\", \"Tokyo\" is never logged.Continue loop ​The Continue loop action skips the current loop iteration when its condition is met and moves on to the next item. This action only works inside Iterator or While loops.In the example below, we loop through a list of cities[\"Paris\", \"London\", \"Tokyo\"]. Our Continue loop condition is set to Action.loop.item = \"London\". The workflow logs \"Paris\", skips all actions when it hits \"London\", then processes and logs \"Tokyo\". As a result, you'll only see \"Paris\" and \"Tokyo\" in the logs.WARNINGPlace the Continue loop action at the beginning of your loop actions. Any actions placed before Continue loop will still execute before the skip occurs.Pass through condition ​A Pass through condition controls which actions in your workflow execute. When the condition is false, all following actions are skipped. When true, the workflow continues normally. While Pass through condition works in loops like Continue does, it can also be used anywhere in your workflow as a checkpoint to control which actions should run.For instance, If a user doesn't have permission (false), all following actions are skipped. If they do have permission (true), the workflow continues executing the next actions.TIPPosition your Pass through condition before any actions you want to conditionally execute.Actions placed before Pass through condition will always run regardless of the condition.This action can be used outside loops"
  },
  {
    "h1": "Triggers​",
    "url": "https://docs.weweb.io/workflows/triggers.html",
    "content": "Triggers ​Triggers define when your workflows should execute, allowing you to create interactive applications that respond to user actions and system events. From a button click to a page load, triggers are your way to make things happen at the right moment.TIPThe available triggers sometimes vary depending on the element or custom component type. For example, input fields have specific triggers like On change that aren't available for buttons, while forms have unique triggers like On submit. Some triggers are also exclusive to page-level workflows, such as On page load.Additionally, if using the Supabase plugin, you can access Supabase Realtime triggers, such as Realtime | Subscribe to channelElement triggers ​Element triggers activate when users interact with WeWeb elements:On focus: Fires when an element receives focus (e.g., clicking into an input field)On blur: Fires when an element loses focus (e.g., clicking away from an input field)Mouse events ​Mouse-related triggers capture various pointer interactions:On click: Triggers when an element is clickedOn double click: Activates upon two rapid successive clicksOn right click: Fires when the right mouse button is clickedOn mouse down: Triggers when a mouse button is pressed downOn mouse up: Fires when a mouse button is releasedOn mouse move: Activates when the mouse pointer movesOn mouse enter: Fires when the pointer enters an element's boundsOn mouse leave: Triggers when the pointer exits an element's boundsTouch events ​Touch event triggers support mobile and touch-screen interactions:On touch start: Fires when a touch point is placed on the screenOn touch move: Triggers when a touch point moves along the screenOn touch end: Activates when a touch point is removed from the screenOn touch cancel: Fires when a touch event is interruptedOther events ​Additional triggers for broader interaction scenarios:On scroll: Activates when an element or the window is scrolledLifecycle events ​When you visit a webpage, your browser creates something called the DOM (Document Object Model). Think of the DOM as a live representation of your webpage - like a blueprint that shows how all elements (buttons, text, images) are organized and connected. Every time you interact with a webpage, you're actually interacting with its DOM.Every modern web browser includes Developer Tools (often called \"Dev Tools\") that let you inspect the DOM. The most common way to access it is:Right-click on any element of a webpageSelect \"Inspect\" or \"Inspect Element\"This opens the browser's Dev Tools, usually showing you the \"Elements\" panel:WeWeb elements and components go through different stages from initialization to deletion in the DOM - this is called their lifecycle. Events related to component and element lifecycle:On created: Fires when an element is initialized in the DOMOn mounted: Triggers after an element is placed and ready to use on the pageBefore unmount: Executes just before an element is removed from the pageTIPThe 'On created' event is fired before the 'On mounted' event.When an element is 'created', it exists in the DOM but it may not have rendered on the page and/or be ready for user interaction. The 'On mounted' event signifies the element has been rendered on the page and is now ready for user interaction.Page and app triggers ​Lifecycle ​On app load (before fetching collections): The first trigger that fires when your app starts up. Happens before any data is loaded from your database, good for initial setup tasks.On app load: Happens after your app is completely ready and all data has been loaded. Everything is set up and ready to use.On page load (before fetching collections): Fires when someone opens a page, but before that page's data is loaded. Good for page preparation tasks.On page load: Triggers when a page and all its data is fully loaded and ready. The page is now complete and usable.On page unload: Happens when someone leaves a page - whether going to another page or closing the tab. Good for saving changes or cleanup.Listeners ​On page scroll: Triggers when page is scrolledOn page resize: Fires when browser window is resizedOn keydown: Triggers when a keyboard key is pressedOn keyup: Fires when a keyboard key is releasedTIPThe On page load (before fetching collections) trigger can be helpful when the data you load on the page depends on the current user's information.For example, you might want to display news items that the user has not yet read or load only the data that matches the user's role in the organization.Common use cases for app triggers include but are not limited to:Triggering the display of a cookie banner if applicable,Display a custom alert whenever there is a collection fetch error in your app,Change the color of a top navbar when the user scrolls down any page in your app.On error ​The On error workflow triggers when an error occurs at any step of the workflow execution. If any action/step in the workflow fails (e.g., an API call returns an error, or an action encounters an invalid value), the On error branch will execute.You can define specific actions under On error to:Notify users of the issue (e.g., display an error message).Log the error for debugging purposes.Retry the failed action or workflow step.On error vs on collection fetch error ​The on collection fetch error trigger is a special trigger that fires whenever any collection in your application fails to fetch its data. So if you have multiple collections like:users collectionproducts collectionorders collectionAnd you create a workflow starting with the on collection fetch error trigger, that workflow will run whenever any of these collections fails to fetch its data. This is different from the on error tab in a workflow which only handles errors within its specific workflow's actions."
  }
]